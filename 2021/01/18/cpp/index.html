<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>cpp - 饱食终日，无所事事</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="饱食终日，无所事事"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="饱食终日，无所事事"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="简单记录一下 《C++ Primer Plus》"><meta property="og:type" content="blog"><meta property="og:title" content="cpp"><meta property="og:url" content="http://example.com/2021/01/18/cpp/"><meta property="og:site_name" content="饱食终日，无所事事"><meta property="og:description" content="简单记录一下 《C++ Primer Plus》"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2021-01-18T01:48:06.000Z"><meta property="article:modified_time" content="2021-01-25T07:49:25.383Z"><meta property="article:author" content="lll"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/01/18/cpp/"},"headline":"cpp","image":["http://example.com/img/og_image.png"],"datePublished":"2021-01-18T01:48:06.000Z","dateModified":"2021-01-25T07:49:25.383Z","author":{"@type":"Person","name":"lll"},"publisher":{"@type":"Organization","name":"饱食终日，无所事事","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"简单记录一下 《C++ Primer Plus》"}</script><link rel="canonical" href="http://example.com/2021/01/18/cpp/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="饱食终日，无所事事" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-18T01:48:06.000Z" title="2021/1/18 上午9:48:06">2021-01-18</time>发表</span><span class="level-item"><time dateTime="2021-01-25T07:49:25.383Z" title="2021/1/25 下午3:49:25">2021-01-25</time>更新</span><span class="level-item">43 分钟读完 (大约6505个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">cpp</h1><div class="content"><p>简单记录一下</p>
<p>《C++ Primer Plus》</p>
<span id="more"></span>

<h2 id="第十二章-类和动态内存分配"><a href="#第十二章-类和动态内存分配" class="headerlink" title="第十二章 类和动态内存分配"></a>第十二章 类和动态内存分配</h2><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><p>C++ 编译器自动生成下面这些成员函数的定义（如果没有定义）：</p>
<ul>
<li><p>默认构造函数</p>
</li>
<li><p>默认析构函数</p>
</li>
<li><p>复制构造函数</p>
</li>
<li><p>赋值运算符</p>
</li>
<li><p>地址运算符</p>
</li>
<li><p>移动构造函数（C++ 11）</p>
</li>
<li><p>移动赋值运算符（C++ 11）</p>
</li>
</ul>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>指不接受参数的构造函数，有了默认构造函数后可以使用类似于初始化自动变量的方式来初始化一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Klunk lunk;</span><br></pre></td></tr></table></figure>

<p>如果定义一个类时没有提供任何构造函数，编译器将提供以下默认构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Klunk::Klunk() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以显式定义默认构造函数，常用于设置成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Klunk::Klunk()</span><br><span class="line">&#123;</span><br><span class="line">	klunk_ct = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在所有参数都有默认值的情况下，带有参数的构造函数也是默认构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Klunk(int n=0)</span><br><span class="line">&#123;</span><br><span class="line">	klunk_ct = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但只能有一个默认构造函数。</p>
<h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><p>复制构造函数用于将一个对象复制到<strong>新创建的</strong>对象中（通常是初始化过程，包括按值传递参数），而不是常规的赋值过程。</p>
<p>类的复制构造函数原型通常如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class_name(const Class_name &amp;);</span><br></pre></td></tr></table></figure>

<p>新建一个对象并将其初始化为同类现有对象时，复制构造函数将被调用，假设 motto 是一个 StringBad 对象，以下声明将调用复制构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBad ditto(motto);</span><br><span class="line">// 以下两种声明可能调用复制构造函数直接创建 metto 和 also，也可能使用复制构造函数生成临时对象后将内容赋值给 metto 和 also</span><br><span class="line">StringBad metoo = motto;</span><br><span class="line">StringBad also = StringBad(motto);</span><br><span class="line">// 以下声明会使用复制构造函数初始化匿名对象，并将指针赋值给 pStringBad</span><br><span class="line">Stringbad * pStringBad = new StingBad(motto);</span><br></pre></td></tr></table></figure>

<p>每当程序生成了对象副本，编译器都将使用复制构造函数。当函数按值传递对象或者返回对象时都将使用复制构造函数。</p>
<p>生成临时对象时也将使用复制构造函数。</p>
<p>默认的复制构造函数逐个复制非静态成员，复制的是成员的值（浅复制）。以下两种方式等效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBad sailor = sports;</span><br><span class="line">// 等效于</span><br><span class="line">StringBad sailor;</span><br><span class="line">sailor.str = sports.str;</span><br><span class="line">sailor.len = sports.len;</span><br></pre></td></tr></table></figure>

<p>解决方案为定义一个显式的复制构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBad::StringBad(const StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	num_strings++;</span><br><span class="line">	len = st.len;</span><br><span class="line">	str = new char[len+1];</span><br><span class="line">	std::strcpy(str, st.str);</span><br><span class="line">	cout &lt;&lt; num_strings &lt;&lt; &quot;: \&quot;&quot; &lt;&lt; str</span><br><span class="line">		&lt;&lt; &quot;\&quot; object created\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>将已有的对象赋值给另一个对象时将使用重载的赋值运算符。</p>
<p>类似于复制构造函数，赋值运算符的隐式实现也对成员进行逐个复制（浅复制）。</p>
<p>提供赋值运算符进行深度复制的定义时，实现与复制构造函数类似。但有一些不同：</p>
<ul>
<li>由于目标对象可能引用了之前分配的数据，函数应使用 <code>delete[] </code>释放这些数据</li>
<li>函数应当避免赋值给自身，否则释放内存时可能删除对象的内存</li>
<li>函数返回一个指向调用对象的引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBad &amp; StringBad::operator=(const StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">	if (this == &amp; st)</span><br><span class="line">		return *this;</span><br><span class="line">	delete [] str;</span><br><span class="line">	len = st.len;</span><br><span class="line">	str = new char [len+1];</span><br><span class="line">	std::strcpy(str, st.str);</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>delete []</code>是由于稍后将把一个新的字符串地址赋给 str，如果不释放，则这个字符串将一直保留在内存中。</p>
<p>子类赋值运算符中需要调用父类的赋值运算符时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baseDMA::operator=(hs);</span><br></pre></td></tr></table></figure>

<h3 id="定位-new-运算符"><a href="#定位-new-运算符" class="headerlink" title="定位 new 运算符"></a>定位 new 运算符</h3><p>对于使用定位 new 运算符分配的内存空间，应以与创建时相反的顺序显式调用析构函数来释放空间，而不是使用 delete。</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>仅可以在构造函数中使用初始化列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TTP:TTP (const string&amp; fn, const string&amp; ln) : firstname(fn), lastname(ln)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十三章-类继承"><a href="#第十三章-类继承" class="headerlink" title="第十三章 类继承"></a>第十三章 类继承</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>子类的构造函数应总是使用初始化列表显式调用合适的父类构造函数，否则将调用默认构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">class RP : public TTP</span><br><span class="line">&#123;</span><br><span class="line">	int rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line">RP::RP(int r, const string&amp; fn, const string&amp; ln) : TPP(fn, ln)</span><br><span class="line">&#123;</span><br><span class="line">	rate = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指向父类的指针可以用于指向子类，但只能使用父类的数据成员和公有方法。</p>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><p>virtual 有一个含义为 实际上的，事实上的，理解起来更容易。</p>
<p>被声明为 virtual 的方法在<strong>通过指针或引用调用</strong>时，将根据指针指向的对象的实际类型（而不是指针的类型，因为子类对象可以使用指向父类对象的指针）调用相应的方法。</p>
<p>virtual 关键字只用于类声明的方法原型中，不用在定义中。</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>如果子类的析构函数中包含了某些操作，那么父类应显式声明一个虚的析构函数。否则当使用父类指针的子类对象销毁时将只调用父类的析构函数。</p>
<p>用作基类的函数应总是声明一个虚析构函数。</p>
<h3 id="重新定义方法"><a href="#重新定义方法" class="headerlink" title="重新定义方法"></a>重新定义方法</h3><p>如果在子类中重新定义了父类的方法，但与父类的特征标不通，子类的方法将覆盖父类的方法，而不是重载。</p>
<p>经验法则：</p>
<ul>
<li>如果重新定义继承的方法，应确保与原来的原型完全想通。例外：如果返回基类的指针或引用，则可以修改为派生类的指针或引用</li>
<li>如果基类的有重载的方法需要重写，则在派生类中应重新定义所有的重载版本</li>
</ul>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>类似于接口，声明一个类方法时可以在声明后加 <code>=0</code> 使其成为纯虚方法，有纯虚方法的类不能实例化，基类中不必提供纯虚方法的定义，而子类必须覆盖纯虚方法。</p>
<h2 id="第十四章-代码重用"><a href="#第十四章-代码重用" class="headerlink" title="第十四章 代码重用"></a>第十四章 代码重用</h2><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><p>一个类中可以包含另一个类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Studnet</span><br><span class="line">&#123;</span><br><span class="line">	std::string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Studnet(const char* str): name(str) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>多数情况下应使用包含，除非需要使用私有继承的特性如使用 protected 成员或者需要重写虚方法。</p>
<h3 id="模板类-valarray"><a href="#模板类-valarray" class="headerlink" title="模板类 valarray"></a>模板类 valarray</h3><p>声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valarray&lt;type&gt; classname;</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double gpa[3] = &#123;3.1, 3.5, 3.8&#125;;</span><br><span class="line">valarray&lt;int&gt; v1;		// empty</span><br><span class="line">valarray&lt;int&gt; v2(6);	// 6 elements</span><br><span class="line">valarray&lt;int&gt; v3(10,8);	// 8 elements, each set to 10</span><br><span class="line">valarray&lt;double&gt; v4(gpa,4); // 4 elements, initialized with array</span><br></pre></td></tr></table></figure>

<h3 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h3><p>基类的公有成员将成为派生类的私有成员，基类的接口在培盛磊中可用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Student :private std::string</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(const char* str) :std::string(str)&#123;&#125; </span><br></pre></td></tr></table></figure>

<p>由于是继承，所以使用类名调用基类的构造函数。</p>
<p>使用类名和作用域解析符调用基类的方法，使用强制类型转换将子类转换为基类来访问基类对象本身</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double Student::Average() const</span><br><span class="line">&#123;</span><br><span class="line">	if (ArrayDb::size() &gt; 0)</span><br><span class="line">		return ArrayDb::sum;</span><br><span class="line">	else </span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const string&amp; Student::Name() const</span><br><span class="line">&#123;</span><br><span class="line">	return (const string&amp;) *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><p>基类的公有成员和保护成员都成为派生类的保护成员，继承层次较多时依然可用</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>必须使用访问控制符修饰每一个基类，否则默认为 private。</p>
<p>不使用虚基类的 MI 不会引入新的语法规则。</p>
<h4 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h4><p>假设 Singer 和 Waiter 继承自 Worker，SingingWaiter 继承自 Singer 和 Waiter</p>
<p>使用虚基类使 SingingWaiter 只包含一个 Worker（通常将包含两个，分别来自 Singer 和 Waiter）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Singer : virtual public Worker &#123;...&#125;;</span><br><span class="line">class Waiter : public virtual Worker &#123;...&#125;;</span><br><span class="line">class SingingWaiter : public Singer, public Waiter &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>此时 SingingWaiter 只包含 Worker 对象的一个副本，本质上时 Singer 和 Waiter 共享一个 Waiter 对象</p>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><p>如果 Worker 是虚基类，则在以下 MI 构造函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SingingWaiter(const Worker&amp; wk, int p = 0, int v = Singer::other)</span><br><span class="line">: Waiter(wk,p), Singer(wk,v) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>初始化了 panache 和 voice，但不会将 wk 的信息传递给子对象 Waiter 和 Singer（否则会由于使用两个 Worker 的构造函数导致冲突）。但创建派生类对象前必须调用基类构造函数，因此会使用 Worker 的默认构造函数。</p>
<p>如果不希望使用默认构造函数创建虚基类对象，则需要显式调用所需的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SingingWaiter(const Worker&amp; wk, int p =0, int v = Singer::other)</span><br><span class="line">: Worker(wk), Waiter(wk,p), Singer(wk,v) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>只能对虚基类这样做</p>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>应在 SingingWaiter 中重写的 <code>Show</code>方法指定使用 Singer 或是 Waiter 的版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void SingingWaiter::Show()</span><br><span class="line">&#123;</span><br><span class="line">	Singer::Show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>使用模板定义替换类声明，使用模板成员函数替换类成员函数，模板类也以<code>template &lt;typename Type&gt;</code>开头，Type 为泛型名，常用 Type 和 T，模板被调用时，Type 将被具体类型取代。</p>
<p>模板的具体实现和声明应放置在同一文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// stack.h</span><br><span class="line">#ifndef STACKTP_H_</span><br><span class="line">#define STACKTP_H_</span><br><span class="line">template &lt;class Type&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    enum &#123;MAX = 10&#125;;    // constant specific to class</span><br><span class="line">    Type items[MAX];    // holds stack items</span><br><span class="line">    int top;            // index for top stack item</span><br><span class="line">public:</span><br><span class="line">    Stack();</span><br><span class="line">    bool isempty();</span><br><span class="line">    bool isfull();</span><br><span class="line">    bool push(const Type &amp; item); // add item to stack</span><br><span class="line">    bool pop(Type &amp; item);        // pop top into item</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class Type&gt;</span><br><span class="line">Stack&lt;Type&gt;::Stack()</span><br><span class="line">&#123;</span><br><span class="line">    top = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class Type&gt;</span><br><span class="line">bool Stack&lt;Type&gt;::isempty()</span><br><span class="line">&#123;</span><br><span class="line">    return top == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class Type&gt;</span><br><span class="line">bool Stack&lt;Type&gt;::isfull()</span><br><span class="line">&#123;</span><br><span class="line">    return top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class Type&gt;</span><br><span class="line">bool Stack&lt;Type&gt;::push(const Type &amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    if (top &lt; MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        items[top++] = item;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class Type&gt;</span><br><span class="line">bool Stack&lt;Type&gt;::pop(Type &amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    if (top &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        item = items[--top];</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return false; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>使用时用具体类型替代泛型名进行实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;int&gt; is;</span><br><span class="line">Stack&lt;string&gt; ss;</span><br></pre></td></tr></table></figure>

<p>必须显式提供所需类型（不同于函数模板）。</p>
<p>与函数模板类似，有隐式实例化，显式实例化，和显式具体化，统称为具体化（specialization）</p>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>使用友元函数时，应使用具体化的对象，声明中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class HasFriend</span><br><span class="line">&#123;</span><br><span class="line">	friend void report(HasFriend&lt;T&gt; &amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且由于 report 不是成员函数，所以必须为其提供定义显式具体化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void report(HasFriend&lt;short&gt; &amp;) &#123;...&#125;;</span><br><span class="line">void report(HasFriend&lt;int&gt; &amp;) &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种解决方案时使友元函数本身成为模板</p>
<p>首先在类定义前面声明每个模板函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; void counts();</span><br><span class="line">template &lt;typename T&gt; void report(T &amp;);</span><br></pre></td></tr></table></figure>

<p>然后在函数中再次将模板声明为友元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class HasFriend</span><br><span class="line">&#123;</span><br><span class="line">	friend void counts&lt;T&gt;();</span><br><span class="line">	friend void report&lt;&gt; (HasFriend&lt;T&gt; &amp;)；</span><br><span class="line">	// or report&lt;HasFriend&lt;T&gt;&gt; (HasFriend&lt;T&gt; &amp;)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后要为友元提供模板定义</p>
<h4 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h4><p>可以使用 typedef 为模板具体化指定别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef std::array&lt;double, 12&gt; arrd;</span><br><span class="line">typedef std::array&lt;int, 12&gt; arri;</span><br></pre></td></tr></table></figure>

<p>也可以使用模板提供一系列别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">	using arrtype = std::array&lt;T,12&gt;;</span><br><span class="line"></span><br><span class="line">arraytype&lt;int&gt; days; // std::array&lt;int,12&gt;</span><br></pre></td></tr></table></figure>

<p>using = 语法用于非模板时等价于 typedef</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef const char *pc1;</span><br><span class="line">using pc2 = const char*;</span><br></pre></td></tr></table></figure>

<h2 id="第十五章-友元、异常和其他"><a href="#第十五章-友元、异常和其他" class="headerlink" title="第十五章 友元、异常和其他"></a>第十五章 友元、异常和其他</h2><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>被声明为友元的类可以访问 private 和 protected 成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Tv</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	friend class Remote;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以只将另外一个类的某个成员函数作为友元，此时需要重排声明顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Tv;		</span><br><span class="line">class Remote &#123;...&#125;;</span><br><span class="line">class Tv; </span><br><span class="line">&#123;</span><br><span class="line">	friend void Remote::set_chan();</span><br><span class="line">&#125;;</span><br><span class="line">// 函数定义</span><br></pre></td></tr></table></figure>

<p>也可以使两个类是彼此的友元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Tv</span><br><span class="line">&#123;</span><br><span class="line">friend class Remote;</span><br><span class="line">&#125;</span><br><span class="line">class Remote</span><br><span class="line">&#123;</span><br><span class="line">friend class Tv;</span><br><span class="line">&#125;</span><br><span class="line">// 函数定义</span><br></pre></td></tr></table></figure>

<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>可以在类中定义类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Queue</span><br><span class="line">&#123;</span><br><span class="line">	class Node</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在嵌套类中使用模板</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>cstdlib 中包含 abort 函数，它向 stderr 中发送消息，然后终止程序。</p>
<p>也可以使用返回值指出出现了错误。</p>
<p>也可以使用 try catch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int b = 0;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	if ( b==0 ) </span><br><span class="line">		throw &quot;Divided by 0&quot;;</span><br><span class="line">	a /= b;</span><br><span class="line">&#125;</span><br><span class="line">catch ( const char* s )</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常将对象用作异常类型，可以获得更多信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class err</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	double v1, v2;</span><br><span class="line">public:</span><br><span class="line">	err(double a, double b) :v1(a), v2(b) &#123;&#125;</span><br><span class="line">	void msg() &#123; cout &lt;&lt; &quot;v1: &quot; &lt;&lt; v1; &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	throw err(a,b)</span><br><span class="line">&#125;</span><br><span class="line">catch (err&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">	e.msg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try catch 中将总会为异常创建一个拷贝，即使声明了引用。此时声明引用的意义在于基类的引用可以用于子类。</p>
<h4 id="exception-类"><a href="#exception-类" class="headerlink" title="exception 类"></a>exception 类</h4><p>C++ 中提供了异常类的基类 <code>exception</code>类，在 <code>exception</code> 头文件中，它有 <code>what</code> 虚方法，返回一个字符串。</p>
<p>头文件 <code>stdexcept</code> 定义了 <code>logic_error</code> 和 <code>runtime_error</code> 等异常类，它们都是 exception 的公有派生。构造函数接受一个 string 对象为参数，为 what 方法提供数据。两个类都有一些派生类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// logic_error 系列</span><br><span class="line">domain_error</span><br><span class="line">invalid_argument</span><br><span class="line">length_error</span><br><span class="line">out_of_bouonds</span><br><span class="line"></span><br><span class="line">// runtime_error 系列</span><br><span class="line">range_error</span><br><span class="line">overflow_error</span><br><span class="line">underflow_error</span><br></pre></td></tr></table></figure>

<p>新标准中，当 new 无法分配请求的内存时会引发 <code>bad_alloc</code> 异常，它时 exception 的公有派生。以前则是返回空指针。新标准中也提供了失败时返回空指针的 new </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * pi = new (std::nothrow) int;</span><br></pre></td></tr></table></figure>

<h4 id="异常处理失败"><a href="#异常处理失败" class="headerlink" title="异常处理失败"></a>异常处理失败</h4><p>throw 一个异常后，如果在带有异常规范的函数中引发，则必须与异常规范列表中的某种一场匹配，否则称为意外异常，导致程序异常终止。如果异常不是在函数中引发的（或函数没有异常规范），则必须 catch ，否则称为未捕获的异常，默认情况下导致程序异常终止，但可以修改默认行为。</p>
<h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><p>运行阶段类型识别（Runtime Type Identification），只适用于包含虚函数的类层次结构，因为只有这种结构才应该将派生对象的地址赋给基类指针</p>
<p>C++ 有3个支持 RTTI 的元素：</p>
<ul>
<li>如果可能的话，<code>dynamic_cast</code>运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则返回0（空指针）</li>
<li><code>typeid</code> 运算符返回一个指出对象类型的值</li>
<li><code>type_info</code>结构存储了有关特定类型的信息</li>
</ul>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>新增4个类型转换运算符，规范转换过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dynamic_cast</span><br><span class="line">const_cast</span><br><span class="line">static_cast</span><br><span class="line">reinterpret_cast</span><br></pre></td></tr></table></figure>

<h2 id="第十六章-string-类和标准模板库"><a href="#第十六章-string-类和标准模板库" class="headerlink" title="第十六章 string 类和标准模板库"></a>第十六章 string 类和标准模板库</h2><h3 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a>string 类</h3><p>string 类在头文件 string 中，实际上是模板具体化<code>basic_string&lt;char&gt;</code>的一个 typedef，同时省略了有关内存管理的参数。</p>
<h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>size_type</code>是一个依赖于实现的整型，<code>npos</code>为字符串的最大长度，通常为<code>unsigned int</code>的最大值，<code>NBTS</code>（null-terminated string）表示 C字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">string(const char* s);</span><br><span class="line"> </span><br><span class="line">string(size_type n, char c);</span><br><span class="line">// 创建包含 n 个元素的 string 对象，每个元素都初始化为 c</span><br><span class="line"></span><br><span class="line">string(const string&amp; str);</span><br><span class="line">// 复制构造函数</span><br><span class="line"></span><br><span class="line">string()</span><br><span class="line">// 长度为0，默认构造函数</span><br><span class="line"></span><br><span class="line">string(const char* s, size_type n)</span><br><span class="line">// 初始化为 s 指向的 NBTS 的前 n 个字符，即使超过了 /0 </span><br><span class="line"></span><br><span class="line">template&lt;typename Iter&gt;</span><br><span class="line">string(Iter begin, Iter end);</span><br><span class="line">// 初始化为区间 [begin,end) 内的字符</span><br><span class="line"></span><br><span class="line">string(const string&amp; str, size_type pos = 0, size_type n = npos)</span><br><span class="line">// 初始化为对象 str 从 pos 开始的 n 个字符</span><br><span class="line"></span><br><span class="line">string(string &amp;&amp; str) noexcept</span><br><span class="line">// 移动构造函数，初始化为 string 对象 str，并可能修改 str（C++ 11）</span><br><span class="line"></span><br><span class="line">string(initialize_list&lt;char il)</span><br><span class="line">// 初始化为初始化列表 il 中的字符（C++ 11）</span><br></pre></td></tr></table></figure>

<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>C字符串的输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char info[100];</span><br><span class="line">cin &gt;&gt; info;			// read a word</span><br><span class="line">cin.getline(info,100); 	// read a line discard \n</span><br><span class="line">cin.get(info, 100);		// read a line ,leave \n in queue</span><br></pre></td></tr></table></figure>

<p>string 对象的输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string stuff;</span><br><span class="line">cin &gt;&gt; stuff;			// read a word</span><br><span class="line">getline(cin, stuff);	// read a line, discard \n</span><br></pre></td></tr></table></figure>

<p>getline 都有一个可选参数用于指定确定输入边界的字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.getline(info, 100, &#x27;:&#x27;); // discard :</span><br><span class="line">getline(cin, stuff, &#x27;:&#x27;);</span><br></pre></td></tr></table></figure>

<p>string 的 getline 函数读取字符存入 string 对象，直到三者之一发生：</p>
<ul>
<li>到达文件尾，此时会设置输入流的 eofbit，fail 和 eof 函数都将返回 true</li>
<li>遇到分界字符（默认为换行），将从输入流中删除分界字符，但不存储它</li>
<li>读取的字符达到最大允许值，（string::npos 和可供分配的内存字节数中较小的一个），将设置 failbit，fail 方法返回 true</li>
</ul>
<p>输入流对象有统计系统，遇到文件尾设置 eofbit，检测到输入错误设置 failbit，出现无法识别的故障设置 badbit，顺利时设置 goodbit。</p>
<p>string 的 operater&gt;&gt; 函数类似，但是遇到空白字符时将把该空白字符留在输入队列中。空白字符包括空格、换行和制表符，使用<code>isspace()</code>会返回 true。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>string 对象重载了全部 6 个关系运算符，按 ascii 码排列。</p>
<p>可以使用 <code>+= </code>拼接字符串</p>
<p>size 和 length 成员函数返回字符串中的字符数。</p>
<p>find 方法可以寻找子字符串或字符，可以指定开始位置，也可以指定将参数的前 n 个字符作为待查找的子字符串。除此之外，还有 rfind，find_first_of，find_last_of，find_first_not_of，find_last_not_of 等方法。</p>
<p>c_str 方法返回一个指向 C 字符串的指针</p>
<h4 id="字符串种类"><a href="#字符串种类" class="headerlink" title="字符串种类"></a>字符串种类</h4><p>string 库实际上基于一个模板类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class charT, class traits = char_traits&lt;charT&gt;,</span><br><span class="line">	class Allocator = allocator&lt;charT&gt; &gt;</span><br><span class="line">basic_string &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>模板 basic_string 有四个具体化，每个都有一个 typedef 名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef basic_string&lt;char&gt; string;</span><br><span class="line">typedef basic_string&lt;wchar_t&gt; wstring;</span><br><span class="line">typedef basic_string&lt;char16_t&gt; u16string;	// C++ 11</span><br><span class="line">typedef basic_string&lt;char32_t&gt; u32string;	// C++ 11</span><br></pre></td></tr></table></figure>

<h3 id="智能指针模板类"><a href="#智能指针模板类" class="headerlink" title="智能指针模板类"></a>智能指针模板类</h3><p>智能指针时行为类似于指针的类对象，但具有其他功能。对象过期时，对象的析构函数可以删除指向的内存。</p>
<p>有三个智能指针对象，auto_ptr（C++11 废弃），unique_ptr 和 shared_ptr（后面两个为C++11新增）。</p>
<p>使用 new 将返回的地址赋给这些对象，无需记住使用 delete 释放内存，智能指针过期时，将由析构函数自动释放内存。</p>
<p>智能指针不能用于非堆内存。</p>
<p>使用智能指针对象需要包含头文件 memory，在命名空间 std 中使用，然后使用通常的模板语法实例化所需类型的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">template&lt;class X&gt;</span><br><span class="line">class auto_ptr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit auto_ptr(X* p =0) throw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用，new double 是一个指针，是构造函数的参数</span><br><span class="line">auto_ptr&lt;double&gt; pd(new double);</span><br></pre></td></tr></table></figure>

<p>在多次使用同一个指针初始化多个 auto_ptr 时，会对同一个内存块多次调用 delete 导致崩溃。</p>
<p>多个 unique_ptr 不能指向同一个内存块，否则会引发编译错误。</p>
<p>多个 shared_ptr 指向同一个内存块时，存在一个计数器，记录 shared_ptr 的数量，只有减到 0 时才会释放内存。 </p>
<p>如果程序要使用多个指向同一个对象的指针应使用 shared_ptr，否则使用 unique_ptr。</p>
<h3 id="标准模板库（STL）"><a href="#标准模板库（STL）" class="headerlink" title="标准模板库（STL）"></a>标准模板库（STL）</h3><p>STL 提供了一组表示容器、迭代器、函数对象和算法的模板。STL 不是面向对象的编程，而是泛型编程（generic programming）。</p>
<p>STL 从广泛角度定义了一些非成员函数执行一些操作。</p>
<h4 id="容器模板类-vector"><a href="#容器模板类-vector" class="headerlink" title="容器模板类 vector"></a>容器模板类 vector</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include vector</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; ratings</span><br></pre></td></tr></table></figure>

<p>与 string 类相似，各种 STL 容器模板都提供一个可选的模板参数用来指定使用哪个分配器对象管理内存。</p>
<p>STL 的容器模板类都提供了一些基本方法，包括：</p>
<ul>
<li>size，返回容器中元素的数目</li>
<li>swap，交换两个容器的内容</li>
<li>begin，返回一个指向容器中第一个元素的迭代器</li>
<li>end，返回一个表示超过容器尾的迭代器</li>
</ul>
<p>vector 还有一些只有部分容器才有的方法：</p>
<ul>
<li>push_back(element)，将元素添加到 vector 末尾</li>
<li>erase(begin, end)，接受两个迭代器参数，删除区间内的元素，包括 begin 但不包括 end</li>
<li>insert(pos, begin, end)，接受三个迭代器参数，第一个指定新元素的插入位置，第二个和第三个定义插入的区间</li>
</ul>
<p>还有一些 STL 函数，它们是非成员函数：</p>
<ul>
<li>for_each，接受三个参数，前两个是定义容器区间的迭代器，最后一个是指向函数的指针（或者说函数对象），for_each 函数将被指向的函数应用于区间中的每个元素</li>
<li>random_shuffle 函数接受两个指定区间的迭代器参数，并随机排列区间中的元素，此函数要求容器类允许随机访问</li>
<li>sort，有两个版本，第一个版本接受两个定义区间的迭代器参数，使用 operator&lt; 比较，用于用户定义的类型时必须提供 operator&lt; 定义。第二个版本接受第三个参数，是想要使用的函数指针（函数对象），这个函数需要返回能转化为 bool 的值，返回 false 代表顺序错误。同样要求容器允许随机访问</li>
</ul>
<h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器使算法独立于使用的容器类型，具有以下特征</p>
<ul>
<li>能够解除引用</li>
<li>能将一个迭代器赋值给另一个</li>
<li>迭代器之间能够比较</li>
<li>能使用迭代器遍历容器中的元素，通过为迭代器 p 定义 ++p 和 p++ 实现</li>
</ul>
<p>有5种迭代器，分别是输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器。算法原型指出了需要的迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class InputIterator, class T&gt;</span><br><span class="line">InputIterator find(InputIterator first, InputIterator last, constT&amp; value);</span><br><span class="line"></span><br><span class="line">template&lt;class RandomAccessIterator&gt;</span><br><span class="line">void sort(RandomAccessIterator first, RandomAccessIterator last);</span><br></pre></td></tr></table></figure>

<p>算法会尽量使用低等级的迭代器。</p>
<h5 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h5><p>“输入”是从程序的角度来说，即来自容器的信息被视为输入。因此，输入迭代器可被容器用来读取容器中的信息。</p>
<p>对输入迭代器解除引用使程序能够读取容器中的值，但不一定能够修改，所以需要输入迭代器的算法不会改变容器中的值。</p>
<p>输入迭代器必须能够访问容器中所有的值，通过支持 ++ 运算符（前缀和后缀格式）实现。</p>
<p>输入迭代器使单项迭代器，可以递增不能倒退。基于输入迭代器的算法应该是 single-pass 的，不依赖于前一次遍历时的迭代器值，也不依赖于本次遍历中前面的迭代器值。</p>
<h5 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h5><p>与输入迭代器相反。</p>
<h5 id="正向迭代器"><a href="#正向迭代器" class="headerlink" title="正向迭代器"></a>正向迭代器</h5><p>正向迭代器只能使用++运算符便利容器，但是它总是按相同顺序便利一系列值，迭代器递增后依然可以对前面的迭代器值解出引用并得到相同的值，因此可以用于 多次通行算法。</p>
<p>即可以只读，也可以读写。</p>
<h5 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h5><p>相比于正向迭代器，同时支持 – 运算符。</p>
<h5 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h5><p>有些算法要求能够直接跳到容器中的任何一个元素（随机访问），除了双向迭代器的特性意外，同时需要支持随机访问。</p>
<p>在容器区间内，需要支持一系列运算，包括：+（迭代器和数字相加，顺序不限），-（迭代器减数字），+=，-=，[]，&lt;，&gt;，&gt;=，&lt;=。</p>
<h4 id="概念改进和模型——无需关联容器"><a href="#概念改进和模型——无需关联容器" class="headerlink" title="概念改进和模型——无需关联容器"></a>概念改进和模型——无需关联容器</h4><h3 id="函数对象——其他库"><a href="#函数对象——其他库" class="headerlink" title="函数对象——其他库"></a>函数对象——其他库</h3><h2 id="第十七章-输入、输出和文件"><a href="#第十七章-输入、输出和文件" class="headerlink" title="第十七章 输入、输出和文件"></a>第十七章 输入、输出和文件</h2><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><h4 id="流和缓冲区和-iostream-文件"><a href="#流和缓冲区和-iostream-文件" class="headerlink" title="流和缓冲区和 iostream 文件"></a>流和缓冲区和 iostream 文件</h4><p>C++ 程序把输入和输出看作字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。</p>
<p>iostream 文件包含了一些类：</p>
<ul>
<li>streambuf 类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法</li>
<li>ios_base 表示流的一般特征，如是否可读取，时二进制还是文本流等</li>
<li>ios 类基于 ios_base ，其中包含了一个指向 streambuf 对象的指针成员</li>
<li>ostream 和 istream 是从 ios 类派生而来的，分别提供了输出和输入方法</li>
<li>iostream 类是基于 istream 和 ostream 类的，继承了输入和输出方法。</li>
</ul>
<p>在程序中包含 iostream 文件将自动创建8个流对象：cin，wcin，cout，wcout，cerr，wcerr，clog，wclog。流对象存储了有关输出的数据成员，如显式数据时使用的字符宽度，小数位数，显示整数时采用的技术方法及 streambuf 对象的地址。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>对标准输出的重定向不影响 cerr 和 clog</p>
<h3 id="使用-cout-输出"><a href="#使用-cout-输出" class="headerlink" title="使用 cout 输出"></a>使用 cout 输出</h3><p>使用 ostream 对象和 &lt;&lt; 运算符输出，&lt;&lt;运算符应返回 ostream &amp;来连续输出</p>
<p>ostream 类还提供了 put（显示字符）和 write（显示字符串）方法</p>
<h4 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h4><p>使用 cout 将字节发送到标准输出时，字节被存储在缓冲区中。缓冲区被填满时，程序将刷新缓冲区，把内容发送出去，并清空缓冲区。输出到屏幕时，多数实现会在输入发生时刷新缓冲区，也可以使用控制符刷新缓冲区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &#x27;a&#x27; &lt;&lt; flush;</span><br><span class="line">cout &lt;&lt; &#x27;b&#x27; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>也可以使用函数刷新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush(cout)</span><br></pre></td></tr></table></figure>

<h4 id="用-cout-进行格式化"><a href="#用-cout-进行格式化" class="headerlink" title="用 cout 进行格式化"></a>用 cout 进行格式化</h4><p>ostream 插入运算将值转换为文本格式。</p>
<p>ios_base 类存储了描述格式状态的信息，通过使用 ios_base 的成员函数，可以控制字段宽度和小数位数。</p>
<h3 id="使用用-cin-输入"><a href="#使用用-cin-输入" class="headerlink" title="使用用 cin 输入"></a>使用用 cin 输入</h3><h3 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h3><h3 id="内核格式化"><a href="#内核格式化" class="headerlink" title="内核格式化"></a>内核格式化</h3></div><div class="article-licensing box"><div class="licensing-title"><p>cpp</p><p><a href="http://example.com/2021/01/18/cpp/">http://example.com/2021/01/18/cpp/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>lll</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-18</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/19/windows/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Windows 编程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/03/gopher/"><span class="level-item">Gopher 协议利用</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="lll"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">lll</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">52</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/1klnd" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CTF/"><span class="level-start"><span class="level-item">CTF</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Powershell/"><span class="level-start"><span class="level-item">Powershell</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/metasploit/"><span class="level-start"><span class="level-item">metasploit</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/notes/"><span class="level-start"><span class="level-item">notes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vulnhub/"><span class="level-start"><span class="level-item">vulnhub</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"><span class="level-start"><span class="level-item">漏洞复现</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-30T05:59:59.000Z">2021-08-30</time></p><p class="title"><a href="/2021/08/30/struts2/">Struts2 漏洞 S2-001</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-22T03:51:23.000Z">2021-07-22</time></p><p class="title"><a href="/2021/07/22/vulhub-debug/">vulhub-debug</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-20T02:31:56.000Z">2021-07-20</time></p><p class="title"><a href="/2021/07/20/fastjson/">Fastjson 漏洞相关</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-04T12:53:55.000Z">2021-05-04</time></p><p class="title"><a href="/2021/05/04/basic-pwn/">PWN 入门</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-14T08:35:37.000Z">2021-04-14</time></p><p class="title"><a href="/2021/04/14/xxe/">XXE 总结</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Powershell/"><span class="tag">Powershell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Struts2/"><span class="tag">Struts2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Writeup/"><span class="tag">Writeup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/flask/"><span class="tag">flask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/metasploit/"><span class="tag">metasploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssr/"><span class="tag">ssr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tables/"><span class="tag">tables</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tricks/"><span class="tag">tricks</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vulnhub/"><span class="tag">vulnhub</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"><span class="tag">渗透测试</span><span class="tag">3</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#第十二章-类和动态内存分配"><span class="level-left"><span class="level-item">1</span><span class="level-item">第十二章 类和动态内存分配</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#特殊成员函数"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">特殊成员函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#默认构造函数"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">默认构造函数</span></span></a></li><li><a class="level is-mobile" href="#复制构造函数"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">复制构造函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#赋值运算符"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">赋值运算符</span></span></a></li><li><a class="level is-mobile" href="#定位-new-运算符"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">定位 new 运算符</span></span></a></li><li><a class="level is-mobile" href="#初始化列表"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">初始化列表</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第十三章-类继承"><span class="level-left"><span class="level-item">2</span><span class="level-item">第十三章 类继承</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#构造函数"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">构造函数</span></span></a></li><li><a class="level is-mobile" href="#指针"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">指针</span></span></a></li><li><a class="level is-mobile" href="#虚方法"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">虚方法</span></span></a></li><li><a class="level is-mobile" href="#虚析构函数"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">虚析构函数</span></span></a></li><li><a class="level is-mobile" href="#重新定义方法"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">重新定义方法</span></span></a></li><li><a class="level is-mobile" href="#纯虚函数"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">纯虚函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第十四章-代码重用"><span class="level-left"><span class="level-item">3</span><span class="level-item">第十四章 代码重用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#包含"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">包含</span></span></a></li><li><a class="level is-mobile" href="#模板类-valarray"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">模板类 valarray</span></span></a></li><li><a class="level is-mobile" href="#私有继承"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">私有继承</span></span></a></li><li><a class="level is-mobile" href="#保护继承"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">保护继承</span></span></a></li><li><a class="level is-mobile" href="#多重继承"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">多重继承</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#虚基类"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">虚基类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类模板"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">类模板</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#友元"><span class="level-left"><span class="level-item">3.6.1</span><span class="level-item">友元</span></span></a></li><li><a class="level is-mobile" href="#模板别名"><span class="level-left"><span class="level-item">3.6.2</span><span class="level-item">模板别名</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#第十五章-友元、异常和其他"><span class="level-left"><span class="level-item">4</span><span class="level-item">第十五章 友元、异常和其他</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#友元类"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">友元类</span></span></a></li><li><a class="level is-mobile" href="#嵌套类"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">嵌套类</span></span></a></li><li><a class="level is-mobile" href="#异常"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">异常</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#exception-类"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">exception 类</span></span></a></li><li><a class="level is-mobile" href="#异常处理失败"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">异常处理失败</span></span></a></li></ul></li><li><a class="level is-mobile" href="#RTTI"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">RTTI</span></span></a></li><li><a class="level is-mobile" href="#类型转换运算符"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">类型转换运算符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第十六章-string-类和标准模板库"><span class="level-left"><span class="level-item">5</span><span class="level-item">第十六章 string 类和标准模板库</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#string-类"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">string 类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#构造函数-2"><span class="level-left"><span class="level-item">5.1.1</span><span class="level-item">构造函数</span></span></a></li><li><a class="level is-mobile" href="#输入"><span class="level-left"><span class="level-item">5.1.2</span><span class="level-item">输入</span></span></a></li><li><a class="level is-mobile" href="#方法"><span class="level-left"><span class="level-item">5.1.3</span><span class="level-item">方法</span></span></a></li><li><a class="level is-mobile" href="#字符串种类"><span class="level-left"><span class="level-item">5.1.4</span><span class="level-item">字符串种类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#智能指针模板类"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">智能指针模板类</span></span></a></li><li><a class="level is-mobile" href="#标准模板库（STL）"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">标准模板库（STL）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#容器模板类-vector"><span class="level-left"><span class="level-item">5.3.1</span><span class="level-item">容器模板类 vector</span></span></a></li></ul></li><li><a class="level is-mobile" href="#泛型编程"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">泛型编程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#迭代器"><span class="level-left"><span class="level-item">5.4.1</span><span class="level-item">迭代器</span></span></a></li><li><a class="level is-mobile" href="#概念改进和模型——无需关联容器"><span class="level-left"><span class="level-item">5.4.2</span><span class="level-item">概念改进和模型——无需关联容器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#函数对象——其他库"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">函数对象——其他库</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第十七章-输入、输出和文件"><span class="level-left"><span class="level-item">6</span><span class="level-item">第十七章 输入、输出和文件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#输入与输出"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">输入与输出</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#流和缓冲区和-iostream-文件"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">流和缓冲区和 iostream 文件</span></span></a></li><li><a class="level is-mobile" href="#重定向"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">重定向</span></span></a></li></ul></li><li><a class="level is-mobile" href="#使用-cout-输出"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">使用 cout 输出</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#刷新输出缓冲区"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">刷新输出缓冲区</span></span></a></li><li><a class="level is-mobile" href="#用-cout-进行格式化"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">用 cout 进行格式化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#使用用-cin-输入"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">使用用 cin 输入</span></span></a></li><li><a class="level is-mobile" href="#文件输入和输出"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">文件输入和输出</span></span></a></li><li><a class="level is-mobile" href="#内核格式化"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">内核格式化</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="饱食终日，无所事事" height="28"></a><p class="is-size-7"><span>&copy; 2021 lll</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>