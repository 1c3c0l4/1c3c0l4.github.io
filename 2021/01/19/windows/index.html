<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Windows 编程 - panic</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="panic"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="panic"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Windows 编程"><meta property="og:type" content="blog"><meta property="og:title" content="Windows 编程"><meta property="og:url" content="http://example.com/2021/01/19/windows/"><meta property="og:site_name" content="panic"><meta property="og:description" content="Windows 编程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2021-01-19T05:47:10.000Z"><meta property="article:modified_time" content="2022-09-19T02:56:41.203Z"><meta property="article:author" content="lll"><meta property="article:tag" content="windows"><meta property="article:tag" content="notes"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/01/19/windows/"},"headline":"Windows 编程","image":["http://example.com/img/og_image.png"],"datePublished":"2021-01-19T05:47:10.000Z","dateModified":"2022-09-19T02:56:41.203Z","author":{"@type":"Person","name":"lll"},"publisher":{"@type":"Organization","name":"panic","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"Windows 编程"}</script><link rel="canonical" href="http://example.com/2021/01/19/windows/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="panic" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/glance">Glance</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-19T05:47:10.000Z" title="2021/1/19 下午1:47:10">2021-01-19</time>发表</span><span class="level-item"><time dateTime="2022-09-19T02:56:41.203Z" title="2022/9/19 上午10:56:41">2022-09-19</time>更新</span><span class="level-item">2 小时读完 (大约13544个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Windows 编程</h1><div class="content"><p>Windows 编程</p>
<span id="more"></span>

<h1 id="Windows-程序设计"><a href="#Windows-程序设计" class="headerlink" title="Windows 程序设计"></a>Windows 程序设计</h1><h2 id="窗口和消息"><a href="#窗口和消息" class="headerlink" title="窗口和消息"></a>窗口和消息</h2><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>Windows 程序设计实质上是面向对象的升序设计，操作对象为窗口（window），程序员与用户的视角基本一致。</p>
<p>使用<code>RegisterClass</code>注册窗口类，使用<code>CreateWindow</code>创建窗口。</p>
<p>Windows 会在特定情况下向窗口发送消息，程序建立的每一个窗口都有窗口消息处理函数，Windows 会调用消息处理函数，函数根据收到的消息进行处理，完成后将控制权交还给 Windows。</p>
<p>Windows 程序开始执行后，系统为该程序建立一个消息队列，用于存放部分该程序将要接收到的消息。程序通过一段称为消息循环的代码从消息队列中取出消息，将消息发送给窗口处理函数。有些消息会直接发送给窗口处理函数，不会进入消息队列。消息循环一般如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="constructor">GetMessage(&amp;<span class="params">msg</span>, NULL, 0, 0)</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="constructor">TranslateMessage(&amp;<span class="params">msg</span>)</span>;	<span class="comment">// 处理关于键盘（鼠标）的消息</span></span><br><span class="line">	<span class="constructor">DispatchMessage(&amp;<span class="params">msg</span>)</span>;	<span class="comment">// 将消息发送到窗口处理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="窗口生命周期"><a href="#窗口生命周期" class="headerlink" title="窗口生命周期"></a>窗口生命周期</h3><ol>
<li>注册窗口类</li>
<li>建立窗口</li>
<li>显示窗口</li>
<li>消息循环</li>
<li>处理消息（窗口消息处理程序）</li>
</ol>
<h3 id="部分标识符"><a href="#部分标识符" class="headerlink" title="部分标识符"></a>部分标识符</h3><table>
<thead>
<tr>
<th>前缀</th>
<th>英文</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>ClassStyle</td>
<td>窗口样式</td>
</tr>
<tr>
<td>CW</td>
<td>CreateWindow</td>
<td>创建窗口</td>
</tr>
<tr>
<td>DT</td>
<td>DrawText</td>
<td>绘制文字</td>
</tr>
<tr>
<td>IDI</td>
<td>ID of Image</td>
<td>图标ID</td>
</tr>
<tr>
<td>IDC</td>
<td>ID of Cursor</td>
<td>光标ID</td>
</tr>
<tr>
<td>MB</td>
<td>MessageBox</td>
<td>消息框</td>
</tr>
<tr>
<td>SND</td>
<td>Sound</td>
<td>声音</td>
</tr>
<tr>
<td>WM</td>
<td>WindowMessage</td>
<td>窗口消息</td>
</tr>
<tr>
<td>WS</td>
<td>WindowStyle</td>
<td>窗口样式</td>
</tr>
</tbody></table>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>MSG</td>
<td>消息结构体</td>
</tr>
<tr>
<td>WNDCLASS</td>
<td>窗口类别结构体</td>
</tr>
<tr>
<td>PAINTSTRUCT</td>
<td>绘图结构</td>
</tr>
<tr>
<td>RECT</td>
<td>矩形结构</td>
</tr>
</tbody></table>
<h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>HINSTANCE</td>
<td>程序句柄</td>
</tr>
<tr>
<td>HWND</td>
<td>窗口句柄</td>
</tr>
<tr>
<td>HDC</td>
<td>设备句柄（Device Contxt）</td>
</tr>
</tbody></table>
<h2 id="输出文字"><a href="#输出文字" class="headerlink" title="输出文字"></a>输出文字</h2><h3 id="绘制和更新"><a href="#绘制和更新" class="headerlink" title="绘制和更新"></a>绘制和更新</h3><p>Windows 中只能在窗口的显示区域绘制文字和图形，而且不能确保显示区域内的内容一直保存直到下一次修改。</p>
<h3 id="WM-PAINT-消息"><a href="#WM-PAINT-消息" class="headerlink" title="WM_PAINT 消息"></a>WM_PAINT 消息</h3><p>Windows 向程序发送 WM_PAINT 消息时，表示窗口部分或全部显示区域需要重新绘制。</p>
<p>多数程序在 WinMain 进入消息循环之前会调用<code>UpdateWindow</code>来发送第一个 WM_PAINT 消息。之后在下列事件之一发生时，窗口消息处理程序会收到一个 WM_PAINT 消息：</p>
<ul>
<li>移动或显示窗口时</li>
<li>改变窗口大小时</li>
<li>代码使用<code>InvalidateRect</code>或<code>InvalidateRgn</code>函数刻意产生 WM_PAINT 消息</li>
<li>一个窗口或者下拉菜单挡住部分窗口时，Windows 尝试保存遮挡的部分，但不一定成功，失败时也会发送 WM_PAINT</li>
</ul>
<h3 id="有效矩形和无效矩形"><a href="#有效矩形和无效矩形" class="headerlink" title="有效矩形和无效矩形"></a>有效矩形和无效矩形</h3><p>窗口消息处理程序收到 WM_PAINT 消息后，会准备更新整个显示区域，但通常只需要更新一个较小的区域，称为无效区域/更新区域。</p>
<p>Windows 为每个窗口保存一个绘图消息结构，这个结构包含了包围无效区域的最小矩形的坐标和其他信息，这个矩形称为无效矩形。</p>
<p>如果消息处理程序处理 WM_PAINT 消息之前，显示区域的另一个区域也变为无效，Windows 将计算一个新的包围两个无效区域的无效区域并存入绘图信息结构，而不是将多个 WM_PAINT 放入消息队列。</p>
<p>在处理 WM_PAINT 期间，窗口消息处理程序调用了<code>BeginPaint</code>，整个区域都会变为有效，程序也可以调用<code>ValidateRect</code>使任意矩形变为有效。整个区域都有效时，目前消息队列中的 WM_PAINT 将被删除。</p>
<h3 id="WM-SIZE"><a href="#WM-SIZE" class="headerlink" title="WM_SIZE"></a>WM_SIZE</h3><p>当窗口尺寸发生变化时，Windows 会发送 WM_SIZE 消息。</p>
<h3 id="GDI"><a href="#GDI" class="headerlink" title="GDI"></a>GDI</h3><p>要在窗口的显示区域绘图（文字）需要使用 WIndows 图形设备接口（GDI）函数。</p>
<h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>键盘输入以消息形式传递给程序的窗口消息处理程序，Windows 有八种不通的消息。</p>
<h4 id="获得焦点"><a href="#获得焦点" class="headerlink" title="获得焦点"></a>获得焦点</h4><p>按下键盘时，只有一个窗口消息处理程序接受该消息，并且此消息包含窗口控件码。接收特定键盘事件的窗口具有输入焦点。</p>
<p>获取焦点时，Windows 发送 WM_SETFOCUS，失去焦点时，发送 WM_KILLFOCUS。</p>
<h4 id="队列和同步"><a href="#队列和同步" class="headerlink" title="队列和同步"></a>队列和同步</h4><p>按下键盘时，由 Windows 和键盘驱动程序将硬件扫描码转换成格式消息，消息首先存入 Windows 的系统消息队列中，当应用程序处理完前一个输入的消息时，Windows 从系统消息队列中取出下一个消息，放入程序的消息队列中。</p>
<h4 id="按键和字符"><a href="#按键和字符" class="headerlink" title="按键和字符"></a>按键和字符</h4><p>键盘消息分为按键和字符两类。对于能产生字符的按键或组合（比如 Shift+A）， Windows 发送按键和字符消息，否则（比如Home）只发送按键消息。</p>
<h3 id="按键消息"><a href="#按键消息" class="headerlink" title="按键消息"></a>按键消息</h3><p>按下按键时，Windows 发送 WM_KEYDOWN 或 WM_SYSKEYDOWN，松开按键时发送 WM_KEYUP 或 WM_SYSKEYUP，按键消息也有实践信息，可以通过调用<code>GetMessageTime</code>获得。</p>
<h4 id="系统按键和非系统按键"><a href="#系统按键和非系统按键" class="headerlink" title="系统按键和非系统按键"></a>系统按键和非系统按键</h4><p>包含 SYS 的为系统按键消息，通常程序忽略这些消息并交给<code>DefWindowProc</code>处理</p>
<h4 id="虚拟键码"><a href="#虚拟键码" class="headerlink" title="虚拟键码"></a>虚拟键码</h4><p>虚拟键码保存在四个消息（WM_(SYS)?KEY[DOWN|UP]）中的 wParam 参数中，标识按下或者释放的按键。</p>
<p>大部分虚拟键码以 VK 开头，定义在 WINUSER.H 中。</p>
<h4 id="lParam"><a href="#lParam" class="headerlink" title="lParam"></a>lParam</h4><p>低16位为重复计数，当消息处理速度不如消息的产生速度时，积累的多个 KEYDOWN 消息会组合成一个，并增加重复计数。</p>
<p>16-23位为 OEM 扫描码，一般忽略。</p>
<p>30位为该键的先前状态，释放为0，按下为1。</p>
<p>31位为转换状态，与先前不同则为1，相同为0。</p>
<h4 id="特殊按键"><a href="#特殊按键" class="headerlink" title="特殊按键"></a>特殊按键</h4><p>需要知道处理消息时是否按下了 Shift/Alt/Ctrl 或锁定键，可以调用<code>GetKeyState</code>函数获取消息。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">iState</span> = GetKeyState(VK_SHIFT)</span><br></pre></td></tr></table></figure>

<p>为负则按下了 Shift键。</p>
<h3 id="字符消息"><a href="#字符消息" class="headerlink" title="字符消息"></a>字符消息</h3><p>消息循环中，<code>TranslateMessage</code>函数将按键消息转换为字符消息。如果消息为 WM_KEYDOWN 或者 WM_SYSKEYDOWN，并且按键或者组合产生了一个字符，该函数就会将字符消息放入消息队列中。</p>
<h4 id="字符消息分类"><a href="#字符消息分类" class="headerlink" title="字符消息分类"></a>字符消息分类</h4><p>字符消息有四类：WM_CHAR、WM_DEADCHAR、WM_SYSCHAR 、WM_SYSDEADCHAR。</p>
<p>通常程序只处理 WM_CHAR。</p>
<p>字符消息与按键消息的 lParam 相同，wParam包含的是 ANSI 或 Unicode 字符代码。</p>
<h3 id="插入符号"><a href="#插入符号" class="headerlink" title="插入符号"></a>插入符号</h3><p>插入符号只在获取了焦点的窗口中有效，因此应在 WM_SETFOCUS 和 WM_KILLFOCUS 中处理。</p>
<h2 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h2><h3 id="鼠标消息"><a href="#鼠标消息" class="headerlink" title="鼠标消息"></a>鼠标消息</h3><p>鼠标移动过窗口的显示区域时，Windows 发送 WM_MOUSEMOVE 消息。二按下或松开按键时，发送以下消息：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>按下</th>
<th>松开</th>
<th>双击</th>
</tr>
</thead>
<tbody><tr>
<td>左</td>
<td>WM_LBUTTONDOWN</td>
<td>WM_LBUTTONUP</td>
<td>WM_LBUTTONDBLCLK</td>
</tr>
<tr>
<td>中</td>
<td>WM_MBUTTONDOWN</td>
<td>WM_MBUTTONUP</td>
<td>WM_MBUTTONDBLCLK</td>
</tr>
<tr>
<td>右</td>
<td>WM_RBUTTONDOWN</td>
<td>WM_RBUTTONUP</td>
<td>WM_RBUTTONDBLCLK</td>
</tr>
</tbody></table>
<p>以上9个消息中，lParam 低16位为 x 坐标，高16位为 y 坐标，坐标原点为显示区域的左上角。提取值时可使用宏</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="constructor">LOWORD(<span class="params">lParam</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> y = <span class="constructor">HIWORD(<span class="params">lParam</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>wParam 指出鼠标按键以及 Shift 和 Ctrl 的状态，通过与运算进行测试。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wParam <span class="meta">&amp; MK_SHIFT</span></span><br></pre></td></tr></table></figure>

<p>如果在活动窗口按下鼠标，该窗口会变成活动窗口，然后收到 WM_LBUTTONDOWN 消息。</p>
<p>希望收到双击消息时，注册窗口类应包含 SC_DBLCLK 标识符。</p>
<h3 id="非显示区域鼠标消息"><a href="#非显示区域鼠标消息" class="headerlink" title="非显示区域鼠标消息"></a>非显示区域鼠标消息</h3><p>在窗口内显示区域外，Windows 会发送非显示区域鼠标消息，通常不需要处理。</p>
<h3 id="命中测试"><a href="#命中测试" class="headerlink" title="命中测试"></a>命中测试</h3><p>代表非显示区域命中测试，优先于所有其他显示区域和非显示区域的鼠标消息。</p>
<p>通常程序将这个消息传给<code>DefWindowProc</code>，wParam 参数会存有测试结果：HTCLIENT 显示区域中，HTNOWHERE 不在窗口中，HTTRANSPARENT 窗口被另一个窗口覆盖， HTERROR 产生警示声音。</p>
<h3 id="拦截鼠标"><a href="#拦截鼠标" class="headerlink" title="拦截鼠标"></a>拦截鼠标</h3><p>在窗口外也可以接受鼠标消息。使用<code>SetCapture</code>拦截，<code>ReleaseCapture</code>释放。</p>
<h3 id="鼠标滚轮"><a href="#鼠标滚轮" class="headerlink" title="鼠标滚轮"></a>鼠标滚轮</h3><p>滚动滚轮产生 WM_MOUSEWHEEL 消息。</p>
<h2 id="子窗口控件"><a href="#子窗口控件" class="headerlink" title="子窗口控件"></a>子窗口控件</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>子窗口和父窗口在有必要时可以互相发送消息。</p>
<p>存在一些预定义的子窗口类别，使用 <code>CreateWindow</code>可以直接使用，然后使用<code>MoveWindow</code>调整位置和尺寸。</p>
<p><strong>子窗口获取焦点后，不能将焦点传回父窗口。</strong></p>
<h3 id="按钮类"><a href="#按钮类" class="headerlink" title="按钮类"></a>按钮类</h3><p>按钮样式以 BS 开头，子窗口 ID 必须强制转换为 HMENU 类型。</p>
<table>
<thead>
<tr>
<th>按钮样式</th>
<th>按钮</th>
</tr>
</thead>
<tbody><tr>
<td>BS_PUSHBUTTON</td>
<td>按钮</td>
</tr>
<tr>
<td>BS_DEFPUSHBUTTON</td>
<td>按键</td>
</tr>
<tr>
<td>BS_CHECKBOX BS_AUTOCHECKBOX</td>
<td>复选框</td>
</tr>
<tr>
<td>BS_RADIOBUTTON BS_AUTORADIOBUTTON</td>
<td>单选按钮</td>
</tr>
<tr>
<td>BS_GROUPBOX</td>
<td>分组方块</td>
</tr>
</tbody></table>
<h3 id="子窗口向父窗口发送消息"><a href="#子窗口向父窗口发送消息" class="headerlink" title="子窗口向父窗口发送消息"></a>子窗口向父窗口发送消息</h3><p>点击按钮，子窗口空间会向父窗口发送一个 <code>WM_COMMAND</code>消息，<code>LOWORD(wParam)</code>为子窗口ID，<code>HIWORD(wParam)</code>为通知码，<code>lParam</code>为子窗口句柄。</p>
<table>
<thead>
<tr>
<th>通知码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>BN_CLICKED</td>
</tr>
<tr>
<td>5</td>
<td>BN_DOUBLECLICKED or BN_DBLCLK</td>
</tr>
<tr>
<td>6</td>
<td>BN_SETFOCUS</td>
</tr>
<tr>
<td>7</td>
<td>BN_KILLFOCUS</td>
</tr>
</tbody></table>
<p>点击按钮时子窗口获得输入焦点，此时只有空格可用，忽略其他键盘输入。</p>
<h3 id="父窗口向子窗口发送消息"><a href="#父窗口向子窗口发送消息" class="headerlink" title="父窗口向子窗口发送消息"></a>父窗口向子窗口发送消息</h3><p>除了发送 WM 开头的消息，也可以发送 BM 开头的消息。</p>
<table>
<thead>
<tr>
<th>消息</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>BM_GETCHECK / BM_SETCHECK</td>
<td>取得或设定复选框和单选按钮的状态</td>
</tr>
<tr>
<td>BM_GETSTATE / BM_SETTATE</td>
<td>表示按钮是否处于被按下的状态</td>
</tr>
<tr>
<td>BM_SETSTYLE</td>
<td>改变按钮样式</td>
</tr>
</tbody></table>
<p>子窗口控件具有唯一的窗口句柄和 ID 值，知道一个可以获取另一个。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">id</span> = GetWindowLong(hwndChild, GWL_ID)<span class="comment">;</span></span><br><span class="line"><span class="attr">id</span> = GetDlgCtrlID(hwndChild)<span class="comment">;</span></span><br><span class="line"><span class="attr">hwndChild</span> = GetDlgItem(hwndParent, id)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="改变按钮文字"><a href="#改变按钮文字" class="headerlink" title="改变按钮文字"></a>改变按钮文字</h3><p>可以使用函数改变按钮文字</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">SetWindowText(<span class="params">hwnd</span>, <span class="params">pszString</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>获取目前文字</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iLength = <span class="constructor">GetWindowText(<span class="params">hwnd</span>, <span class="params">pszBuffer</span>, <span class="params">iMaxlength</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="可见和启用"><a href="#可见和启用" class="headerlink" title="可见和启用"></a>可见和启用</h3><p>建立窗口时如果没有设置 WS_VISIBLE，那么调用 ShowWindow 才会显示窗口。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">ShowWindow(<span class="params">hwndChild</span>, SW_SHOWNORMAL)</span>;<span class="comment">//不包含WS_VISIBLE显示子窗口  </span></span><br><span class="line"><span class="constructor">ShowWindow(<span class="params">hwndChild</span>, SW_HIDE)</span>；<span class="comment">//包含WS_VISIBLE,用来隐藏窗口  </span></span><br><span class="line"><span class="constructor">IsWindowVisible(<span class="params">hwndChild</span>)</span>;<span class="comment">//确认子窗口是否可见  </span></span><br><span class="line"><span class="constructor">EnableWindow(<span class="params">hwndChild</span>, FALSE)</span>;<span class="comment">//使子窗口不被启用   </span></span><br><span class="line"><span class="constructor">EnableWindow(<span class="params">hwndChild</span>, TRUE)</span>;<span class="comment">//使子窗口被启用   </span></span><br><span class="line"><span class="constructor">IsWindowEnabled(<span class="params">hwndChild</span>)</span>;<span class="comment">//确认子窗口是否被启用   </span></span><br></pre></td></tr></table></figure>

<h3 id="静态类别"><a href="#静态类别" class="headerlink" title="静态类别"></a>静态类别</h3><p>在 CreateWindow 函数中指定窗口为 static，就可以建立静态文字的窗口控件，它不接受鼠标和键盘输入，也不发送 WM_COMMAND 消息。</p>
<p>鼠标在静态子窗口中移动或按下时，子窗口会拦截 WM_NCHITTEST 消息并将 HTTRANSPARENT 的值传给 Windows，Winodws 再发送相同的 WM_NCHITTEST 消息给父窗口，通常父窗口不处理这个消息，发送给<code>DefWindowProc</code>。</p>
<h3 id="滚动条类别"><a href="#滚动条类别" class="headerlink" title="滚动条类别"></a>滚动条类别</h3><p>建立窗口时通过加入 WS_VSCROLL 和 WS_HSCROLL 可以加入滚动条。</p>
<h3 id="编辑框类别"><a href="#编辑框类别" class="headerlink" title="编辑框类别"></a>编辑框类别</h3><h2 id="菜单及其他资源"><a href="#菜单及其他资源" class="headerlink" title="菜单及其他资源"></a>菜单及其他资源</h2><p>资源保存在 EXE 文件中，在不可执行程序的数据区。</p>
<h2 id="多任务和多线程"><a href="#多任务和多线程" class="headerlink" title="多任务和多线程"></a>多任务和多线程</h2><h3 id="Windows-中的多线程"><a href="#Windows-中的多线程" class="headerlink" title="Windows 中的多线程"></a>Windows 中的多线程</h3><p>通过<code>CreateThread</code>创建线程</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hThread = <span class="constructor">CreateThread(&amp;<span class="params">security_attributes</span>, <span class="params">dwStackSize</span>, ThreadProc, <span class="params">pParam</span>, <span class="params">dwFlags</span>, &amp;<span class="params">idThread</span>)</span></span><br></pre></td></tr></table></figure>

<p>ThreadProc 是一个函数指针，指向线程函数，可以任意命名，但必须有如下格式</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="constructor">ThreadProc(PVOID <span class="params">pParam</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>pParam 就是传给 ThreadProc 的参数。</p>
<p>dwFlags 通常设置为零，如果设置为<code>CREATE_SUSPENDED</code>，表示这个线程创建后不会立即执行，保持在挂起状态，直到调用<code>ResumeThread</code>。</p>
<p>idThread 是一个指针，指向接受新线程ID的变量。</p>
<p>使用<code>_beginThread</code>函数创建线程，调用后，此线程函数中的代码和其他会被此线程调用的函数，会与程序中的其他代码同时运行，两个或多个线程可以使用一个进程中的相同函数。静态变量时所有线程共享的，自动局部变量（存储在栈上）是每个线程私有的数据。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_beginThread(<span class="keyword">Thread</span>, <span class="number">0</span> <span class="built_in">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区（Critical Section）用于防止共享的数据呗破坏。使用临界区前必须定义一个临界区对象，然后初始化。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"><span class="constructor">InitializeCriticalSection(&amp;<span class="params">cs</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>一个线程可以通过调用<code>EnterCriticalSection</code>进入临界区</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">EnterCriticalSection(&amp;<span class="params">cs</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>此时这个线程拥有这个临界区对象。两个线程不能同时拥有同一个临界区对象。如果一个线程进入了临界区，下一个线程尝试进入同一个临界区时将被挂起，直到第一个对象调用<code>LeaveCriticalSection</code>才会返回</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">LeaveCriticalSection(&amp;<span class="params">cs</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>不需要临界区对象时，可以删除</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">DeleteCriticalSection(&amp;<span class="params">cs</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>临界区机制涉及互斥（mutual exclusion），任何时刻只有一个线程拥有临界区。临界区的局限在于只能在同一个进程中使用。如果需要在进程间实现互斥，则应使用互斥对象（mutex）。</p>
<h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><p>事件对象有两种状态，已触发（已设置）或未触发（已复位）。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hEvent = <span class="constructor">CreateEvent(&amp;<span class="params">sa</span>, <span class="params">fManual</span>, <span class="params">fInitial</span>, <span class="params">pszName</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>sa 是指向 SECURITY_ATTRIBUTES 的引用，pszName 是事件对象名，这两个参数只在事件对象在进程间共享时使用，单进程环境中通常被设置为 NULL。</p>
<p>fInitial 表示事件初始的触发状态，TRUE 为已触发。</p>
<p>fManual 表示是否手动设置。</p>
<p>触发或解除出发使用以下函数</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">SetEvent(<span class="params">hEvent</span>)</span>;</span><br><span class="line"><span class="constructor">ResetEvent(<span class="params">hEvent</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>等待事件触发</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">WaitForSingleObject(<span class="params">hEvent</span>, <span class="params">dwTimeOut</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果事件处于触发状态，该函数会立刻返回；否则会等待事件触发，最长等待 dwTimeOut 毫秒。dwTimeOut 可设置为 INFINITE。</p>
<p>如果 CreateEvent 的 fManual 参数为 FALSE，那么 WaitForSingleObject 返回后，事件对象的触发状态会自动设置为未触发。</p>
<h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>线程本地存储（Thread Local Storage）是线程私有并一直存在的存储单元。</p>
<p>使用线程本地存储，首先需要创建一个包含所有静态私有数据的的结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">&#125; DATA, *DATA;</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>TlsAlloc</code>获取一个索引</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dwTlsIndex</span> = TlsAlloc()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这个索引可以保存在全局变量中，或者通过参数结构传递给线程函数。</p>
<p>线程函数一开始为这个数据结构分配内存并调用 TlsSetValue</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TlsSetValue(<span class="name">dwTlsIndex</span>, GlobalAlloc(<span class="name">GPTR</span>, sizeof(<span class="name">DATA</span>)))<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这个函数将指向线程本地数据结构的指针和特定的线程以及特定的线程索引关联。现在可以使用以下方法访问这个指针</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PDATA pdata<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line"><span class="attribute">pdata</span> = (PDATA) TleGetValue(dwTlsIndex)<span class="comment">;</span></span><br><span class="line">pdata-&gt;a<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>线程函数终止运行之前释放已分配的内存</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">GlabalFree</span>(<span class="title">TlsGetValue</span>(<span class="variable">dwTlsIndex</span>));</span></span><br></pre></td></tr></table></figure>

<p>所有使用这个本地存储的线程结束后，在主线程释放索引</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">TlsFree(<span class="params">dwTlsIndex</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用前置符<code>__declspec(thread)</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">__declspec(<span class="params">thread</span>)</span> <span class="built_in">int</span> iGlobal = <span class="number">1</span>;			<span class="comment">//定义全局静态变量</span></span><br><span class="line"><span class="constructor">__declspec(<span class="params">thread</span>)</span> static <span class="built_in">int</span> iLocal = <span class="number">1</span>;	<span class="comment">//定义函数内部的静态变量</span></span><br></pre></td></tr></table></figure>

<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><h3 id="关于库的基本知识"><a href="#关于库的基本知识" class="headerlink" title="关于库的基本知识"></a>关于库的基本知识</h3><p>动态链接库一般不能直接执行，而且他们一般也不接收消息。他们是包含许多函数的独立文件，这些函数可以被应用程序和其他DLL调用以完成默写特定的工作。一个动态链接库只在另一个模块调用其所包含的函数时才会被启动。</p>
<p>动态链接指 Windows 的链接过程。这个过程中它把模块中的函数调用与在库模块中的实际函数链接在一起。静态链接一般是在程序开发过程中发生的，用于把一些文件链接在一起创建一个 Windows 可执行文件。这些文件包括各种各样的对象模块（.OBJ），运行时库文件（.LIB），通常还有已编译的资源文件（.RES）。与其相反，动态链接发生在程序运行时。</p>
<p>一些动态链接库（如字体文件）被称为 resource-only 的，它们只包含数据，没有代码。</p>
<p>动态链接库的扩展名是任意的，但只有扩展名为 .DLL 的动态链接库才能被 Windows 自动加载。如果该文件有其他的扩展名，则程序必须调用<code>LoadLibrary</code>或<code>LoadLibraryEx</code>函数加载相应模块。</p>
<h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>除了动态链接库，还有对象库（object library）和导入库（import library）。</p>
<p>对象库是扩展名为 .LIB 的文件，这个文件中的代码在运行链接器进行静态链接时被添加到程序的 .EXE 文件中。</p>
<p>导入库是一种特殊的对象库，扩展名也是 .LIB。链接器用它来解析源代码中的函数调用。然而导入库不含代码，它给链接器提供信息，以建立 .EXE 文件中用于动态链接的重定位表格。</p>
<h4 id="一个简单的DLL"><a href="#一个简单的DLL" class="headerlink" title="一个简单的DLL"></a>一个简单的DLL</h4><p>DLL 中供应用程序所用的函数必须先导出，EXPORT 关键字确保函数名称被添加到 .DLL 文件中，使得链接器在链接使用这些函数的应用程序时可以正确解析该函数名，并且确保这些函数在 DLL文件中可见。</p>
<p>如果头文件由 C++ 模式编译，则 EXPORT 标识符会包含存储类关键字<code>__declspec(dllexport)</code>和<code>exter &quot;C&quot;</code>，这可以防止编译器对 C++ 函数进行名称重整，使 C 和 C++ 程序都能使用该 DLL。</p>
<h4 id="库的入口点和退出点"><a href="#库的入口点和退出点" class="headerlink" title="库的入口点和退出点"></a>库的入口点和退出点</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> WINAPI DllMain (<span class="keyword">HINSTANCE</span> <span class="keyword">hInstance</span>, DWORD fdwReason, PVOID pvReserved)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>当库第一次开始和终止时， DllMain 都会被调用。DllMain 的第一个参数时库的实例句柄。如果库使用的资源需要实例句柄，则应该把 hInstance 作为一个全局变量保存。</p>
<p>fdwReason 参数可以是四个值中的一个，用来说明 Windows 调用 DllMain 函数的原因。一个程序可以被多次加载，并在 Windows 环境下同时运行，每一次程序加载都可以认为是一个独立的进程。</p>
<p>当 fdwReason 值为 <code>DLL_PROCESS_ATTACH</code>时，表明动态链接库已经被映射到一个进程的地址空间，这相当于一个初始化信号，让库针对所服务进程的后续请求进行初始化工作。在一个进程的整个生命周期内，DllMain 只有一次会在调用中带有<code>DLL_PROCESS_ATTACH</code>参数。</p>
<p>如果初始化成功，DllMain 应该返回非零值，否则将导致 Windows 无法运行该程序。</p>
<p>fdwReason 值为 <code>DLL_PROCESS_DETACH</code>时，表示这个进程不再需要该 DLL 了，这给了库一个自我清理的机会。</p>
<p>fdwReason 值为<code>DLL_THREAD_ATTACH</code>时，表示一个关联的进程创建了一个新的线程，该线程终止时，Windows 会以 fdwReason 参数为 <code>DLL_THREAD_DETACH</code> 调用 DllMain。即使之前没有<code>DLL_THREAD_ATTACH</code>的情况下，也可能出现<code>DLL_THREAD_DETACH</code>的调用，例如动态链接库连接到一个进程时，该线程已经创建。以<code>DLL_THREAD_DETACH</code>调用时，线程仍然存在，它甚至还可以在此过程中发送线程消息，但它不应该再使用<code>PostMessage</code>。</p>
<h4 id="在-DLL-中共享内存"><a href="#在-DLL-中共享内存" class="headerlink" title="在 DLL 中共享内存"></a>在 DLL 中共享内存</h4><p>Windows 让同时使用相同动态链接库的进程相互隔离。</p>
<h1 id="Windows-核心编程"><a href="#Windows-核心编程" class="headerlink" title="Windows 核心编程"></a>Windows 核心编程</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="Windows-函数的错误"><a href="#Windows-函数的错误" class="headerlink" title="Windows 函数的错误"></a>Windows 函数的错误</h3><p>调用 Windows 函数时，会先验证参数，然后开始执行。如果传入的参数无效，或者由于其他原因导致操作无法执行，则由返回值指出函数因为某些原因失败了。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>调用成功返回值</th>
<th>调用失败返回值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>VOID</td>
<td></td>
<td>该函数不可能失败</td>
<td></td>
</tr>
<tr>
<td>BOOL</td>
<td>非0值</td>
<td>0</td>
<td>应检查其是否不为 FALSE</td>
</tr>
<tr>
<td>HANDLE</td>
<td>标识一个可操纵对象</td>
<td>NULL 或 INVALID_HANDLE_VALUE（通常为-1）</td>
<td></td>
</tr>
<tr>
<td>PVOID</td>
<td>标识一个数据块的内存地址</td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td>LONG/DWORD</td>
<td>LONG 或 DWORD</td>
<td>0 或 -1</td>
<td></td>
</tr>
</tbody></table>
<p>必要时查看 Platform SDK 文档。</p>
<h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>在内部，Windows 函数检测到错误时，使用线程本地存储区机制（thread-local storage）将错误代码与主调i线程（calling thread）关联，在返回时用返回值指出发生了错误。使用<code>GetLastError</code>函数查看错误，该函数返回上一个函数调用设置的线程的 32 位错误代码。</p>
<p>Windows 函数失败后应立刻调用 <code>GetLastError</code>，因为下一个函数很可能改写此值，即使成功调用的函数也可能用 <code>ERROR_SUCCESS</code> 改写此值。成功调用也可能有不同的情况，需要获取额外信息时也应调用<code>GetLastError</code>。</p>
<p><code>WinError.h</code>头文件包含了 MS 定义的错误代码列表，每个错误由消息ID（宏），消息文本（注释）和编号（LONG值）组成</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define ERROR_INVALID_FUNCTION 1L</span></span><br><span class="line"><span class="regexp">//</span> MessageId: ERROR_INVALID_FUNCTION</span><br><span class="line"><span class="regexp">//</span> MessageText:</span><br><span class="line"><span class="regexp">//</span>Incorrect <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure>

<p>使用<code>FormatMessage</code>函数可以将错误代码转换为相应的文本描述，该函数也有翻译功能。</p>
<h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><p>编写函数时，通过设置错误代码（调用<code>SetLastError</code>）并返回指出发生了错误的值（FALSE，INVALID_HANDLE_VALUE，NULL 或其他值）来指出发生了错误</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">VOID</span> <span class="function"><span class="title">SetLastEror</span>(<span class="variable">DWORD</span> <span class="variable">dwErrCode</span>)</span></span><br></pre></td></tr></table></figure>

<p>尽量使用<code>WinError.h</code>中的代码，在需要时创建自己的错误代码，它是一个32位数，由以下几个字段组成</p>
<table>
<thead>
<tr>
<th>位</th>
<th>31-30</th>
<th>29</th>
<th>28</th>
<th>27-16</th>
<th>15-0</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>严重性</td>
<td>MS/客户</td>
<td>保留</td>
<td>Facility代码</td>
<td>异常代码</td>
</tr>
<tr>
<td>含义</td>
<td>0（成功），1（信息/提示），2（警告），3（错误）</td>
<td>0（MS定义的代码），1（客户定义的代码）</td>
<td>必须为0</td>
<td>前256个值由MS保留</td>
<td>MS/客户定义的代码</td>
</tr>
</tbody></table>
<h2 id="字符与字符串处理"><a href="#字符与字符串处理" class="headerlink" title="字符与字符串处理"></a>字符与字符串处理</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>分为 ANSI 和 Unicode，Vista 的 Unicode 字符使用 UTF-16 编码</p>
<p><code>.NET Framework</code>始终使用 UTF-16 编码所有字符和字符串。</p>
<p>C语言中，数据类型<code>wchar_t</code>表示一个 UTF-16 字符，字符和字符串前加<code>L</code>提示编译器将该字符串用 UTF-16 编码，使用方法如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> c = <span class="string">L&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> buf[<span class="number">100</span>] = <span class="string">L&quot;A String&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>WinNT.h</code>提供了一些 typedef</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef char <span class="keyword">CHAR</span><span class="comment">;</span></span><br><span class="line">typedef wchar_t WCHAR；</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">CHAR</span> *PCHAR<span class="comment">;</span></span><br><span class="line">typedef <span class="keyword">CHAR</span> *PSTR<span class="comment">;</span></span><br><span class="line">typedef CONST <span class="keyword">CHAR</span> *PCSTR<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef WCHAR *PWCHAR<span class="comment">;</span></span><br><span class="line">typedef WCHAR *PWSTR<span class="comment">;</span></span><br><span class="line">typedef CONST WCHAR *PCWSTR<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>使用宏可以使得 Unicode 和 ANSI 子丰富都能通过编译，<code>WinNT.h</code>中还有如下类型和宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> WCHAR TCHAR, *PTCHAR, PTSTR;</span><br><span class="line"><span class="keyword">typedef</span> CONST WCHAR *PCTSTR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TEXT(quote) quote</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TEXT(quote) L##quote</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> CHAR TCHAR,*PTCHAR, PTSTR;</span><br><span class="line"><span class="keyword">typedef</span> CONST CHAR *PCTSTR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TEXT(quote) quote</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXT(quote) __TEXT(quote)</span></span><br></pre></td></tr></table></figure>

<p>使用时</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCHAR c = <span class="keyword">TEXT</span>(<span class="comment">&#x27;A&#x27;);</span></span><br><span class="line">TCHAR buf[<span class="number">100</span>] = <span class="keyword">TEXT</span>(<span class="string">&quot;A String&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Windows-中的-Unicode-函数和-ANSI-函数"><a href="#Windows-中的-Unicode-函数和-ANSI-函数" class="headerlink" title="Windows 中的 Unicode 函数和 ANSI 函数"></a>Windows 中的 Unicode 函数和 ANSI 函数</h3><p>如果一个 Windows 函数的多数列表中有字符串，则该函数通常有两个版本。例如<code>CreateWindowEx</code>有<code>CreateWindowExW</code>和<code>CreateWindowExA</code>两个版本，W 表示宽字节，A 表示 ANSI 字符。</p>
<p>使用时只需使用<code>CreateWindowEx</code>，在 <code>WinUser.h</code>中有如下宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CreateWindowEx CreateWindowExW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CreateWindowEx CreateWindowExA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>ANSI 版本一般只是分配内存，执行转换操作，然后调用 Unicode 函数。</p>
<p>程序中应尽量使用 Unicode 字符。</p>
<h3 id="C-运行库中的-Unicode-函数-和-ANSI-函数"><a href="#C-运行库中的-Unicode-函数-和-ANSI-函数" class="headerlink" title="C 运行库中的 Unicode 函数 和 ANSI 函数"></a>C 运行库中的 Unicode 函数 和 ANSI 函数</h3><p>一般不会互相调用。</p>
<p>对应于<code>strlen</code>的Unicode版本为<code>wcslen</code>，两个原型都在 <code>string.h</code>，<code>TChar.h</code>包含以下宏，可以使用 Unicode 或 ANSI 编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _tcslen wcslen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _tcslen strlen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="C运行库中的安全字符串函数"><a href="#C运行库中的安全字符串函数" class="headerlink" title="C运行库中的安全字符串函数"></a>C运行库中的安全字符串函数</h3><p>新版本的函数相对于旧版本在后面添加一个<code>_s</code>，并接受一个新的参数</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PTSTR _tcscpy (PTSTR strDestination, PCTSTR strSource);</span><br><span class="line">errno_t <span class="constructor">_tcscpy_s(PTSTR <span class="params">strDestination</span>, <span class="params">size_t</span> <span class="params">numberOfCharacters</span>, PCTSTR <span class="params">strSource</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>将一个可写的缓冲区作为参数传递时，必须同时提供他的大小，值是一个字符数。对缓冲区使用<code>_countof</code>宏（在<code>stdlib.h</code>中定义）计算这个值。</p>
<p>安全函数会检查指针不为NULL，整数在有效范围内，枚举值有效，缓冲区足够容纳结果数据。如果其中有任何一个失败，函数都会设置 error值并返回一个 errno_t 值指出成功或者失败（并不实际返回），debug 版本显示 Debug Assertion Failed 对话框，release 版本直接终止运行。</p>
<p>也可以自己定义一个函数，检测到参数无效时调用该函数。在这个函数中可以记录失败，附上调试器或者做其他工作。原型如下</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">InvalidParamenterHandler(PCTSTR <span class="params">expression</span>, PCTSTR <span class="params">function</span>, PCTSTR <span class="params">file</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">line</span>, <span class="params">uintptr_t</span><span class="operator">/</span><span class="operator">*</span><span class="params">pReserved</span><span class="operator">*</span><span class="operator">/</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>expression 描述了代码中可能出现的函数失败，比如<code>(L&quot;Buffer is too small&quot;&amp;&amp;0)</code>，function、file、line 分别描述了出现错误的函数名称、源代码文件和行号。</p>
<p>然后调用<code>_set_invalid_parameter_handler</code>注册这个处理程序，还要调用<code>_CrtSetReportMode(_CRT_ASSERT,0);</code>来禁止出现 Debug Assertion Failed 对话框。</p>
<p>定义了用于处理错误的函数后，使用安全函数时就可以检查返回的 errorno_t ，只有返回<code>S_OK</code>才表明函数调用成功，其他返回值在<code>error.h</code>中定义。</p>
<h3 id="控制字符串"><a href="#控制字符串" class="headerlink" title="控制字符串"></a>控制字符串</h3><p>C 运行库也有在执行字符串处理时提供控制的函数，如控制天重复或指定如何截断，也有 W 和 A 版本。</p>
<p>Cch 表示 Count of characters，使用 <code>_countof</code>宏获取， Cb 表示 count of bytes，使用 sizeof 获取。</p>
<p>这些函数返回一个 HRESULT</p>
<table>
<thead>
<tr>
<th>HRESULT值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>S_OK</td>
<td>成功</td>
</tr>
<tr>
<td>STRSAFE_E_INVALID_PARAMETER</td>
<td>失败，将 NULL 传给了一个参数</td>
</tr>
<tr>
<td>STRSAFE_E_INSUFFICIENT_BUFFER</td>
<td>失败，缓冲区太小</td>
</tr>
</tbody></table>
<h3 id="Windows-字符串处理函数"><a href="#Windows-字符串处理函数" class="headerlink" title="Windows 字符串处理函数"></a>Windows 字符串处理函数</h3><h3 id="推荐的字符和字符串处理方式"><a href="#推荐的字符和字符串处理方式" class="headerlink" title="推荐的字符和字符串处理方式"></a>推荐的字符和字符串处理方式</h3><p>编写程序时：</p>
<ul>
<li>将文本字符串视为字符的数组，而不是 char 或字节的数组</li>
<li>使用通用数据类型（如TCHAR/PTSTR)）表示文本字符和字符串</li>
<li>用明确的数据类型（如 BYTE/PBYTE）表示字节、字节指针和数据缓冲区</li>
<li>用 TEXT 或 <code>_T</code>宏（两者之一）表示字面量字符和字符串</li>
<li>执行全局替换（如用 PTSTR 替换 PSTR）</li>
<li>修改与字符串有关的计算。例如函数幼传入缓冲区大小的字符数而不是字节数时，应传入<code>_countof(szBuffer)</code>而不是<code>sizeof(szBuffer</code>。分配内存时按字节分配，所以应调用<code>malloc(nCharacters* sizeof(TCHAR))</code>而不是<code>malloc(nCharacters)</code>。</li>
<li>避免使用 printf 系列函数，尤其不要使用<code>%s</code>和<code>%S</code>占位符进行 ANSI 和 Unicode 字符串的转换。正确做法是使用 <code>MultiByteTowideChar</code> 和 <code>WideCharToMultiByte</code>函数</li>
<li><code>UNICODE</code>和<code>_UNICODE</code>符号要么同时指定，要么都不指定</li>
</ul>
<p>对于字符串处理函数</p>
<ul>
<li>始终使用安全的字符串处理函数</li>
<li>不要是哟个不安全的C运行库字符串处理函数</li>
<li>使用 <code>/GS</code> 和 <code>/RTCs</code> 编译器标志来自动检测缓冲区溢出</li>
<li>不要使用 Kernel32 方法进行字符串处理，如 lstrcat 和 lstrcpy</li>
<li>比较字符串时，应使用 <code>CompareStringOrdinal</code>，因为它非常快而且不考虑用户的区域设置。用户字符串一般要在用户界面上显式，对于这些字符串应使用<code>CompareString(Ex)</code>，因为它考虑用户的区域设置</li>
</ul>
<h3 id="Unicode-与-ANSI-字符串转换"><a href="#Unicode-与-ANSI-字符串转换" class="headerlink" title="Unicode 与 ANSI 字符串转换"></a>Unicode 与 ANSI 字符串转换</h3><h4 id="导出-ANSI-和-Unicode-DLL-函数"><a href="#导出-ANSI-和-Unicode-DLL-函数" class="headerlink" title="导出 ANSI 和 Unicode DLL 函数"></a>导出 ANSI 和 Unicode DLL 函数</h4><h4 id="判断文本是-ANSI-和-Unicode"><a href="#判断文本是-ANSI-和-Unicode" class="headerlink" title="判断文本是 ANSI 和 Unicode"></a>判断文本是 ANSI 和 Unicode</h4><h2 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h2><h3 id="内核对象概念"><a href="#内核对象概念" class="headerlink" title="内核对象概念"></a>内核对象概念</h3><p>内核对象由函数创建，每个内核对象都是一个内存块，由操作系统内核分配，只能由操作系统内核访问。程序通过调用 Windows 提供的函数操作内核对象。</p>
<p>调用一个创建内核对象的函数后，函数返回一个<strong>句柄</strong>（handle），标识了所创建的对象，它是进程相关的，可以被进程中的任何线程使用</p>
<p>除了内核对象，还有用户对象和GDI（Grapical Device Interface）对象。几乎所有创建内核对象的函数都有有一个允许我们指定安全属性信息的参数。</p>
<h4 id="使用计数（usage-count）"><a href="#使用计数（usage-count）" class="headerlink" title="使用计数（usage count）"></a>使用计数（usage count）</h4><p>操作系统内核知道当前有多少个进程正在使用一个特定的内核对象，因为内核对象都包含一个数据成员——使用计数。创建时，使用计数为 1，另一个进程获得对现有对象的访问权后，使用计数递增，进程终止时使用计数递减，使用计数为0时销毁该内核对象。</p>
<h4 id="内核对象安全性"><a href="#内核对象安全性" class="headerlink" title="内核对象安全性"></a>内核对象安全性</h4><p>内核对象可以用一个安全描述符（security descriptor，SD）保护。它描述了谁拥有对象，哪些用户允许访问或使用对象，那些组和用户拒绝访问此对象。</p>
<p>用于创建内核对象的所有函数几乎都有一个指向 <code>SECURITY_ATTRIBUTES</code>结构的指针作为参数，这个结构只有一个与安全性有关的成员<code>IpSecurityDescriptor</code>。</p>
<p>访问现有对象时，必须指定将对此对象进行何种操作，函数会进行安全检查。</p>
<h3 id="进程内核对象句柄表"><a href="#进程内核对象句柄表" class="headerlink" title="进程内核对象句柄表"></a>进程内核对象句柄表</h3><p>一个进程初始化时，系统将为其分配一个句柄表（handle table），这个句柄表仅供内核对象使用。</p>
<p>一个句柄表就是一个结构组成的数组，每个结构保护一个指向内核对象的指针，一个访问掩码（包含标志位的一个DWORD）和一些标志。</p>
<h4 id="创建内核对象"><a href="#创建内核对象" class="headerlink" title="创建内核对象"></a>创建内核对象</h4><p>进程初始化时，其句柄表为空。当进程内的一个线程调用一个会创建内核对象的函数时，内核将为这个对象分配并初始化一个内存块，然后内核扫描进程的句柄表，查找一个空白的记录项（empty entry），并对其进行初始化。</p>
<p>用于创建内核对象的任何函数都会返回一个与进程相关的句柄，这个句柄可以由同一个进程中运行的所有线程使用。系统用索引表示内核对象的信息保存在进程句柄表中的具体位置。要得到实际的索引值，聚丙酯应该右移两位来忽略 Windows 操作系统内部使用的最后两位。</p>
<p>调用一个函数时，如果它接受一个内核对象句柄作为参数，必须把 Create* 函数返回的值传给它。在内部，这个函数会查找进程的句柄表，获得目标内核对象的地址，然后用某种方式操作对象的数据结构。</p>
<p>如果传入一个无效的句柄，函数会失败，GetLastError 会返回6（ERROR_INVALID_HANDLE），由于句柄值实际上时作为进程句柄表的索引使用的，所以句柄与当前进程相关，无法供其他进程使用。否则实际引用的只是那个进程句柄表中位于同一个索引位置的内核对象。</p>
<p>使用函数创建内核对象失败时，返回的句柄值通常为0（NULL），所以第一个有效句柄值为4。另外有几个函数失败时会返回 -1（INVALID_HANDLE_VALUE）。</p>
<h4 id="关闭内核对象"><a href="#关闭内核对象" class="headerlink" title="关闭内核对象"></a>关闭内核对象</h4><p>无论用什么方法创建内核对象，都要调用<code>CloseHandle</code>向系统表明我们已经结束使用对象</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL </span><span class="keyword">CloseHandle(HANDLE </span>hobject);</span><br></pre></td></tr></table></figure>

<p>内部，该函数首先检查主调进程的句柄表，验证”传给函数的句柄值“标识的是”进程确实有权访问“的一个对象。如果句柄有效，系统将获得内核对象数据结构的地址，并将结构中的”使用计数“成员递减。如果句柄无效，分两种情况：如果程序是正常运行的，CloseHandle 将返回 FALSE，而 GetLastError 返回 ERROR_INVALID_HANDLE；如果进程正在被调试，系统将抛出异常（指定了无效的句柄）来方便调试。</p>
<p>CloseHandle 返回之前会清楚进程句柄表中对应的记录想，所以不能再试图使用它。</p>
<h3 id="跨进程边界共享内核对象"><a href="#跨进程边界共享内核对象" class="headerlink" title="跨进程边界共享内核对象"></a>跨进程边界共享内核对象</h3><h4 id="使用对象句柄继承"><a href="#使用对象句柄继承" class="headerlink" title="使用对象句柄继承"></a>使用对象句柄继承</h4><p>只有在进程之间有父子关系时，才能使用对象句柄继承。</p>
<p>父进程需要进行如下步骤：</p>
<p>首先父进程创建内核对象时，父进程必须向系统指出它希望这个对象的句柄是可继承的。初始化一个<code>SECURITY_ATTRIBUTES</code>，指定句柄可继承，并传给具体的 Create 函数</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES <span class="keyword">sa</span>;</span><br><span class="line"><span class="keyword">sa</span>.nLength = sizeof(<span class="keyword">sa</span>);</span><br><span class="line"><span class="keyword">sa</span>.nSecurityDescriptor = NULL;</span><br><span class="line"><span class="keyword">sa</span>.binheritHandle = TRUE; <span class="comment">// Make the returned handle inheritable</span></span><br><span class="line"></span><br><span class="line">HANDLE hMutex = CreateMutex(&amp;<span class="keyword">sa</span>, FALSE, NULL);</span><br></pre></td></tr></table></figure>

<p>进程句柄表中的记录项有一个标志位（最低位），默认为0，为1时表示这个句柄时科技城的。</p>
<p>然后由父进程生成子进程，通过调用<code>CreateProcess</code>函数完成，</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL </span>CreateProcess&#123;</span><br><span class="line">	PCTCTR pszApplicationName;</span><br><span class="line">	PTSTR pszCommandLine,</span><br><span class="line">	PSECURITY_ATTRIBUTES psaProcess,</span><br><span class="line">	PSECURITY_ATTRIBUTES psaThread,</span><br><span class="line">	<span class="keyword">BOOL </span><span class="keyword">bInheritHandles,</span></span><br><span class="line"><span class="keyword"></span>	DWORD dwCreationFlags,</span><br><span class="line">	PVOID pvEnvironment,</span><br><span class="line">	PCTSTR pszCurrentDirectory,</span><br><span class="line">	LPSTARTUPINFO pStartupInfo,</span><br><span class="line">	PPROCESS_INFORMATION pProcessInformation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>bInheritHandles</code>为TRUE，子进程就会继承父进程的“可继承的句柄”的值，系统创建子进程时，为子进程创建一个新的进程句柄表，并遍历父进程的句柄表，包含“可继承的句柄”的项都会被完整复制到子进程的句柄表。在子进程的句柄表中，复制项的位置与之前一致，所以子进程和父进程中对一个内核对象进行标识的句柄值也是一致的。内核对象的使用计数也会递增。</p>
<p>子进程不知道自己继承了句柄，为了使子进程得到继承的内核对象的句柄值，常见方式是将句柄值作为命令行参数传给子进程。也可以使用其他进程间通信技术，或者让父进程添加子进程知道的环境变量。</p>
<h4 id="改变句柄的标志"><a href="#改变句柄的标志" class="headerlink" title="改变句柄的标志"></a>改变句柄的标志</h4><p>使用<code>SetHandleInformation</code>函数可以修改函数标志</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">BOOL</span> SetHandleInformation&#123;</span><br><span class="line">	<span class="attribute">HANDLE</span> hObject,</span><br><span class="line">	DWORD dwMask,</span><br><span class="line">	DWORD dwFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hObject 标识了一个有效句柄，dwMask告诉我们向修改哪个或那些标志，目前每个句柄关联两个标志</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDLE_FLAG_INHERIT				0x00000001	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDLE_FLAG_PROTECT_FROM_CLOSE	0x00000002</span></span><br></pre></td></tr></table></figure>

<p><code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code>表示禁止系统关闭句柄</p>
<p>第三个参数指出希望把标志修改为什么。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开继承标志</span></span><br><span class="line"><span class="constructor">SetHandleInformation(<span class="params">hObj</span>, HANDLE_FLAG_INHERIT&lt;HANDLE_FLAG_INHERIT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭继承标志</span></span><br><span class="line"><span class="constructor">SetHandleInformation(<span class="params">hObj</span>, HANDLE_FLAG_INHERIT, 0)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="为对象命名"><a href="#为对象命名" class="headerlink" title="为对象命名"></a>为对象命名</h4><p>为对象命名也可以实现跨进程边界共享内核对象，多数内核对象都可以进行命名，创建内核对象的函数会有一个<code>pszName</code>参数，传入NULL时表示创建匿名对象，也可以传入字符串为对象命名。</p>
<p>MS 不存在保证对象名唯一的机制，所有对象共享同一个命名空间。</p>
<p>共享对象时，首先进程 A 创建一个命名的对象</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HANDLE</span> hMutexProcessA = CreateMutex(<span class="built_in">NULL</span>, <span class="literal">FALSE</span>, TEXT(<span class="string">&#x27;AMutex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>进程 B 执行</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HANDLE</span> hMutexProcessB = CreateMutex(<span class="built_in">NULL</span>, <span class="literal">FALSE</span> TEXT(<span class="string">&#x27;AMutex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>系统首先查看是否存在一个名为<code>AMutex</code>的内核对象，如果存在，接下来检查该对象的类型。进程 B 试图创建一个互斥量对象，AMutex 也是互斥量对象，检查通过。然后系统进行安全检查，验证调用者是否拥有对该对象的完全访问权限，如果是，系统会在 B 的句柄表中查找一个空白记录项，将其初始化为现存的内核对象。如果中间有一处检查失败，函数返回NULL。</p>
<p>创建内核对象的函数总是返回具有完全访问权限的句柄，如果需要限制句柄的访问权限，可以使用这些函数的扩展版本（EX）。</p>
<p>除了调用<code>Create*</code>函数，也可以使用<code>Open*</code>函数实现共享。Open函数在对象不存在时不会创建新的对象，只会调用失败。</p>
<p>通常使用 GUID 防止出现命名冲突。</p>
<h4 id="终端服务命名空间"><a href="#终端服务命名空间" class="headerlink" title="终端服务命名空间"></a>终端服务命名空间</h4><p>终端服务（Terminal Service）的情况不通，正在运行终端服务的计算机中，有多个用于内核对象的命名空间，其中一个是全局空间</p>
<p>可以使用<code>ProcessIdToSessinId</code>函数查看当前进程在哪个 Terminal Service 会话中运行（由kernel32.dll导出，在WinBase.h中声明）</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DWORD processID = GetCurrentProcessId();</span><br><span class="line">DWORD sessionID;</span><br><span class="line"><span class="keyword">if</span>(ProcessIdToSessionId(processID, &amp;sessionID)) &#123;</span><br><span class="line">	tprintf(TEXT(<span class="string">&#x27;Process &#x27;</span>%<span class="string">u&#x27; runs in Terminal Services session &#x27;</span>%<span class="string">u&#x27;, processID, sessionID&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个服务的命名内核对象始终位于全局命名空间内，默认情况下，终端服务中的应用程序把自己的内核对象放在会话的命名空间内。使用<code>Global\</code>前缀可以强制把一个命名对象放入全局命名空间</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HANDLE</span> h = CreateEvent(<span class="built_in">NULL</span>, <span class="literal">FALSE</span> <span class="literal">FALSE</span>, TEXT(<span class="string">&#x27;Global\\MyName&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>Local\</code>前缀显式指出希望将内核对象放入当前会话的命名空间。</p>
<h4 id="专有命名空间"><a href="#专有命名空间" class="headerlink" title="专有命名空间"></a>专有命名空间</h4><p>创建内核对象时，可以传入一个指向<code>SECURITY_ATTRIBUTES</code>结构的指针，来保护对象。Vista 之前，任何进程都能用任何指定的名称创建一个对象。可以创建专有的命名空间（类似 Global 和 Local）来保护对象。</p>
<p>创建边界（bondary），将对应于本地管理员（Local Administrators）的安全描述符（Security Identifier，SID）与它关联起来，然后创建或打开其名称被用作内核对象前缀的命名空间。</p>
<h4 id="复制对象句柄"><a href="#复制对象句柄" class="headerlink" title="复制对象句柄"></a>复制对象句柄</h4><p>使用<code>DuplicateHandle</code>函数可以获得一个进程句柄表的一个记录项，然后再另一个进程的句柄表中创建这个记录项的一个副本。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL DuplicateHandle (</span><br><span class="line">	<span class="keyword">HANDLE</span> hSourceProcessHandle,</span><br><span class="line">	<span class="keyword">HANDLE</span> hSourceHandle,</span><br><span class="line">	<span class="keyword">HANDLE</span> hTargetProcessHandle,</span><br><span class="line">	PHANDLE phTargetHandle,</span><br><span class="line">	DWORD dwDesiredAdress,</span><br><span class="line">	BOOL bInheritHandle,</span><br><span class="line">	DWORD dwOptions);</span><br></pre></td></tr></table></figure>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程由两部分组成：内核对象和地址空间，这个地址空间包含所有可执行文件或 DLL 模块的代码和数据，还有堆和栈的分配。</p>
<h3 id="第一个-Windows-程序"><a href="#第一个-Windows-程序" class="headerlink" title="第一个 Windows 程序"></a>第一个 Windows 程序</h3><p>入口点函数有两种</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="function">WINAPI <span class="title">_tWinMain</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hInstanceExe,</span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE,</span></span></span><br><span class="line"><span class="params"><span class="function">	PTSTR pszCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> nCmdShow)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">_tmain</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="params"><span class="function">	TCHAR *argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">	TCHAR *envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>链接可执行文件时，链接器选择正确的 C/C++ 运行库启动函数。启动函数会：</p>
<ul>
<li>获取指向新进程的完整命令行的一个指针</li>
<li>获取指向新进程的环境变量的一个指针</li>
<li>初始化 C/C++ 运行库的全局变量</li>
<li>初始化 C 运行库内存分配函数和其他底层 IO 使用的堆</li>
<li>调用所有全局变量和静态 C++ 类对象的构造函数</li>
</ul>
<p>程序可以访问的 C/C++ 运行库全局变量如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述和推荐使用的 Windows 函数</th>
</tr>
</thead>
<tbody><tr>
<td>_osver</td>
<td></td>
<td></td>
</tr>
<tr>
<td>_winmajor</td>
<td></td>
<td></td>
</tr>
<tr>
<td>_winminor</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__argc</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__argv</td>
<td></td>
<td></td>
</tr>
<tr>
<td>_environ</td>
<td></td>
<td></td>
</tr>
<tr>
<td>_pgmptr</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>之后会调用程序的入口点函数，入口点函数返回后，启动函数调用 C 运行库函数 exit，向其传递返回值<code>nMainTreVal</code>，exit 函数执行以下任务</p>
<ul>
<li>调用<code>_onexit</code>函数调用所注册的任何一个函数</li>
<li>调用所有全局和静态 C++ 类对象的析构函数</li>
<li>在 DEBUG 生成中，如果设置了<code>_CRTDBG_LEAK_CHECK_DF</code>标志，则通过调用<code>_CrtDumpMemoryLeaks</code>生成内存泄漏报告</li>
<li>调用操作系统的 ExitProcess 函数，想起传入 nMainRetVal。这会导致操作系统 kill 我们的进程，并设置其退出代码</li>
</ul>
<h4 id="进程实例句柄"><a href="#进程实例句柄" class="headerlink" title="进程实例句柄"></a>进程实例句柄</h4><p>加载到进程地址空间的每一个可执行文件或者 DLL 文件都有一个独一无二的实例句柄，可执行文件的实例被当作 WinMain 函数的第一个参数 hInstanceExe 传入，需要加载资源的函数调用中一般都要提供此句柄的值。比如从可执行文件中加载图标</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HICON LoadIcon &#123;</span><br><span class="line">	<span class="keyword">HINSTANCE</span> <span class="keyword">hInstance</span>,</span><br><span class="line">	PCTSTR pszIcon&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>Platform SDK 文档中，有些函数需要一个 HMODULE 类型的参数。HMODULE 和 HINSTANCE 完全相同。</p>
<p><code>GetModuleHandle</code>函数可以获取一个可执行文件或者 DLL 文件被加载到进程地址空间的什么位置</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMODULE <span class="constructor">GetModuleHandle(PCTSTR <span class="params">pszModule</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>pszModule 参数指定已在主调进程的地址空间中加载的一个可执行文件或 DLL 文件的名称。如果找到了指定的文件，会返回基地址，否则返回 NULL。如果传入 NULL，则返回主调进程的可执行文件的基地址。</p>
<p>如果代码在 DLL 中运行，为了知道代码在什么模块中运行，可以使用链接器提供的伪变量<code>__ImageBase</code>或者调用<code>GetModuleHandleEx</code>，第一个参数传入<code>GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS</code>，第二个参数传入当前函数的地址，该函数会用传入函数所在 DLL 的基地址填入第三个参数中。</p>
<p><code>GetModuleHandle</code>函数只检查主调进程的地址空间，如果传入 NULL，会返回进程的地址空间中的可执行文件的基地址，即使调用该函数的代码是在一个 DLL 文件中。</p>
<h4 id="进程前一个实例的句柄（hPrevInstance）"><a href="#进程前一个实例的句柄（hPrevInstance）" class="headerlink" title="进程前一个实例的句柄（hPrevInstance）"></a>进程前一个实例的句柄（hPrevInstance）</h4><p>C/C++ 运行库启动代码总是向 WinMain 的 hPrevInstance 参数传递 NULL，该参数用于16位 Windows 系统，平时不要引用这个参数。建议将 WinMain 按如下写法编写</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> WINAPI _tWinMain(</span><br><span class="line">	<span class="keyword">HINSTANCE</span> hInstanceExe,</span><br><span class="line">	<span class="keyword">HINSTANCE</span>,</span><br><span class="line">	PSTR pszCmdLine,</span><br><span class="line">	<span class="keyword">int</span> nCmdShow</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用<code>UNREFERENCED_PARAMETER</code>宏指出该参数未使用</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> APIENTRY _tWinMain(</span><br><span class="line">	<span class="keyword">HINSTANCE</span> <span class="keyword">hInstance</span>,</span><br><span class="line">	<span class="keyword">HINSTANCE</span> hPrevInstance,</span><br><span class="line">	LPTSTR lpCmdLine,</span><br><span class="line">	<span class="keyword">int</span> nCmdShow)&#123;</span><br><span class="line">UNREFERENCED_PARAMETER(hPrevInstance)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进程的命令行"><a href="#进程的命令行" class="headerlink" title="进程的命令行"></a>进程的命令行</h4><p>系统在创建一个新进程时，会传一个命令行给它。C于悉尼国库的启动代码开始执行一个 GUI 程序时，会调用 Windows 函数 GetCommandLine 来获取进程的完整命令行，忽略可执行文件的名称，然后将指向命令行剩余部分呢的一个指针传给 WinMain 的 pszCmdLine 参数。</p>
<p>虽然 pszCmdLine 指向的缓冲区可写，但应注意越界问题，最好将它当作只读的。</p>
<p>也可以像 C 运行库一样获取完整命令行</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTSTR GetCommandLine()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>利用 CommandLineToArgvW 可以将 Unicode 字符串分解为单独的标记</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PWSTR* <span class="title">CommandLineToArgvW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PWSTR pszCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span>* pNumArgs)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数指向一个命令行字符串，通常是<code>GetCommandLineW</code>函数调用的返回值，pNumArgs 参数是一个整数的地址，该整数会被设置位命令行中的实参数目。CommandLineArgW 返回一个 Uniclde 字符串指针数组的地址。</p>
<p>CommandLineToArgvW 在内部分配内存，如果需要手动释放内存，可以调用 HeapFree</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int nNumArgs;</span><br><span class="line"><span class="symbol">PWSTR</span> *ppArgv = <span class="symbol">CommandLineArgvW</span>(<span class="symbol">GetCommandLineW</span>(), &amp;nNumArgs);</span><br><span class="line"></span><br><span class="line">if (*ppArgv[<span class="number">1</span>] == <span class="symbol">L</span><span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">HeapFree</span>(<span class="symbol">GetProcessHeap</span>(), <span class="number">0</span>, ppArgv);</span><br></pre></td></tr></table></figure>

<h4 id="进程的环境变量"><a href="#进程的环境变量" class="headerlink" title="进程的环境变量"></a>进程的环境变量</h4><p>每个进程都有一个与它相关的环境块（environment block），这是在进程地址空间分配的一块内存，包含的字符串与下面类似</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=<span class="symbol">:</span><span class="symbol">:</span>=<span class="symbol">:</span><span class="symbol">:</span>\ ...</span><br><span class="line">VarName1=VarValue1\0</span><br><span class="line">VarName2=VarValue2\0 ...</span><br><span class="line">VarNameX=VarValueX\0</span><br><span class="line">\0</span><br></pre></td></tr></table></figure>

<p>除了第一个<code>=::=::\</code>字符串，还可能存在其他以<code>=</code>开头的字符串，它们不作为环境变量使用。</p>
<p>访问环境块的第一种方式是使用<code>GetEnvironmentStrings</code>函数获取完整的环境块，得到的字符串与上面一致。不再使用这块内存时，应使用<code>FreeEnvironmentStrings</code>释放。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PTSTR pEnvBlock = <span class="constructor">GetEnvironmentStrings()</span>;</span><br><span class="line"><span class="constructor">FreeEnvironmentStrings(<span class="params">pEnvBlock</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>第二种方式是 CUI 程序专用的，它通过应用程序 main 入口点函数接受的 <code>TCHAR* env[]</code>参数实现。env 是一个字符串指针数组，每个指针指向一个不同的环境变量（名称=值 的格式）。指向最后一个环境变量字符串的指针后面，会有一个 NULL 指针表明这是数组的末尾。以<code>=</code>开头的字符串在接收到 env 之前就会被移除。</p>
<p>环境变量中的空格是有意义的。<code>ABC=XYZ</code>不同于<code>ABC = XYZ</code>。</p>
<p>用户登录时，系统会创建 shell 进程，并将一组环境字符串与其关联，系统通过检查注册表中的两个注册表项来获得出事的环境字符串。</p>
<p>第一个注册表项包含应用于系统的所有环境变量的列表，<code>HKEY_LOCAL_MACHINE\SYSTEM\Current\Set\Control\Session Manager\Environment</code>，第二个注册表项包含应用于当前登录用户的所有环境变量的列表，<code>HKEY_CURRENT_USER\Environment</code>。</p>
<p>用户可以通过控制面板或者调用注册表函数修改注册表项。修改后，有些程序的主窗口可以接受 WM_SETTINGCHANGE 消息，更新环境块，如希望其立刻更新，可以使用如下方法</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendMessage(<span class="name">HWND_BROAUCAST</span>, WM_SETTINGCHANGE, <span class="number">0</span>, (<span class="name">LPARAM</span>)TEXT(<span class="string">&quot;Environment&quot;</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>通常，子进程会继承一组环境变量，与父进程相同。但是父进程可以控制哪些环境变量允许子进程继承。父进程和子进程不共享同一个环境块。</p>
<p>使用<code>GetEnvironmentVariable</code>可以检查环境变量是否存在，如果存在，它的值是什么</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DWORD</span> GetEnvironmentVariable(</span><br><span class="line">	PCTSTR pszName,</span><br><span class="line">	PTSTR pszValue,</span><br><span class="line">	<span class="built_in">DWORD</span> cchValue)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>字符串中有时包含可替换部分，如<code>%USERPROFILE%\Documents</code>，可以使用<code>ExpandEnvironmentStrings</code>替换</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DWORD</span> ExpandEnvironmentStrings(</span><br><span class="line">	PTCSTR pszSrc,</span><br><span class="line">	PTSTR pszDst,</span><br><span class="line">	<span class="built_in">DWORD</span> chSize)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>SetEnvironmentVaribal</code>添加删除或修改变量的值</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetEnvironmentVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PCTSTR pszName,</span></span></span><br><span class="line"><span class="params"><span class="function">	PCTSTR pszValue)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="进程的关联性"><a href="#进程的关联性" class="headerlink" title="进程的关联性"></a>进程的关联性</h4><p>通常，进程中的线程可以在主机的任何 CPU 上执行，但是也可以强迫进程在可用 CPU 的一个子集上运行，这称为“处理器关联性”（processor affinity）。</p>
<h4 id="进程的错误模式"><a href="#进程的错误模式" class="headerlink" title="进程的错误模式"></a>进程的错误模式</h4><p>每个进程都关联了一组标志，这些标志的作用是让系统直到进程如何响应严重错误，包括磁盘介质错误，未处理的异常，文件查找错误以及数据对其错误等。进程可以调用<code>SetErrorMode</code>告诉系统如何处理这些错误</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UINT</span> SetErrorMode(<span class="built_in">UINT</span> fuErrorMode);</span><br></pre></td></tr></table></figure>

<p>fuErrorMode 参数时下表中按位或的结果</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SEM_FAILCRITICALERROR</td>
<td>系统不显示严重错误处理程序（critical-error-handler）消息框，并将错误返回主调进程</td>
</tr>
<tr>
<td>SEM_NOGPFAULTERRORBOX</td>
<td>系统不显示常规保护错误（general-protection-fault）消息框，此标志只应该由调试程序设置；该调试程序用一个异常处理程序来自行处理常规保护（general protection，GP）错误</td>
</tr>
<tr>
<td>SEM_NOOPENFILEERRORBOX</td>
<td>系统查找文件关联，不显示消息框</td>
</tr>
<tr>
<td>SEM_NOALIGNMENTEAULTEXCEPT</td>
<td>系统自动修复内存对齐错误，并使应用程序看不到这些错误，对 x86/x64 处理器无效</td>
</tr>
</tbody></table>
<p>默认情况下，子进程会继承父进程的错误模式标志。</p>
<h4 id="进程当前所在的驱动器和目录"><a href="#进程当前所在的驱动器和目录" class="headerlink" title="进程当前所在的驱动器和目录"></a>进程当前所在的驱动器和目录</h4><p>如果不提供完整的路径名，各种 Windows 函数会在当前驱动器的当前目录查找文件和目录。系统在内部追踪记录着一个进程的当前驱动器或目录，这种信息以进程为单位维护，如果进程中的一个线程改变了当前目录，这个进程中的其他线程也会受到影响。</p>
<p>可以调用以下两个函数获取和设置所在进程的当前驱动器和目录</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD cctCCurDir,</span></span></span><br><span class="line"><span class="params"><span class="function">	PTSTR pszCurDir)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">SetCurrentDirectory</span><span class="params">(PCTSTR pszCurDir)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="进程的当前目录"><a href="#进程的当前目录" class="headerlink" title="进程的当前目录"></a>进程的当前目录</h4><p>系统跟踪记录进程的当前驱动器和目录，但它没有记录每个驱动器的当前目录。可以在环境变量中添加如下的字符串来指出各个驱动器的当前目录</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=<span class="symbol">C:</span>=<span class="symbol">C:</span>\Utility\bin</span><br><span class="line">=<span class="symbol">D:</span>=<span class="symbol">D:</span>\Program Files</span><br></pre></td></tr></table></figure>

<p>如果调用一个函数，传入的路径名限定的是当前驱动器以外的驱动器，系统会在进程的环境块中查找与指定的驱动器号关联的变量。如果找到，则将该变量的值作为当前目录使用，如果没有找到，则假定指定驱动器的当前目录为它的根目录。</p>
<p>如果父进程创建了一个希望传给子进程的环境块，紫荆城的环境块就不会自动继承父进程的当前目录。可以在子进程生成前，将这些驱动器号环境变量添加到环境块中。</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DWORD GetFul<span class="meta">lPathName(</span></span><br><span class="line">	PCTSTR pszFile,</span><br><span class="line">	DWORD cchPath,</span><br><span class="line">	PTSTR pszPath,</span><br><span class="line">	PTSTR <span class="comment">*ppszFilePart);</span></span><br><span class="line">	</span><br><span class="line">TCHAR szCurDir[MAX_PATH];</span><br><span class="line">DOWRD cchLength = GetFul<span class="meta">lPathName(</span>TEXT(<span class="string">&quot;C:&quot;</span>), MAX_PATH, szCurDir, <span class="meta">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>驱动器号环境变量通常必须放在环境块的开始处。</p>
<h4 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h4><p><code>GetVersion</code>函数的低位字为主版本号，高位字为次版本号。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GetVersionEx(POSVERSIONINFOEX pVersionInformaton)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	<span class="built_in">DWORD</span> dwOSVersionInfoSize,</span><br><span class="line">	<span class="built_in">DWORD</span> dwMajorVersion,</span><br><span class="line">	<span class="built_in">DWORD</span> dwMinorVersion,</span><br><span class="line">	<span class="built_in">DWORD</span> dwBuildNumber,</span><br><span class="line">	<span class="built_in">DWORD</span> dwPlatformId,</span><br><span class="line">	TCHAR szCSDversion[<span class="number">128</span>],</span><br><span class="line">	<span class="built_in">WORD</span> wServicePackMajor,</span><br><span class="line">	<span class="built_in">WORD</span> wServicePackMinor,</span><br><span class="line">	<span class="built_in">WORD</span> wSuiteMask,</span><br><span class="line">	<span class="built_in">BYTE</span> wProductType,</span><br><span class="line">	<span class="built_in">BYTE</span> wReserved,</span><br><span class="line">&#125; OSVERSIONINFOEX, *POSVERSIONINFOEX<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">BOOL VerifyVersionInfo(</span><br><span class="line">	POSVERSIONINFOEX pVersionInfomation,</span><br><span class="line">	<span class="built_in">DWORD</span> dwTypeMask,</span><br><span class="line">	DWORDLONG dwlConditionMask)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>dwTypeMask 参数指出我们初始化了此结构的那些成员，dwlConditionMask描述比较方式，可以使用宏来设置</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VER_SET_CONDITION(</span><br><span class="line">	DOWRDLONG dwlConditionMask,</span><br><span class="line">	<span class="type">ULONG</span> dwTypeBitMask,</span><br><span class="line">	<span class="type">ULONG</span> dwConditionMask)</span><br></pre></td></tr></table></figure>

<p>建立一组条件之后就可以调用 VerifyVersionInfo，成功返回非零值，如果返回0，说明主机系统不符合要求或者调用函数方式不正确，可以使用 GetLastError 查看错误原因。</p>
<h2 id="DLL-基础"><a href="#DLL-基础" class="headerlink" title="DLL 基础"></a>DLL 基础</h2><p>将 DLL 文件映像映射到调用进程的地址空间有两种方式：隐式载入时链接(implicit lod-time linking)或显式运行时链接(explicit run-time linking)，本章讨论隐式链接。</p>
<h3 id="DLL-和进程的地址空间"><a href="#DLL-和进程的地址空间" class="headerlink" title="DLL 和进程的地址空间"></a>DLL 和进程的地址空间</h3><p>DLL 不会拥有任何对象，DLL 中函数创建的对象都为调用线程活调用进程拥有。</p>
<p>一个模块提供一个内存分配函数的时候，必须同时提供另一个用来释放内存的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="function"><span class="title">EXEFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	PVOID pv = DLLFunc();</span><br><span class="line">	DLLFreeFunc(pv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PVOID <span class="function"><span class="title">DLLFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	PVOID pv = malloc(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">return</span>(pv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="function"><span class="title">DLLFreeFunc</span>(<span class="params">PVOID, pv</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> free(pv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纵观全局"><a href="#纵观全局" class="headerlink" title="纵观全局"></a>纵观全局</h3><p>如果一个可执行模块需要从另一个 DLL 模块中导入函数活变量，必须先构建 DLL 模块，然后构建可执行模块。</p>
<p>构建 DLL 模块：</p>
<ul>
<li>创建一个头文件，包含想要在 DLL 模块中导出的函数原型、结构以及符号。所有 DLL 的源文件都要包含这个头文件</li>
<li>创建 C/C++ 源文件来实现想要在 DLL 模块中导出的函数和变量</li>
<li>构建该 DLL 模块的时候，编译器会对每个源文件进程处理并生成一个 .obj 模块，每个源文件对应一个 .obj 模块</li>
<li>所有 .obj 模块构建完成后，链接器将所有 .obj 模块内容合并，产生一个单独的 DLL 映像文件，包含 DLL 中所有的二进制代码以及全局/静态变量</li>
<li>如果链接器检测到 DLL 源文件道出了至少一个函数活变量，那么链接器还会生成一个 .lib 文件，只列出了所有被导出的函数和变量的符号名，用于构建可执行模块</li>
</ul>
<p>构建可执行模块：</p>
<ul>
<li>在所有引用了导出的函数、变量、活符号的源文件中，包含上述 DLL 的头文件</li>
<li>创建 C/C++ 源文件实现功能</li>
<li>构建可执行模块时，编译器对每个源文件进行处理并生成一个 .obj 模块，没课源文件对应一个 .obj 模块</li>
<li>所有.obj模块构建完毕后，链接器把所有 .obj 模块的内容合并起来，产生一个单独的可执行映像文件，这个文件包含了可执行文件的所有二进制代码和全局/静态变量。除此以外，还包含一个导入段，包含它需要的 DLL 模块的名称和可执行文件的二进制代码从中引用的函数和符号名。操作系统加载程序会解析这个导入段</li>
<li>加载程序为新的进程创建一个虚拟地址空间，并将可执行模块映射到新进程的地址空间中，接着解析导入段，对导入段中每个 DLL进行定位，并映射到地址空间中</li>
</ul>
<h4 id="构建-DLL-模块"><a href="#构建-DLL-模块" class="headerlink" title="构建 DLL 模块"></a>构建 DLL 模块</h4><p>应只从 DLL 模块导出函数，不应导出变量和C++类。</p>
<p>Mylib.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYLIBAPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIBAPI extern <span class="meta-string">&quot;C&quot;</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">MYLIBAPI <span class="keyword">int</span> g_nResult;</span><br><span class="line"><span class="function">MYLIBAPI <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft, <span class="keyword">int</span> nRight)</span></span>;</span><br></pre></td></tr></table></figure>

<p>MylibFile1.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIBAPI extern <span class="meta-string">&quot;C&quot;</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Mylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_nResult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> nLeft, <span class="keyword">int</span> nRight)</span> </span>&#123;</span><br><span class="line">    g_nResult = nLeft + nRight;</span><br><span class="line">    <span class="keyword">return</span> g_nResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器看到 <code>__declspec(dllexport</code> 就知道应该在生成的 DLL 模块中导出该变量、函数或 C++ 类。需要被导出的变量和函数必须在头文件定义的前面加上<code>MYLIBAPI</code></p>
<p><code>extern &quot;C&quot;</code>只有在编写 C++ 代码时才能使用，告诉编译器不要对函数名或变量名进行改变。</p>
<p>可执行文件不应在 DLL 的头文件之前定义<code>MYLIBAPI</code>。可执行模块中的<code>MYLIBAPI</code>会被头文件定义为<code>declspec(dllimport)</code>，这样编译器就知道需要从 DLL 模块中导入变量或函数。</p>
<h4 id="构建可执行模块"><a href="#构建可执行模块" class="headerlink" title="构建可执行模块"></a>构建可执行模块</h4><p>MyExeFile1.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyLib\MyLib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> WINAPI _tWinMain(HINSTANCE, HINSTANCE, LPSTR, <span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> nLeft = <span class="number">10</span>, nRight = <span class="number">25</span>;</span><br><span class="line">    </span><br><span class="line">    TCHAR sz[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">StringCchPrintf</span>(sz, _countof(sz), <span class="built_in">TEXT</span>(<span class="string">&quot;%d + %d = %d&quot;</span>), nLeft, nRight, <span class="built_in">Add</span>(nLeft, nRight));</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, sz, <span class="built_in">TEXT</span>(<span class="string">&quot;Calculation&quot;</span>), MB_OK);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">StringCchPrintf</span>(sz, _countof(sz,), <span class="built_in">TEXT</span>(<span class="string">&quot;The result from the last Add is: %d&quot;</span>), g_nResult);</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, sz, <span class="built_in">TEXT</span>(<span class="string">&quot;Last result&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行可执行模块"><a href="#运行可执行模块" class="headerlink" title="运行可执行模块"></a>运行可执行模块</h4><p>启动一个可执行模块时，操作系统的加载程序会先为进程创建虚拟地址空间，接着把可执行模块映射到进程的地址空间中，之后加载程序会检查可执行程序的导入段，试图对所需的 DLL 进行定位并映射到进程的地址空间中。</p>
<p>导入段只包含 DLL 的名称，所以加载程序必须在用户的磁盘上搜索 DLL，顺序为：</p>
<ul>
<li>包含可执行文件的目录</li>
<li>Windows 的系统目录</li>
<li>16 位 的系统目录</li>
<li>Windows 目录</li>
<li>进程的当前目录</li>
<li>PATH 环境变量中列出的目录</li>
</ul>
<p>为了减少应用程序的载入时间，应该对自己的可执行模块和 DLL 模块进行基址重定位和绑定。</p>
<h2 id="DLL-高级技术"><a href="#DLL-高级技术" class="headerlink" title="DLL 高级技术"></a>DLL 高级技术</h2><h3 id="DLL-模块的显式载入和符号链接"><a href="#DLL-模块的显式载入和符号链接" class="headerlink" title="DLL 模块的显式载入和符号链接"></a>DLL 模块的显式载入和符号链接</h3><p>指在运行的过程中，显式地载入所需的 DLL 并显式地域想要输出的符号进行链接。</p>
<h4 id="显式载入-DLL-模块"><a href="#显式载入-DLL-模块" class="headerlink" title="显式载入 DLL 模块"></a>显式载入 DLL 模块</h4><p>使用以下两个函数将 DLL 映射到进程的地址空间</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibrary</span><span class="params">(PCTSTR pszDLLPathName)</span></span>;</span><br><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PCTSTR pszDLLPathName,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwFlags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数会定位 DLL，并试图将该文件映像映射到调用进程的地址空间中。返回的 HMODULE 表示文件映像被映射到的虚拟内存地址。</p>
<p>dwFlags 参数可以执行标志。</p>
<h4 id="显式卸载-DLL-模块"><a href="#显式卸载-DLL-模块" class="headerlink" title="显式卸载 DLL 模块"></a>显式卸载 DLL 模块</h4><p>当进程不需要引用 DLL 中的符号时，可以调用下面的函数显式卸载 DLL</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FreeLibrary</span><span class="params">(HMODULE hInstDll)</span></span>;</span><br><span class="line"><span class="function">VOID <span class="title">FreeLibraryAndExitThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HMODULE hInstDll,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwExitCode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不应在 DLL 中使用单独的 <code>FreeLibrary</code> 和 <code>ExitThread</code>代替上述函数。</p>
<p>即使 <code>LoadLibrary</code>和<code>LoadLibraryEx</code>载入的 DLL 影视磁盘上的同一个文件，也不能将他们返回的映射地址互换使用。</p>
<h4 id="显式地链接到导出符号"><a href="#显式地链接到导出符号" class="headerlink" title="显式地链接到导出符号"></a>显式地链接到导出符号</h4><p>通过调用以下函数在载入 DLL 后得到想要引用的符号地址</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HMODULE hInstDll,</span></span></span><br><span class="line"><span class="params"><span class="function">	PCSTR pszSymbolName)</span></span>;</span><br></pre></td></tr></table></figure>

<p>有两种方式指定希望得到的符号的地址</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过符号名</span></span><br><span class="line">FARPROC pfn = <span class="constructor">GetProcAddress(<span class="params">hInstDll</span>, <span class="string">&quot;SomeFuncInDll&quot;</span>)</span>;</span><br><span class="line"><span class="comment">// 通过序号,不推荐</span></span><br><span class="line">FARPROC pfn = <span class="constructor">GetProcAddress(<span class="params">hInstDll</span>, MAKEINTOSOURCE(2)</span>);</span><br></pre></td></tr></table></figure>

<p>在使用返回的函数指针调用函数之前，需要将它转型称为域函数签名匹配的类型。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef void (CALLBACK *PFN_DUMPMODULE)(HMODULE hModule)</span><br><span class="line"></span><br><span class="line">void <span class="constructor">DynamicDumpMoudle(HMODULE <span class="params">hModule</span>)</span>;	<span class="comment">// 在 DLL 中</span></span><br><span class="line"></span><br><span class="line">PFN_DUMPMODULE pfDumoModule = </span><br><span class="line">	(PFN_DUMPMODULE)<span class="constructor">GetProcAddress(<span class="params">hDll</span>, <span class="string">&quot;DumpModule&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (pfnDumpModule != NULL) &#123;</span><br><span class="line">	pfn<span class="constructor">DumpModule(<span class="params">hDll</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DLL-的入口点函数"><a href="#DLL-的入口点函数" class="headerlink" title="DLL 的入口点函数"></a>DLL 的入口点函数</h3><p>一个 DLL 可以有一个入口点函数，系统会在不同的时候调用这个入口点函数。这些调用是通知性质的，通常被 DLL 用来执行一些域进程或线程有关的初始化和清理工作。入口点函数不是必须实现的。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hInstDll, DWORD fdwReason, PVOID fImpLoad)</span> </span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (fdwReason) &#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">		<span class="comment">// DLL is being mapped into the process&#x27; address space</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">		<span class="comment">// A thread is being created</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">		<span class="comment">// A thread is exiting cleanly</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		/ The DLL is being unmapped from the process<span class="number">&#x27;</span> address space</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(TRUE); <span class="comment">// Used only for DLL_PROCESS_ATTACH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hInstDll 包含该 DLL 实例的句柄，表示一个虚拟内存地址。通常将它保存在一个全局变量中，这样在调用资源载入函数时可以使用它。</p>
<p>fImpLoad 当 DLL 是显式载入时为 0，否则不为零。</p>
<p>fdwReason 表示系统调用入口点函数的原因。</p>
<p>DllMain 只应进行简单的初始化，应避免调用从其他 DLL 中导入的函数，避免在 DllMain 中使用 LoadLibrary(Ex) 和 FreeLibrary。</p>
<h4 id="DLL-PROCESS-ATTACH"><a href="#DLL-PROCESS-ATTACH" class="headerlink" title="DLL_PROCESS_ATTACH"></a>DLL_PROCESS_ATTACH</h4><p>系统第一次将一个 DLL 映射到进程的地址空间中会调用 DllMain 并传入 DLL_PROCESS_ATTACH。如果之后一个线程再调用 LoadLibrary(Ex) 载入一个已经被映射到进程的地址空间的 DLL，那么操作系统只会增加该 DLL 的使用计数。</p>
<p>DllMain 的返回值用来表示该 DLL 是否初始化成功，成功应返回 TRUE，如果 fdwReason 不是 DLL_PROCESS_ATTACH，返回值将被忽略。</p>
<p>创建新进程时，系统会分配进程地址空间并将 exe 文件映像及所需的 DLL 文件映像映射到地址的进程空间中。然后系统将创建进程的主线程并用这个线程来调用每个 DLL 的 DllMain 函数，同时传入 DLL_PROCESS_ATTACH，然后让进程的主线程喀什执行可执行模块的 C/C++ 运行时的启动代码，然后执行可执行模块的入口点函数。如果任何一个 DLL 的 DllMain 函数返回 FALSE，系统会把所有文件映像从地址空间中清除，然后终止整个进程。</p>
<p>显式载入时，进程调用 LoadLibrary(Ex) ，系统会对指定的 DLL 进行定位，并将该 DLL 映射到进程地址空间中，然后系统会用调用 LoadLibrary(Ex)  的线程调用 DLL 的 DllMain，并传入 DLL_PROCESS_ATTACH，当 DllMain 函数完成处理后，系统会让 LoadLibrary(Ex) 调用返回。如果 DllMain 返回 FALSE，系统会自动从进程的地址空间中撤销对 DLL 文件映像的映射，然后让 LoadLibrary 返回 NULL。</p>
<h4 id="DLL-PROCESS-DETACH"><a href="#DLL-PROCESS-DETACH" class="headerlink" title="DLL_PROCESS_DETACH"></a>DLL_PROCESS_DETACH</h4><p>系统将一个 DLL 从地址空间撤销映射时，会调用 DLL 的 DllMain 函数，并在 fdwReason 中传入 DLL_PROCESS_DETACH。</p>
<p>只有当所有 DLL 都处理完 DLL_PROCESS_DETACH 之后，操作系统才会真正终止进程。</p>
<h4 id="DLL-THREAD-ATTACH"><a href="#DLL-THREAD-ATTACH" class="headerlink" title="DLL_THREAD_ATTACH"></a>DLL_THREAD_ATTACH</h4><p>系统不会让进程的主线程用 DLL_THREAD_ATTACH 调用 DllMain，只会使用 DLL_PROCESS_ATTACH。</p>
<h4 id="DLL-THREAD-DETACH"><a href="#DLL-THREAD-DETACH" class="headerlink" title="DLL_THREAD_DETACH"></a>DLL_THREAD_DETACH</h4><h4 id="DllMain-的序列化调用"><a href="#DllMain-的序列化调用" class="headerlink" title="DllMain 的序列化调用"></a>DllMain 的序列化调用</h4><h3 id="延迟载入-DLL"><a href="#延迟载入-DLL" class="headerlink" title="延迟载入 DLL"></a>延迟载入 DLL</h3><h3 id="函数转发器"><a href="#函数转发器" class="headerlink" title="函数转发器"></a>函数转发器</h3><h3 id="已知的-DLL"><a href="#已知的-DLL" class="headerlink" title="已知的 DLL"></a>已知的 DLL</h3><p>注册表项<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code>记录了已知的 DLL，操作系统载入它们时总会在同一个目录中查找。</p>
<h3 id="DLL-重定向"><a href="#DLL-重定向" class="headerlink" title="DLL 重定向"></a>DLL 重定向</h3><p>如果有一个<code>SuperApp.exe</code>文件，可以创建一个<code>SuperApp.exe.local</code>文件和一个<code>.local</code>文件夹。</p>
<p>LoadLibarary(Ex) 会检查这个文件是否存在，如果存在就会载入这个目录中的模块。</p>
<p>这个特性默认关闭，可能会使系统从应用程序的文件夹中载入伪造的系统 DLL。可以修改注册表<code>HKLM\Software\Microsoft\WindowsNT\CurrentVersion\Image File Execution Options</code>，增加一个条目<code>DWORD DevOverrideEnable</code>并设置为 1 .</p>
<h3 id="模块的基地址重定向"><a href="#模块的基地址重定向" class="headerlink" title="模块的基地址重定向"></a>模块的基地址重定向</h3><p>如果 DLL 无法被加载到希望的基地址，系统会打开模块的重定位段并遍历其中的条目。对每一个条目，加载程序会先找到包含机器指令的那个存储页面，然后将模块的首选及地址域模块的实际映射地址之间的差值加到机器指令当前使用的内存地址上。</p>
<p>这样做存在两个缺点：</p>
<ul>
<li>加载程序必须遍历重定位段并修改大量代码，损失性能</li>
<li>当加载程序写入到模块的代码页面时，系统的写时复制基址会强制这些页面以系统的页交换文件为后备存储器</li>
</ul>
<h3 id="模块的绑定"><a href="#模块的绑定" class="headerlink" title="模块的绑定"></a>模块的绑定</h3><h2 id="线程局部存储区"><a href="#线程局部存储区" class="headerlink" title="线程局部存储区"></a>线程局部存储区</h2><p>线程局部存储区（Thread Local Storage），将数据与线程关联起来。</p>
<h3 id="动态-TLS"><a href="#动态-TLS" class="headerlink" title="动态 TLS"></a>动态 TLS</h3><p>Windows 中每个进程都有一组正在使用标志(in-use flag)，每个标志可设置为 FREE 或 INUSE，表示该 TLS 元素是否正在使用。至少有 <code>TLS_MINIMUM_AVAILABLE</code> 个标志可使用。</p>
<p>应用程序使用一组 4 个函数使用动态 TLS</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORD TlsAlloc()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>对进程中的位标志进行检索，找到一个 FREE 标志。然后将该标志改为 INUSE，并返回该标志的索引，通常该索引存储在全局变量中。如果无法找到一个 FREE 标志，TlsAlloc 会返回 TLS_OUT_OF_INDEXS。</p>
<p>系统创建一个线程时，会分配 <code>TLS_MINIMUL_AVAILABLE</code> 个 PVOID 值，将他们初始化为 0，并与线程关联起来，每个线程都有自己的 PVOID 数组。TlsAlloc 返回的索引就是该线程此时可用的 PVOID 在数组中的索引。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TlsSetValue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwTlsIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID pvTlsValue)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数把 pvTlsValue 放入调用线程的 PVOID 数组中，成功返回 TRUE。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="constructor">TlsGetValue(DWORD <span class="params">dwTlsIndex</span>)</span>;</span><br><span class="line">BOOL <span class="constructor">TlsFree(DWORD <span class="params">dwTlsIndex</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>TlsFree 会将进程内对应的标志位重新设置为 FREE，还会将所有线程中该元素的内容设置为 0。</p>
<h3 id="静态-TLS"><a href="#静态-TLS" class="headerlink" title="静态 TLS"></a>静态 TLS</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">__declspec(<span class="params">thread</span>)</span> DOWRD t_dwStartTime = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这样声明的变量必须是全局变量<code>gt_</code>或者静态变量<code>st_</code></p>
<h2 id="DLL-注入和-API-拦截"><a href="#DLL-注入和-API-拦截" class="headerlink" title="DLL 注入和 API 拦截"></a>DLL 注入和 API 拦截</h2><h3 id="DLL注入的一个例子"><a href="#DLL注入的一个例子" class="headerlink" title="DLL注入的一个例子"></a>DLL注入的一个例子</h3><p>简单来说，就是不能使用<code>SetWindowLongPtr</code>从另一个进程地址空间中创建的窗口中派生子窗口</p>
<h3 id="使用注册表来注入-DLL"><a href="#使用注册表来注入-DLL" class="headerlink" title="使用注册表来注入 DLL"></a>使用注册表来注入 DLL</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\W</span>indows<span class="symbol">\A</span>ppInit_Dlls</span><br></pre></td></tr></table></figure>

<p>这个注册表键的值可能包含一个或多个 DLL 文件名（通过空格或逗号分隔）。第一个文件名可以包含路径，其他文件名的路径将被忽略。所以最好将自己的 DLL 放到 Windows 系统目录中。</p>
<p>当 User32.dll 映射到一个新的进程时，会收到 <code>DLL_PROCESS_ATTACH</code> 通知，此时它取出上述注册表键的值，并调用 <code>LoadLibrary</code> 载入这个字符串中指定的每个 DLL。被注入的 DLL 是在进程生命期的早期载入的，调用其他函数时应慎重，Kernel32.dll 中的函数基本可以正常使用。</p>
<p>缺点：</p>
<ul>
<li>这个 DLL 只会被映射到使用了 User32.dll 的进程中，对于多数使用 CUI 的程序不可行</li>
<li>每个基于 GUI 的进程都载入了这个 DLL，如果这个 DLL 出错影响会很大</li>
<li>在进程早期就注入了 DLL，使用后应该卸载这个 DLL</li>
</ul>
<h3 id="使用-Windows-挂钩来注入-DLL"><a href="#使用-Windows-挂钩来注入-DLL" class="headerlink" title="使用 Windows 挂钩来注入 DLL"></a>使用 Windows 挂钩来注入 DLL</h3><p>进程 A 需要查看系统中各窗口处理了哪些消息，它通过安装 hook 注入 dll</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HHOOK hHook</span> = SetWindowsHookEx(WH_GETMESSAGE, GetMsgProc, hInstDll, 0);</span><br></pre></td></tr></table></figure>

<p>第一个参数表示安装 hook 的类型，第二个参数时函数地址（在该进程的地址空间中），窗口即将处理消息时，会调用这个函数。第三个参数标识一个 DLL，这个 DLL 包含了 GetMsgProc 函数，hInstDll 的值时进程地址空间中 DLL 被映射到的虚拟内存地址。最后一个参数 0 表示给哪个进程安装挂钩。一个线程可能调用<code>SetWindowHookEx</code>并传入另一个线程的标识符。如果传入0，表示要给系统中所有 GUI 线程安装挂钩。</p>
<p>运行过程：</p>
<ol>
<li>进程 B 的一个线程准备向一个窗口发送一条消息</li>
<li>系统检查该线程是否安装了 <code>WH_GETMESSAGE</code> 挂钩</li>
<li>系统检查 <code>GetMsgProc</code> 所在的 DLL 是否被映射到了进程 B 的地址空间中</li>
<li>如果该 DLL 还未被映射，那么系统会强制该 DLL 映射到进程 B 的地址空间中，并将进程 B 中该 DLL 的锁计数器（lock count）递增</li>
<li>由于 DLL 的 hInstDll 是在进程 B 中映射的，系统会检查该 DLL在两个进程中的位置是否相同。如果相同，那么系统可以直接在 A 的地址空间中调用 <code>GetMsgProc</code>；如果不同，系统必须确定 <code>GetMsgProc</code> 在进程 B 的地址空间中的虚拟地址（<code>GetMsgProc B =  hInstDll B + (GetMsgProc A + hInstDll A)</code>）</li>
<li>系统在进程 B 中递增该 DLL 的所计数器</li>
<li>系统在进程 B 中调用 GetMsgProc 函数</li>
<li>GetMsgProc 返回时，系统递减该 DLL 在进程 B 中的锁计数器</li>
</ol>
<p>系统把挂钩过滤函数（hook filter function）所在的 DLL 注入或映射到地址空间中时，会映射整个 DLL 而不仅仅是挂钩过滤函数。</p>
<p>相比于使用注册表注入，该方法可以在不再需要该 DLL 时撤销映射</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="constructor">UnhookWindowsHookEx(HHOOK <span class="params">hHook</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>调用该函数时，系统遍历内部一个已经注入过该 DLL 的进程列表，并递减该 DLL 的锁计数器。当锁计数器递减到 0 的时候，系统会自动从进程的地址空间中撤销对该 DLL 的映射。锁计数器的意义在于防止进程 B 中的一个线程执行 GetMsgProc 时，另一个线程调用 UnhookWindowsHookEx，引发内存访问违规。</p>
<h3 id="使用远程线程注入-DLL"><a href="#使用远程线程注入-DLL" class="headerlink" title="使用远程线程注入 DLL"></a>使用远程线程注入 DLL</h3><p>第三种方法是使用远程线程（remote thread），提供了最高的灵活性。</p>
<p>根本上来说，DLL 注入要求目标线程中的一个线程调用 <code>LoadLibrary</code> 载入我们想要的 DLL。这种方法要求我们在目标进程中创建一个新的线程，使用<code>CreateRemoteThread</code>。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HANDLE</span> CreateRemoteThread(</span><br><span class="line">	<span class="keyword">HANDLE</span> hProcess,</span><br><span class="line">	PSECURITY_ATTRIBUTES psa,</span><br><span class="line">	DWORD dwStackSize,</span><br><span class="line">	PTHREAD_START_ROOTINE pfaStartAddr,</span><br><span class="line">	PVOID pvParam,</span><br><span class="line">	DWORD fdwCreate,</span><br><span class="line">	PDWORD pdwThreadId);</span><br></pre></td></tr></table></figure>

<p>除了第一个参数外，其余参数与 CreateThread 完全相同。第一个参数表示新建的进程由哪个进程所有。<code>pfaStartAddr</code> 是线程函数的内存地址，这个地址应该在远程进程（remote process）的地址空间中，而不是自己进程的空间中。</p>
<p>创建线程后，接下来需要调用 LoadLibrary 函数载入自己的 DLL。如果 DLL 名称以 ANSI 字符串存储就调用 LoadLibraryA，以 Unicode 存储就调用 LoadLibraryW。</p>
<p>LoadLibrary 与线程函数的函数原型基本相同，所以可以将线程函数的地址设置为 LoadLibraryA 或者 LoadLibraryW 的地址。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HANDLE</span> hThread = CreateRemoteThread(hProcessRemote, <span class="built_in">NULL</span>, <span class="number">0</span>, LoadLibraryW, L<span class="string">&quot;C:\\MyLib.dll&quot;</span>, <span class="number">0</span>, <span class="built_in">NULL</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">HANDLE</span> hThread = CreateRemoteThread(hProcessRemote, <span class="built_in">NULL</span>, <span class="number">0</span>, LoadLibraryA, <span class="string">&quot;C:\\MyLib.dll&quot;</span>, <span class="number">0</span>, <span class="built_in">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>此时还存在两个问题。</p>
<p>第一个是编译链接生成一个程序时，胜澈的二进制文件包含一个导入段。这个段由一系列传唤函数（thunk）构成，转换函数用于跳转到导入的函数。代码调用 LoadLibraryW 制类的函数时，链接器会生成一个调用，来调用我们模块中导入段的一个转换函数，转换函数之后会跳转到实际的函数。</p>
<p>如果直接引用 LoadLibraryW，该引用会被解析为模块导入段的 LoadLibraryW 的转换函数的地址。这个地址在远程线程中并不是 LoadLibraryW 的真正地址。所以必须通过 GetProcAddress 得到 LoadLibraryW 的确切地址。</p>
<p>每个应用程序都需要 Kernel32.dll，每个进程中 Kernel32.dll 都会被映射到同一个地址，但重启后可能改变。应像下面这样调用 CreateRemoteThread</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Get the real address of LoadLibraryW</span></span><br><span class="line">PTHREAD_START_ROUTINE pfnThreadRth = (PTHREAD_START_ROUTINE) <span class="constructor">GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;Kernel32&quot;</span>)</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">Handle hThread = <span class="constructor">CreateRemoteThread(<span class="params">hProcessRemote</span>, NULL, 0, <span class="params">pfnThreadRtn</span>, L<span class="string">&quot;C:\\MyLib.dll&quot;</span>, 0, NULL)</span>;</span><br></pre></td></tr></table></figure>

<p>第二个问题是字符串<code>&quot;C:\\MyLib.dll&quot;</code>位于调用进程的地址空间中。我们需要为 CreateRemoteThread 传入在远程进程的地址空间中存放字符串的地址。使用<code>VirtualAlloc</code>在另一个进程中分配空间</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PVOID VirtualAllocEx(</span><br><span class="line">	HANDLE hProcess,</span><br><span class="line">	PVOID pvAddress,</span><br><span class="line">	SIZE_T dwSize,</span><br><span class="line">	<span class="built_in">DWORD</span> flAllocationType,</span><br><span class="line">	<span class="built_in">DWORD</span> flProtect)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>VirtualFree</code>释放这块空间</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualFreeEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID pvAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwFreeType)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在另一个进程中分配空间后，还需要把字符串复制到该进程空间中。以下函数允许一个进程对另外一个进程的地址空间进行读写</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCVOID pvAddressRemote,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID pvBufferLocal,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	Size_T* pdwNumBytesRead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE hProess,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID pvAddressRemote,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCVOID pvBufferLocal,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T* pdwNumBytesWritten)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用远程线程注入 DLL 的步骤如下</p>
<ol>
<li>用 VirtualAllocEx 在远程进程的地址空间中分配一块内存</li>
<li>用 WriteProcessMemory 函数把 DLL 的路径名复制到上述空间中</li>
<li>用 GetProcAddress 获取 LoadLibraryW （在 Kernel32 中）的实际地址</li>
<li>用 CreateRemoteThread 在远程进程中创建一个线程，让新线程调用正确的 LoadLibraryW 并在参数中传入第一步分配的内存地址。 用于注入的 DLL 的 DllMain 函数会受到 DLL_PROCESS_ATTACH 并可以执行需要的代码。当 DllMain 返回时，远程线程会从 LoadLibrary 返回到 BaseThreadStart 函数，这个函数执行 ExitThread，线程终止</li>
<li>使用 VirtualFreeEx 释放第一步分配的内存</li>
<li>使用 GetProcAddress 获取 FreeLibrary 的实际地址</li>
<li>使用 CreateRemoteThread 在远程进程中创建一个线程，让远程线程调用 FreeLibrary，并在参数中传入远程 DLL 的HMODULE</li>
</ol>
<h3 id="使用木马-DLL-来注入-DLL"><a href="#使用木马-DLL-来注入-DLL" class="headerlink" title="使用木马 DLL 来注入 DLL"></a>使用木马 DLL 来注入 DLL</h3><p>另一种方式是，如果我们知道这个进程一定会载入某个 DLL，我们可以创建自己的 DLL 并给它起相同的文件名，然后替换掉原来的 DLL。</p>
<h3 id="把-DLL-作为调试器注入"><a href="#把-DLL-作为调试器注入" class="headerlink" title="把 DLL 作为调试器注入"></a>把 DLL 作为调试器注入</h3><h3 id="使用-CreateProcess-来注入代码"><a href="#使用-CreateProcess-来注入代码" class="headerlink" title="使用 CreateProcess 来注入代码"></a>使用 CreateProcess 来注入代码</h3><h3 id="API-拦截的一个例子"><a href="#API-拦截的一个例子" class="headerlink" title="API 拦截的一个例子"></a>API 拦截的一个例子</h3></div><div class="article-licensing box"><div class="licensing-title"><p>Windows 编程</p><p><a href="http://example.com/2021/01/19/windows/">http://example.com/2021/01/19/windows/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>lll</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-09-19</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/windows/">windows</a><a class="link-muted mr-2" rel="tag" href="/tags/notes/">notes</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/18/dns/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">DNS 相关</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/18/cpp/"><span class="level-item">cpp</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="lll"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">lll</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">52</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/1klnd" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CTF/"><span class="level-start"><span class="level-item">CTF</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Powershell/"><span class="level-start"><span class="level-item">Powershell</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/metasploit/"><span class="level-start"><span class="level-item">metasploit</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/notes/"><span class="level-start"><span class="level-item">notes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vulnhub/"><span class="level-start"><span class="level-item">vulnhub</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"><span class="level-start"><span class="level-item">漏洞复现</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-12T05:56:35.000Z">2022-07-12</time></p><p class="title"><a href="/2022/07/12/practical-reverse-engineering/">《逆向工程实战》 习题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-06T08:39:18.000Z">2021-10-06</time></p><p class="title"><a href="/2021/10/06/etw/">A Primer On Event Tracing For Windows (ETW)</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-18T13:39:32.000Z">2021-09-18</time></p><p class="title"><a href="/2021/09/18/PE/">PE 结构</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-30T05:59:59.000Z">2021-08-30</time></p><p class="title"><a href="/2021/08/30/struts2/">Struts2 漏洞 S2-001</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-22T03:51:23.000Z">2021-07-22</time></p><p class="title"><a href="/2021/07/22/vulhub-debug/">vulhub-debug</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Writeup/"><span class="tag">Writeup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/blackhat/"><span class="tag">blackhat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cheetsheet/"><span class="tag">cheetsheet</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crypto/"><span class="tag">crypto</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/db/"><span class="tag">db</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dev/"><span class="tag">dev</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/environment/"><span class="tag">environment</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etw/"><span class="tag">etw</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/flask/"><span class="tag">flask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/metasploit/"><span class="tag">metasploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/network/"><span class="tag">network</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/notes/"><span class="tag">notes</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pentest/"><span class="tag">pentest</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/powershell/"><span class="tag">powershell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/protocol/"><span class="tag">protocol</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pwn/"><span class="tag">pwn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redteam/"><span class="tag">redteam</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/reverse-engineering/"><span class="tag">reverse-engineering</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssr/"><span class="tag">ssr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vulnhub/"><span class="tag">vulnhub</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/windows/"><span class="tag">windows</span><span class="tag">5</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Windows-程序设计"><span class="level-left"><span class="level-item">1</span><span class="level-item">Windows 程序设计</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#窗口和消息"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">窗口和消息</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#总体结构"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">总体结构</span></span></a></li><li><a class="level is-mobile" href="#窗口生命周期"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">窗口生命周期</span></span></a></li><li><a class="level is-mobile" href="#部分标识符"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">部分标识符</span></span></a></li><li><a class="level is-mobile" href="#结构体"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">结构体</span></span></a></li><li><a class="level is-mobile" href="#句柄"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">句柄</span></span></a></li></ul></li><li><a class="level is-mobile" href="#输出文字"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">输出文字</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#绘制和更新"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">绘制和更新</span></span></a></li><li><a class="level is-mobile" href="#WM-PAINT-消息"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">WM_PAINT 消息</span></span></a></li><li><a class="level is-mobile" href="#有效矩形和无效矩形"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">有效矩形和无效矩形</span></span></a></li><li><a class="level is-mobile" href="#WM-SIZE"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">WM_SIZE</span></span></a></li><li><a class="level is-mobile" href="#GDI"><span class="level-left"><span class="level-item">1.2.5</span><span class="level-item">GDI</span></span></a></li></ul></li><li><a class="level is-mobile" href="#键盘"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">键盘</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基础"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">基础</span></span></a></li><li><a class="level is-mobile" href="#按键消息"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">按键消息</span></span></a></li><li><a class="level is-mobile" href="#字符消息"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">字符消息</span></span></a></li><li><a class="level is-mobile" href="#插入符号"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">插入符号</span></span></a></li></ul></li><li><a class="level is-mobile" href="#鼠标"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">鼠标</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#鼠标消息"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">鼠标消息</span></span></a></li><li><a class="level is-mobile" href="#非显示区域鼠标消息"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">非显示区域鼠标消息</span></span></a></li><li><a class="level is-mobile" href="#命中测试"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">命中测试</span></span></a></li><li><a class="level is-mobile" href="#拦截鼠标"><span class="level-left"><span class="level-item">1.4.4</span><span class="level-item">拦截鼠标</span></span></a></li><li><a class="level is-mobile" href="#鼠标滚轮"><span class="level-left"><span class="level-item">1.4.5</span><span class="level-item">鼠标滚轮</span></span></a></li></ul></li><li><a class="level is-mobile" href="#子窗口控件"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">子窗口控件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概述"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">概述</span></span></a></li><li><a class="level is-mobile" href="#按钮类"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">按钮类</span></span></a></li><li><a class="level is-mobile" href="#子窗口向父窗口发送消息"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">子窗口向父窗口发送消息</span></span></a></li><li><a class="level is-mobile" href="#父窗口向子窗口发送消息"><span class="level-left"><span class="level-item">1.5.4</span><span class="level-item">父窗口向子窗口发送消息</span></span></a></li><li><a class="level is-mobile" href="#改变按钮文字"><span class="level-left"><span class="level-item">1.5.5</span><span class="level-item">改变按钮文字</span></span></a></li><li><a class="level is-mobile" href="#可见和启用"><span class="level-left"><span class="level-item">1.5.6</span><span class="level-item">可见和启用</span></span></a></li><li><a class="level is-mobile" href="#静态类别"><span class="level-left"><span class="level-item">1.5.7</span><span class="level-item">静态类别</span></span></a></li><li><a class="level is-mobile" href="#滚动条类别"><span class="level-left"><span class="level-item">1.5.8</span><span class="level-item">滚动条类别</span></span></a></li><li><a class="level is-mobile" href="#编辑框类别"><span class="level-left"><span class="level-item">1.5.9</span><span class="level-item">编辑框类别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#菜单及其他资源"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">菜单及其他资源</span></span></a></li><li><a class="level is-mobile" href="#多任务和多线程"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">多任务和多线程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Windows-中的多线程"><span class="level-left"><span class="level-item">1.7.1</span><span class="level-item">Windows 中的多线程</span></span></a></li><li><a class="level is-mobile" href="#线程的同步"><span class="level-left"><span class="level-item">1.7.2</span><span class="level-item">线程的同步</span></span></a></li><li><a class="level is-mobile" href="#触发事件"><span class="level-left"><span class="level-item">1.7.3</span><span class="level-item">触发事件</span></span></a></li><li><a class="level is-mobile" href="#线程本地存储"><span class="level-left"><span class="level-item">1.7.4</span><span class="level-item">线程本地存储</span></span></a></li></ul></li><li><a class="level is-mobile" href="#动态链接库"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">动态链接库</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关于库的基本知识"><span class="level-left"><span class="level-item">1.8.1</span><span class="level-item">关于库的基本知识</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Windows-核心编程"><span class="level-left"><span class="level-item">2</span><span class="level-item">Windows 核心编程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#错误处理"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">错误处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Windows-函数的错误"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">Windows 函数的错误</span></span></a></li><li><a class="level is-mobile" href="#错误代码"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">错误代码</span></span></a></li><li><a class="level is-mobile" href="#自定义错误"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">自定义错误</span></span></a></li></ul></li><li><a class="level is-mobile" href="#字符与字符串处理"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">字符与字符串处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字符编码"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">字符编码</span></span></a></li><li><a class="level is-mobile" href="#数据类型"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">数据类型</span></span></a></li><li><a class="level is-mobile" href="#Windows-中的-Unicode-函数和-ANSI-函数"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">Windows 中的 Unicode 函数和 ANSI 函数</span></span></a></li><li><a class="level is-mobile" href="#C-运行库中的-Unicode-函数-和-ANSI-函数"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">C 运行库中的 Unicode 函数 和 ANSI 函数</span></span></a></li><li><a class="level is-mobile" href="#C运行库中的安全字符串函数"><span class="level-left"><span class="level-item">2.2.5</span><span class="level-item">C运行库中的安全字符串函数</span></span></a></li><li><a class="level is-mobile" href="#控制字符串"><span class="level-left"><span class="level-item">2.2.6</span><span class="level-item">控制字符串</span></span></a></li><li><a class="level is-mobile" href="#Windows-字符串处理函数"><span class="level-left"><span class="level-item">2.2.7</span><span class="level-item">Windows 字符串处理函数</span></span></a></li><li><a class="level is-mobile" href="#推荐的字符和字符串处理方式"><span class="level-left"><span class="level-item">2.2.8</span><span class="level-item">推荐的字符和字符串处理方式</span></span></a></li><li><a class="level is-mobile" href="#Unicode-与-ANSI-字符串转换"><span class="level-left"><span class="level-item">2.2.9</span><span class="level-item">Unicode 与 ANSI 字符串转换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内核对象"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">内核对象</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内核对象概念"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">内核对象概念</span></span></a></li><li><a class="level is-mobile" href="#进程内核对象句柄表"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">进程内核对象句柄表</span></span></a></li><li><a class="level is-mobile" href="#跨进程边界共享内核对象"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">跨进程边界共享内核对象</span></span></a></li></ul></li><li><a class="level is-mobile" href="#进程"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">进程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第一个-Windows-程序"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">第一个 Windows 程序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#DLL-基础"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">DLL 基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#DLL-和进程的地址空间"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">DLL 和进程的地址空间</span></span></a></li><li><a class="level is-mobile" href="#纵观全局"><span class="level-left"><span class="level-item">2.5.2</span><span class="level-item">纵观全局</span></span></a></li></ul></li><li><a class="level is-mobile" href="#DLL-高级技术"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">DLL 高级技术</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#DLL-模块的显式载入和符号链接"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">DLL 模块的显式载入和符号链接</span></span></a></li><li><a class="level is-mobile" href="#DLL-的入口点函数"><span class="level-left"><span class="level-item">2.6.2</span><span class="level-item">DLL 的入口点函数</span></span></a></li><li><a class="level is-mobile" href="#延迟载入-DLL"><span class="level-left"><span class="level-item">2.6.3</span><span class="level-item">延迟载入 DLL</span></span></a></li><li><a class="level is-mobile" href="#函数转发器"><span class="level-left"><span class="level-item">2.6.4</span><span class="level-item">函数转发器</span></span></a></li><li><a class="level is-mobile" href="#已知的-DLL"><span class="level-left"><span class="level-item">2.6.5</span><span class="level-item">已知的 DLL</span></span></a></li><li><a class="level is-mobile" href="#DLL-重定向"><span class="level-left"><span class="level-item">2.6.6</span><span class="level-item">DLL 重定向</span></span></a></li><li><a class="level is-mobile" href="#模块的基地址重定向"><span class="level-left"><span class="level-item">2.6.7</span><span class="level-item">模块的基地址重定向</span></span></a></li><li><a class="level is-mobile" href="#模块的绑定"><span class="level-left"><span class="level-item">2.6.8</span><span class="level-item">模块的绑定</span></span></a></li></ul></li><li><a class="level is-mobile" href="#线程局部存储区"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">线程局部存储区</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#动态-TLS"><span class="level-left"><span class="level-item">2.7.1</span><span class="level-item">动态 TLS</span></span></a></li><li><a class="level is-mobile" href="#静态-TLS"><span class="level-left"><span class="level-item">2.7.2</span><span class="level-item">静态 TLS</span></span></a></li></ul></li><li><a class="level is-mobile" href="#DLL-注入和-API-拦截"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">DLL 注入和 API 拦截</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#DLL注入的一个例子"><span class="level-left"><span class="level-item">2.8.1</span><span class="level-item">DLL注入的一个例子</span></span></a></li><li><a class="level is-mobile" href="#使用注册表来注入-DLL"><span class="level-left"><span class="level-item">2.8.2</span><span class="level-item">使用注册表来注入 DLL</span></span></a></li><li><a class="level is-mobile" href="#使用-Windows-挂钩来注入-DLL"><span class="level-left"><span class="level-item">2.8.3</span><span class="level-item">使用 Windows 挂钩来注入 DLL</span></span></a></li><li><a class="level is-mobile" href="#使用远程线程注入-DLL"><span class="level-left"><span class="level-item">2.8.4</span><span class="level-item">使用远程线程注入 DLL</span></span></a></li><li><a class="level is-mobile" href="#使用木马-DLL-来注入-DLL"><span class="level-left"><span class="level-item">2.8.5</span><span class="level-item">使用木马 DLL 来注入 DLL</span></span></a></li><li><a class="level is-mobile" href="#把-DLL-作为调试器注入"><span class="level-left"><span class="level-item">2.8.6</span><span class="level-item">把 DLL 作为调试器注入</span></span></a></li><li><a class="level is-mobile" href="#使用-CreateProcess-来注入代码"><span class="level-left"><span class="level-item">2.8.7</span><span class="level-item">使用 CreateProcess 来注入代码</span></span></a></li><li><a class="level is-mobile" href="#API-拦截的一个例子"><span class="level-left"><span class="level-item">2.8.8</span><span class="level-item">API 拦截的一个例子</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="panic" height="28"></a><p class="is-size-7"><span>&copy; 2022 lll</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>